"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/javascript-terminal-turtle";
exports.ids = ["vendor-chunks/javascript-terminal-turtle"];
exports.modules = {

/***/ "(ssr)/./node_modules/javascript-terminal-turtle/lib/terminal.js":
/*!*****************************************************************!*\
  !*** ./node_modules/javascript-terminal-turtle/lib/terminal.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(void 0, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_585__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_585__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_585__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_585__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_585__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_585__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_585__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_585__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_585__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_585__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_585__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_585__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_585__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_585__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_585__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_585__(__nested_webpack_require_585__.s = 0);\n    /******/ }({\n        /***/ \"./node_modules/balanced-match/index.js\": /*!**********************************************!*\\\n  !*** ./node_modules/balanced-match/index.js ***!\n  \\**********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            module1.exports = balanced;\n            function balanced(a, b, str) {\n                if (a instanceof RegExp) a = maybeMatch(a, str);\n                if (b instanceof RegExp) b = maybeMatch(b, str);\n                var r = range(a, b, str);\n                return r && {\n                    start: r[0],\n                    end: r[1],\n                    pre: str.slice(0, r[0]),\n                    body: str.slice(r[0] + a.length, r[1]),\n                    post: str.slice(r[1] + b.length)\n                };\n            }\n            function maybeMatch(reg, str) {\n                var m = str.match(reg);\n                return m ? m[0] : null;\n            }\n            balanced.range = range;\n            function range(a, b, str) {\n                var begs, beg, left, right, result;\n                var ai = str.indexOf(a);\n                var bi = str.indexOf(b, ai + 1);\n                var i = ai;\n                if (ai >= 0 && bi > 0) {\n                    begs = [];\n                    left = str.length;\n                    while(i >= 0 && !result){\n                        if (i == ai) {\n                            begs.push(i);\n                            ai = str.indexOf(a, i + 1);\n                        } else if (begs.length == 1) {\n                            result = [\n                                begs.pop(),\n                                bi\n                            ];\n                        } else {\n                            beg = begs.pop();\n                            if (beg < left) {\n                                left = beg;\n                                right = bi;\n                            }\n                            bi = str.indexOf(b, i + 1);\n                        }\n                        i = ai < bi && ai >= 0 ? ai : bi;\n                    }\n                    if (begs.length) {\n                        result = [\n                            left,\n                            right\n                        ];\n                    }\n                }\n                return result;\n            }\n        /***/ },\n        /***/ \"./node_modules/brace-expansion/index.js\": /*!***********************************************!*\\\n  !*** ./node_modules/brace-expansion/index.js ***!\n  \\***********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_7452__) {\n            var concatMap = __nested_webpack_require_7452__(/*! concat-map */ \"./node_modules/concat-map/index.js\");\n            var balanced = __nested_webpack_require_7452__(/*! balanced-match */ \"./node_modules/balanced-match/index.js\");\n            module1.exports = expandTop;\n            var escSlash = \"\\x00SLASH\" + Math.random() + \"\\x00\";\n            var escOpen = \"\\x00OPEN\" + Math.random() + \"\\x00\";\n            var escClose = \"\\x00CLOSE\" + Math.random() + \"\\x00\";\n            var escComma = \"\\x00COMMA\" + Math.random() + \"\\x00\";\n            var escPeriod = \"\\x00PERIOD\" + Math.random() + \"\\x00\";\n            function numeric(str) {\n                return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);\n            }\n            function escapeBraces(str) {\n                return str.split(\"\\\\\\\\\").join(escSlash).split(\"\\\\{\").join(escOpen).split(\"\\\\}\").join(escClose).split(\"\\\\,\").join(escComma).split(\"\\\\.\").join(escPeriod);\n            }\n            function unescapeBraces(str) {\n                return str.split(escSlash).join(\"\\\\\").split(escOpen).join(\"{\").split(escClose).join(\"}\").split(escComma).join(\",\").split(escPeriod).join(\".\");\n            }\n            // Basically just str.split(\",\"), but handling cases\n            // where we have nested braced sections, which should be\n            // treated as individual members, like {a,{b,c},d}\n            function parseCommaParts(str) {\n                if (!str) return [\n                    \"\"\n                ];\n                var parts = [];\n                var m = balanced(\"{\", \"}\", str);\n                if (!m) return str.split(\",\");\n                var pre = m.pre;\n                var body = m.body;\n                var post = m.post;\n                var p = pre.split(\",\");\n                p[p.length - 1] += \"{\" + body + \"}\";\n                var postParts = parseCommaParts(post);\n                if (post.length) {\n                    p[p.length - 1] += postParts.shift();\n                    p.push.apply(p, postParts);\n                }\n                parts.push.apply(parts, p);\n                return parts;\n            }\n            function expandTop(str) {\n                if (!str) return [];\n                // I don't know why Bash 4.3 does this, but it does.\n                // Anything starting with {} will have the first two bytes preserved\n                // but *only* at the top level, so {},a}b will not expand to anything,\n                // but a{},b}c will be expanded to [a}c,abc].\n                // One could argue that this is a bug in Bash, but since the goal of\n                // this module is to match Bash's rules, we escape a leading {}\n                if (str.substr(0, 2) === \"{}\") {\n                    str = \"\\\\{\\\\}\" + str.substr(2);\n                }\n                return expand(escapeBraces(str), true).map(unescapeBraces);\n            }\n            function identity(e) {\n                return e;\n            }\n            function embrace(str) {\n                return \"{\" + str + \"}\";\n            }\n            function isPadded(el) {\n                return /^-?0\\d/.test(el);\n            }\n            function lte(i, y) {\n                return i <= y;\n            }\n            function gte(i, y) {\n                return i >= y;\n            }\n            function expand(str, isTop) {\n                var expansions = [];\n                var m = balanced(\"{\", \"}\", str);\n                if (!m || /\\$$/.test(m.pre)) return [\n                    str\n                ];\n                var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n                var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n                var isSequence = isNumericSequence || isAlphaSequence;\n                var isOptions = m.body.indexOf(\",\") >= 0;\n                if (!isSequence && !isOptions) {\n                    // {a},b}\n                    if (m.post.match(/,.*\\}/)) {\n                        str = m.pre + \"{\" + m.body + escClose + m.post;\n                        return expand(str);\n                    }\n                    return [\n                        str\n                    ];\n                }\n                var n;\n                if (isSequence) {\n                    n = m.body.split(/\\.\\./);\n                } else {\n                    n = parseCommaParts(m.body);\n                    if (n.length === 1) {\n                        // x{{a,b}}y ==> x{a}y x{b}y\n                        n = expand(n[0], false).map(embrace);\n                        if (n.length === 1) {\n                            var post = m.post.length ? expand(m.post, false) : [\n                                \"\"\n                            ];\n                            return post.map(function(p) {\n                                return m.pre + n[0] + p;\n                            });\n                        }\n                    }\n                }\n                // at this point, n is the parts, and we know it's not a comma set\n                // with a single entry.\n                // no need to expand pre, since it is guaranteed to be free of brace-sets\n                var pre = m.pre;\n                var post = m.post.length ? expand(m.post, false) : [\n                    \"\"\n                ];\n                var N;\n                if (isSequence) {\n                    var x = numeric(n[0]);\n                    var y = numeric(n[1]);\n                    var width = Math.max(n[0].length, n[1].length);\n                    var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;\n                    var test = lte;\n                    var reverse = y < x;\n                    if (reverse) {\n                        incr *= -1;\n                        test = gte;\n                    }\n                    var pad = n.some(isPadded);\n                    N = [];\n                    for(var i = x; test(i, y); i += incr){\n                        var c;\n                        if (isAlphaSequence) {\n                            c = String.fromCharCode(i);\n                            if (c === \"\\\\\") c = \"\";\n                        } else {\n                            c = String(i);\n                            if (pad) {\n                                var need = width - c.length;\n                                if (need > 0) {\n                                    var z = new Array(need + 1).join(\"0\");\n                                    if (i < 0) c = \"-\" + z + c.slice(1);\n                                    else c = z + c;\n                                }\n                            }\n                        }\n                        N.push(c);\n                    }\n                } else {\n                    N = concatMap(n, function(el) {\n                        return expand(el, false);\n                    });\n                }\n                for(var j = 0; j < N.length; j++){\n                    for(var k = 0; k < post.length; k++){\n                        var expansion = pre + N[j] + post[k];\n                        if (!isTop || isSequence || expansion) expansions.push(expansion);\n                    }\n                }\n                return expansions;\n            }\n        /***/ },\n        /***/ \"./node_modules/concat-map/index.js\": /*!******************************************!*\\\n  !*** ./node_modules/concat-map/index.js ***!\n  \\******************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = function(xs, fn) {\n                var res = [];\n                for(var i = 0; i < xs.length; i++){\n                    var x = fn(xs[i], i);\n                    if (isArray(x)) res.push.apply(res, x);\n                    else res.push(x);\n                }\n                return res;\n            };\n            var isArray = Array.isArray || function(xs) {\n                return Object.prototype.toString.call(xs) === \"[object Array]\";\n            };\n        /***/ },\n        /***/ \"./node_modules/get-options/index.js\": /*!*******************************************!*\\\n  !*** ./node_modules/get-options/index.js ***!\n  \\*******************************************/ /*! no static exports found */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Class used internally to represent individual options.\n * @internal\n */ class Option {\n                /**\n\t * Create a new Option instance.\n\t *\n\t * @param {String|Array} names - Comma-separated list of names.\n\t * @param {String|Array} params - Arguments which the option expects.\n\t * @example new Option(\"-l, --long-list, --length\", \"<num> <type>\")\n\t * @example new Option(\"-e, --exec\", \"[num] [type]\")\n\t * @constructor\n\t */ constructor(names, params = \"\"){\n                    this.shortNames = [];\n                    this.longNames = [];\n                    this.params = [];\n                    this.values = [];\n                    this.defineNames(names);\n                    this.defineParams(params);\n                }\n                /**\n\t * Describe the names used to refer to this option.\n\t * \n\t * @param {String|Array} input\n\t * @internal\n\t */ defineNames(input) {\n                    if (!Array.isArray(input)) input = String(input).split(/,/g);\n                    for (let name of input){\n                        name = name.trim();\n                        /^-([^\\s-])$/.test(name) ? this.shortNames.push(RegExp.lastParen) : this.longNames.push(name.replace(/^-+/, \"\"));\n                    }\n                }\n                /**\n\t * Describe the parameters this option accepts/expects.\n\t *\n\t * @param {String|Array} input\n\t * @internal\n\t */ defineParams(input) {\n                    input = Array.isArray(input) ? input.filter(Boolean).join(\" \") : String(input).trim().split(/\\s+/g);\n                    // Strip any enclosing brackets added for readability\n                    input = input.map((param)=>param.replace(/^<(.+?)>$|^\\[(.+?)\\]$|^\\((.+?)\\)$/gm, (...args)=>args.slice(1, 4).filter(Boolean).join(\"\")));\n                    for (const param of input){\n                        if (!param) continue;\n                        const [, name, pattern = \".+\"] = param.match(/^([^=]+)(?:=(.+)?)?$/);\n                        this.params.push({\n                            name,\n                            pattern\n                        });\n                        if (/\\.{3}$/.test(name)) this.variadic = true;\n                    }\n                }\n                /**\n\t * Pattern to match option when expressed in bundled short-form.\n\t *\n\t * @readonly\n\t * @return {String}\n\t */ get bundlePattern() {\n                    // Use a cached result if possible\n                    if (this._bundlePattern) return this._bundlePattern;\n                    const param = this.params.map((param)=>`(${param.pattern})?`).join(\"\");\n                    const names = 1 === this.shortNames.length ? this.shortNames[0] : `[${this.shortNames.join(\"\")}]`;\n                    return this._bundlePattern = names + param;\n                }\n                /**\n\t * Number of parameters this option expects/accepts.\n\t *\n\t * @readonly\n\t * @property {Number}\n\t */ get arity() {\n                    return this.params ? this.params.length : 0;\n                }\n                /**\n\t * Array of names recognised by the option, both long and short.\n\t *\n\t * @readonly\n\t * @property {Array}\n\t */ get names() {\n                    return this.shortNames.concat(this.longNames);\n                }\n                /**\n\t * Whether the option can accept another parameter.\n\t *\n\t * @readonly\n\t * @property {Boolean}\n\t */ get canCollect() {\n                    return !!(this.variadic || this.values.length < this.params.length);\n                }\n            }\n            /**\n * Box a value inside an {@link Array}, unless it already is one.\n *\n * @example arrayify(1)   => [1]\n * @example arrayify([1]) => [1]\n * @param {*} input\n * @return {Array}\n * @internal\n */ function arrayify(input) {\n                return Array.isArray(input) ? input : [\n                    input\n                ];\n            }\n            /**\n * Strip leading dashes from an option name and convert it to camelCase.\n *\n * @param {String} input - An option's name, such as \"--write-to\"\n * @param {Boolean} noCamelCase - Strip leading dashes only\n * @return {String}\n * @internal\n */ function formatName(input, noCamelCase) {\n                input = input.replace(/^-+/, \"\");\n                // Convert kebab-case to camelCase\n                if (!noCamelCase && /-/.test(input)) input = input.toLowerCase().replace(/([a-z])-+([a-z])/g, (_, a, b)=>a + b.toUpperCase());\n                return input;\n            }\n            /**\n * Test a string against a list of patterns.\n *\n * @param {String} input\n * @param {String[]|RegExp[]} patterns\n * @return {Boolean}\n * @internal\n */ function match(input, patterns = []) {\n                if (!patterns || 0 === patterns.length) return false;\n                input = String(input);\n                patterns = arrayify(patterns).filter(Boolean);\n                for (const pattern of patterns)if (pattern === input && \"string\" === typeof pattern || pattern instanceof RegExp && pattern.test(input)) return true;\n                return false;\n            }\n            /**\n * Filter duplicate strings from an array.\n *\n * @param {String[]} input\n * @return {Array}\n * @internal\n */ function uniqueStrings(input) {\n                const output = {};\n                for(let i = 0, l = input.length; i < l; ++i)output[input[i]] = true;\n                return Object.keys(output);\n            }\n            /**\n * Parse a string as a whitespace-delimited list of options,\n * preserving quoted and escaped characters.\n *\n * @example unstringify(\"--foo --bar\")     => [\"--foo\", \"--bar\"];\n * @example unstringify('--foo \"bar baz\"') => [\"--foo\", '\"bar baz\"'];\n * @param {String} input\n * @return {Object}\n * @internal\n */ function unstringify(input) {\n                input = String(input || \"\");\n                const tokens = [];\n                const { length } = input;\n                let quoteChar = \"\"; // Quote-type enclosing current region\n                let tokenData = \"\"; // Characters currently being collected\n                let isEscaped = false; // Flag identifying an escape sequence\n                for(let i = 0; i < length; ++i){\n                    const char = input[i];\n                    // Previous character was a backslash\n                    if (isEscaped) {\n                        tokenData += char;\n                        isEscaped = false;\n                        continue;\n                    }\n                    // Whitespace: terminate token unless quoted\n                    if (!quoteChar && /[ \\t\\n]/.test(char)) {\n                        tokenData && tokens.push(tokenData);\n                        tokenData = \"\";\n                        continue;\n                    }\n                    // Backslash: escape next character\n                    if (\"\\\\\" === char) {\n                        isEscaped = true;\n                        // Swallow backslash if it escapes a metacharacter\n                        const next = input[i + 1];\n                        if (quoteChar && (quoteChar === next || \"\\\\\" === next) || !quoteChar && /[- \\t\\n\\\\'\"`]/.test(next)) continue;\n                    } else if ((!quoteChar || char === quoteChar) && /['\"`]/.test(char)) {\n                        quoteChar = quoteChar === char ? \"\" : char;\n                        continue;\n                    }\n                    tokenData += char;\n                }\n                if (tokenData) tokens.push(tokenData);\n                return tokens;\n            }\n            /**\n * Parse input using \"best guess\" logic. Called when no optdef is passed.\n *\n * Essentially, the following assumptions are made about input:\n *\n * - Anything beginning with at least one dash is an option name\n * - Options without arguments mean a boolean \"true\"\n * - Option-reading stops at \"--\"\n * - Anything caught between two options becomes the first option's value\n *\n * @param {Array} input\n * @param {Object} [config={}]\n * @return {Object}\n * @internal\n */ function autoOpts(input, config = {}) {\n                const opts = new Object(null);\n                const argv = [];\n                let argvEnd;\n                // Bail early if passed a blank string\n                if (!input) return opts;\n                // Stop parsing options after a double-dash\n                const stopAt = input.indexOf(\"--\");\n                if (stopAt !== -1) {\n                    argvEnd = input.slice(stopAt + 1);\n                    input = input.slice(0, stopAt);\n                }\n                for(let i = 0, l = input.length; i < l; ++i){\n                    let name = input[i];\n                    // Appears to be an option\n                    if (/^-/.test(name)) {\n                        // Equals sign is used, should it become the option's value?\n                        if (!config.ignoreEquals && /=/.test(name)) {\n                            const split = name.split(/=/);\n                            name = formatName(split[0], config.noCamelCase);\n                            opts[name] = split.slice(1).join(\"=\");\n                        } else {\n                            name = formatName(name, config.noCamelCase);\n                            // Treat a following non-option as this option's value\n                            const next = input[i + 1];\n                            if (next != null && !/^-/.test(next)) {\n                                // There's another option after this one. Collect multiple non-options into an array.\n                                const nextOpt = input.findIndex((s, I)=>I > i && /^-/.test(s));\n                                if (nextOpt !== -1) {\n                                    opts[name] = input.slice(i + 1, nextOpt);\n                                    // There's only one value to store; don't wrap it in an array\n                                    if (nextOpt - i < 3) opts[name] = opts[name][0];\n                                    i = nextOpt - 1;\n                                } else opts[name] = true;\n                            } else opts[name] = true;\n                        }\n                    } else argv.push(name);\n                }\n                // Add any additional arguments that were found after a \"--\" delimiter\n                if (argvEnd) argv.push(...argvEnd);\n                return {\n                    options: opts,\n                    argv: argv\n                };\n            }\n            /**\n * Extract command-line options from a list of strings.\n *\n * @param {String|Array} input\n * @param {String|Object} [optdef=null]\n * @param {Object} [config={}]\n */ function getOpts(input, optdef = null, config = {}) {\n                // Do nothing if given nothing\n                if (!input || 0 === input.length) return {\n                    options: {},\n                    argv: []\n                };\n                // Avoid modifying original array\n                if (Array.isArray(input)) input = [\n                    ...input\n                ].map(String);\n                else if (\"string\" === typeof input) input = unstringify(input);\n                // Take a different approach if optdefs aren't specified\n                if (null === optdef || \"\" === optdef || false === optdef) return autoOpts(input, config);\n                // Allow \"t:h:i:s\" style of getopt usage\n                if (\"[object String]\" === Object.prototype.toString.call(optdef)) {\n                    const names = optdef.match(/[^\\s:]:?/g);\n                    optdef = {};\n                    names.forEach((name)=>{\n                        optdef[`-${name.replace(/:/, \"\")}`] = name.length > 1 ? \"<arg>\" : \"\";\n                    });\n                }\n                // Parse settings that affect runtime option-handling\n                const { noAliasPropagation, noCamelCase, noBundling, noMixedOrder, noUndefined, terminator, ignoreEquals, duplicates = \"use-last\" } = config;\n                const shortNames = {};\n                const longNames = {};\n                const result = {\n                    argv: [],\n                    options: new Object(null)\n                };\n                // Define each named option. Throw an error if a duplicate is found.\n                for(const name in optdef){\n                    const option = new Option(name, optdef[name]);\n                    for (const name of option.shortNames){\n                        if (undefined !== shortNames[name]) throw new ReferenceError(`Short option \"-${name}\" already defined`);\n                        shortNames[`-${name}`] = option;\n                    }\n                    for (const name of option.longNames){\n                        if (undefined !== longNames[name]) throw new ReferenceError(`Long option \"--${name}\" already defined`);\n                        longNames[`--${name}`] = option;\n                    }\n                }\n                // Pointer to the option that's currently picking up arguments\n                let currentOption;\n                // Manage duplicated option values\n                function resolveDuplicate(option, name, value) {\n                    switch(duplicates){\n                        // Use the first value (or set of values); discard any following duplicates\n                        case \"use-first\":\n                            return result.options[name];\n                        // Use the last value (or set of values); discard any preceding duplicates. Default.\n                        case \"use-last\":\n                        default:\n                            return result.options[name] = value;\n                        // Use the first/last options; treat any following/preceding duplicates as argv items respectively\n                        case \"limit-first\":\n                        case \"limit-last\":\n                            result.argv.push(option.prevMatchedName, ...arrayify(value));\n                            break;\n                        // Throw an exception\n                        case \"error\":\n                            const error = new TypeError(`Attempting to reassign option \"${name}\" with value(s) ${JSON.stringify(value)}`);\n                            error.affectedOption = option;\n                            error.affectedValue = value;\n                            throw error;\n                        // Add parameters of duplicate options to the argument list of the first\n                        case \"append\":\n                            const oldValues = arrayify(result.options[name]);\n                            const newValues = arrayify(value);\n                            result.options[name] = oldValues.concat(newValues);\n                            break;\n                        // Store parameters of duplicated options in a multidimensional array\n                        case \"stack\":\n                            {\n                                let oldValues = result.options[name];\n                                const newValues = arrayify(value);\n                                // This option hasn't been \"stacked\" yet\n                                if (!option.stacked) {\n                                    oldValues = arrayify(oldValues);\n                                    result.options[name] = [\n                                        oldValues,\n                                        newValues\n                                    ];\n                                    option.stacked = true;\n                                } else result.options[name].push(arrayify(newValues));\n                                break;\n                            }\n                        // Store each duplicated value in an array using the order they appear\n                        case \"stack-values\":\n                            {\n                                let values = result.options[name];\n                                // First time \"stacking\" this option (nesting its value/s inside an array)\n                                if (!option.stacked) {\n                                    const stack = [];\n                                    for (const value of arrayify(values))stack.push([\n                                        value\n                                    ]);\n                                    values = stack;\n                                    option.stacked = true;\n                                }\n                                arrayify(value).forEach((v, i)=>{\n                                    // An array hasn't been created at this index yet,\n                                    // because an earlier option wasn't given enough parameters.\n                                    if (undefined === values[i]) values[i] = Array(values[0].length - 1);\n                                    values[i].push(v);\n                                });\n                                result.options[name] = values;\n                                break;\n                            }\n                    }\n                }\n                // Assign an option's parsed value to the result's `.options` property\n                function setValue(option, value) {\n                    // Assign the value only to the option name it matched\n                    if (noAliasPropagation) {\n                        let name = option.lastMatchedName;\n                        // Special alternative:\n                        // In lieu of using the matched option name, use the first --long-name only\n                        if (\"first-only\" === noAliasPropagation) name = option.longNames[0] || option.shortNames[0];\n                        // camelCase?\n                        name = formatName(name, noCamelCase);\n                        // This option's already been set before\n                        if (result.options[name]) resolveDuplicate(option, name, value);\n                        else result.options[name] = value;\n                    } else {\n                        const { names } = option;\n                        for (let name of names){\n                            // Decide whether to camelCase this option name\n                            name = formatName(name, noCamelCase);\n                            // Ascertain if this option's being duplicated\n                            if (result.options[name]) resolveDuplicate(option, name, value);\n                            result.options[name] = value;\n                        }\n                    }\n                }\n                // Push whatever we've currently collected for this option and reset pointer\n                function wrapItUp() {\n                    let optValue = currentOption.values;\n                    // Don't store solitary values in an array. Store them directly as strings\n                    if (1 === currentOption.arity && !currentOption.variadic) optValue = optValue[0];\n                    setValue(currentOption, optValue);\n                    currentOption.values = [];\n                    currentOption = null;\n                }\n                // Reverse the order of an argument list, keeping options and their parameter lists intact\n                function flip(input) {\n                    input = input.reverse();\n                    // Flip any options back into the right order\n                    for(let i = 0, l = input.length; i < l; ++i){\n                        const arg = input[i];\n                        const opt = shortNames[arg] || longNames[arg];\n                        if (opt) {\n                            const from = Math.max(0, i - opt.arity);\n                            const to = i + 1;\n                            const extract = input.slice(from, to).reverse();\n                            input.splice(from, extract.length, ...extract);\n                        }\n                    }\n                    return input;\n                }\n                // Tackle bundling. Ensure there's at least one option with a short name to work with.\n                const nameKeys = Object.keys(shortNames);\n                let bundleMatch, bundlePatterns, niladicArgs;\n                if (!noBundling && nameKeys.length) {\n                    bundlePatterns = uniqueStrings(nameKeys.map((n)=>shortNames[n].bundlePattern)).join(\"|\");\n                    bundleMatch = new RegExp(`^-(${bundlePatterns})+`, \"g\");\n                    niladicArgs = uniqueStrings(nameKeys.filter((n)=>!shortNames[n].arity).map((n)=>shortNames[n].bundlePattern)).join(\"|\");\n                    niladicArgs = new RegExp(`^(-(?:${niladicArgs})+)((?!${bundlePatterns})\\\\S+)`);\n                    bundlePatterns = new RegExp(bundlePatterns, \"g\");\n                }\n                // Is pre-processing of the argument list necessary?\n                if (!ignoreEquals || bundleMatch) {\n                    // Limit equals-sign expansion to items that begin with recognised option names\n                    const legalNames = new RegExp(`^(?:${Object.keys(longNames).join(\"|\")})=`);\n                    for(let i = 0, l = input.length; i < l; ++i){\n                        let arg = input[i];\n                        // We have bundling in use\n                        if (bundleMatch) {\n                            bundleMatch.lastIndex = 0;\n                            // Expand bundled option clusters (\"-mvl2\" -> \"-m -v -l 2\")\n                            if (bundleMatch.test(arg)) {\n                                // Break off arguments attached to niladic options\n                                const niladicMatch = arg.match(niladicArgs);\n                                if (niladicMatch) {\n                                    niladicArgs.lastIndex = 0;\n                                    arg = niladicMatch[1];\n                                    input.splice(i + 1, 0, niladicMatch[2]);\n                                    l = input.length;\n                                }\n                                const segments = [].concat(...arg.match(bundlePatterns).map((m)=>{\n                                    const option = shortNames[`-${m[0]}`];\n                                    const result = [\n                                        `-${m[0]}`\n                                    ];\n                                    if (!option.arity) return result;\n                                    result.push(...m.match(new RegExp(option.bundlePattern)).slice(1).filter((i)=>i));\n                                    return result;\n                                }));\n                                input.splice(i, 1, ...segments);\n                                l = input.length;\n                                i += segments.length - 1;\n                                continue;\n                            }\n                        }\n                        // Expand \"--option=value\" sequences to become \"--option value\"\n                        if (legalNames.test(arg)) {\n                            const match = arg.match(/^([^=]+)=(.+)$/);\n                            input.splice(i, 1, match[1], match[2]);\n                            l = input.length;\n                            i += 1;\n                        }\n                    }\n                }\n                // If we're handling duplicate options with \"limit-last\", flip the input order\n                if (\"limit-last\" === duplicates) input = flip(input);\n                // Start processing the arguments we were given to handle\n                for(let i = 0, l = input.length; i < l; ++i){\n                    const arg = input[i];\n                    const opt = shortNames[arg] || longNames[arg];\n                    // This argument matches a recognised option name\n                    if (opt) {\n                        // Record the name given on command-line that matched the option\n                        opt.lastMatchedName = arg;\n                        // Did we have an existing option that was collecting values?\n                        if (currentOption) wrapItUp();\n                        // Option takes at least one argument\n                        if (opt.arity) currentOption = opt;\n                        else setValue(opt, true);\n                        // Store an additional back-reference to the current option's name\n                        opt.prevMatchedName = arg;\n                    } else {\n                        const isTerminator = match(arg, terminator);\n                        const keepRest = ()=>result.argv.push(...input.slice(i + 1));\n                        // A previous option is still collecting arguments\n                        if (currentOption && currentOption.canCollect && !isTerminator) currentOption.values.push(arg);\n                        else {\n                            currentOption && wrapItUp();\n                            // Terminate option parsing?\n                            if (isTerminator) {\n                                keepRest();\n                                break;\n                            }\n                            // Raise an exception if unrecognised switches are considered an error\n                            if (noUndefined && /^-./.test(arg)) {\n                                let error = noUndefined;\n                                // Prepare an error object to be thrown in the user's direction\n                                switch(typeof noUndefined){\n                                    case \"function\":\n                                        error = error(arg);\n                                        break;\n                                    case \"boolean\":\n                                        error = 'Unknown option: \"%s\"'; // Fall-through\n                                    case \"string\":\n                                        error = new TypeError(error.replace(\"%s\", arg));\n                                }\n                                throw error;\n                            }\n                            result.argv.push(arg);\n                            // Finish processing if mixed-order is disabled\n                            if (noMixedOrder) {\n                                keepRest();\n                                break;\n                            }\n                        }\n                    }\n                }\n                // Ended abruptly?\n                if (currentOption) wrapItUp();\n                // Check if we need to flip the returned .argv array back into the right order again\n                if (\"limit-last\" === duplicates) result.argv = flip(result.argv);\n                return result;\n            }\n            if (\"undefined\" !== typeof module1.exports) module1.exports = getOpts;\n        /***/ },\n        /***/ \"./node_modules/immutable/dist/immutable.es.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/immutable/dist/immutable.es.js ***!\n  \\*****************************************************/ /*! exports provided: default, version, Collection, Iterable, Seq, Map, OrderedMap, List, Stack, Set, OrderedSet, Record, Range, Repeat, is, fromJS, hash, isImmutable, isCollection, isKeyed, isIndexed, isAssociative, isOrdered, isValueObject, get, getIn, has, hasIn, merge, mergeDeep, mergeWith, mergeDeepWith, remove, removeIn, set, setIn, update, updateIn */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_42902__) {\n            \"use strict\";\n            __nested_webpack_require_42902__.r(__nested_webpack_exports__);\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"version\", function() {\n                return version;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"Collection\", function() {\n                return Collection;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"Iterable\", function() {\n                return Iterable;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"Seq\", function() {\n                return Seq;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"Map\", function() {\n                return Map;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"OrderedMap\", function() {\n                return OrderedMap;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"List\", function() {\n                return List;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"Stack\", function() {\n                return Stack;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"Set\", function() {\n                return Set;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"OrderedSet\", function() {\n                return OrderedSet;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"Record\", function() {\n                return Record;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"Range\", function() {\n                return Range;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"Repeat\", function() {\n                return Repeat;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"is\", function() {\n                return is;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"fromJS\", function() {\n                return fromJS;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"hash\", function() {\n                return hash;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"isImmutable\", function() {\n                return isImmutable;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"isCollection\", function() {\n                return isCollection;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"isKeyed\", function() {\n                return isKeyed;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"isIndexed\", function() {\n                return isIndexed;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"isAssociative\", function() {\n                return isAssociative;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"isOrdered\", function() {\n                return isOrdered;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"isValueObject\", function() {\n                return isValueObject;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"get\", function() {\n                return get;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"getIn\", function() {\n                return getIn;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"has\", function() {\n                return has;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"hasIn\", function() {\n                return hasIn;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"merge\", function() {\n                return merge$1;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"mergeDeep\", function() {\n                return mergeDeep;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"mergeWith\", function() {\n                return mergeWith$1;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"mergeDeepWith\", function() {\n                return mergeDeepWith;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"remove\", function() {\n                return remove;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"removeIn\", function() {\n                return removeIn;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"set\", function() {\n                return set;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"setIn\", function() {\n                return setIn;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"update\", function() {\n                return update;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_42902__.d(__nested_webpack_exports__, \"updateIn\", function() {\n                return updateIn;\n            });\n            /**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ // Used for setting prototype methods that IE8 chokes on.\n            var DELETE = \"delete\";\n            // Constants describing the size of trie nodes.\n            var SHIFT = 5; // Resulted in best performance after ______?\n            var SIZE = 1 << SHIFT;\n            var MASK = SIZE - 1;\n            // A consistent shared value representing \"not set\" which equals nothing other\n            // than itself, and nothing that could be provided externally.\n            var NOT_SET = {};\n            // Boolean references, Rough equivalent of `bool &`.\n            function MakeRef() {\n                return {\n                    value: false\n                };\n            }\n            function SetRef(ref) {\n                if (ref) {\n                    ref.value = true;\n                }\n            }\n            // A function which returns a value representing an \"owner\" for transient writes\n            // to tries. The return value will only ever equal itself, and will not equal\n            // the return of any subsequent call of this function.\n            function OwnerID() {}\n            function ensureSize(iter) {\n                if (iter.size === undefined) {\n                    iter.size = iter.__iterate(returnTrue);\n                }\n                return iter.size;\n            }\n            function wrapIndex(iter, index) {\n                // This implements \"is array index\" which the ECMAString spec defines as:\n                //\n                //     A String property name P is an array index if and only if\n                //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n                //     to 2^32−1.\n                //\n                // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n                if (typeof index !== \"number\") {\n                    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n                    if (\"\" + uint32Index !== index || uint32Index === 4294967295) {\n                        return NaN;\n                    }\n                    index = uint32Index;\n                }\n                return index < 0 ? ensureSize(iter) + index : index;\n            }\n            function returnTrue() {\n                return true;\n            }\n            function wholeSlice(begin, end, size) {\n                return (begin === 0 && !isNeg(begin) || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);\n            }\n            function resolveBegin(begin, size) {\n                return resolveIndex(begin, size, 0);\n            }\n            function resolveEnd(end, size) {\n                return resolveIndex(end, size, size);\n            }\n            function resolveIndex(index, size, defaultIndex) {\n                // Sanitize indices using this shorthand for ToInt32(argument)\n                // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n                return index === undefined ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;\n            }\n            function isNeg(value) {\n                // Account for -0 which is negative, but not less than 0.\n                return value < 0 || value === 0 && 1 / value === -Infinity;\n            }\n            // Note: value is unchanged to not break immutable-devtools.\n            var IS_COLLECTION_SYMBOL = \"@@__IMMUTABLE_ITERABLE__@@\";\n            function isCollection(maybeCollection) {\n                return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);\n            }\n            var IS_KEYED_SYMBOL = \"@@__IMMUTABLE_KEYED__@@\";\n            function isKeyed(maybeKeyed) {\n                return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);\n            }\n            var IS_INDEXED_SYMBOL = \"@@__IMMUTABLE_INDEXED__@@\";\n            function isIndexed(maybeIndexed) {\n                return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);\n            }\n            function isAssociative(maybeAssociative) {\n                return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n            }\n            var Collection = function Collection(value) {\n                return isCollection(value) ? value : Seq(value);\n            };\n            var KeyedCollection = /*@__PURE__*/ function(Collection) {\n                function KeyedCollection(value) {\n                    return isKeyed(value) ? value : KeyedSeq(value);\n                }\n                if (Collection) KeyedCollection.__proto__ = Collection;\n                KeyedCollection.prototype = Object.create(Collection && Collection.prototype);\n                KeyedCollection.prototype.constructor = KeyedCollection;\n                return KeyedCollection;\n            }(Collection);\n            var IndexedCollection = /*@__PURE__*/ function(Collection) {\n                function IndexedCollection(value) {\n                    return isIndexed(value) ? value : IndexedSeq(value);\n                }\n                if (Collection) IndexedCollection.__proto__ = Collection;\n                IndexedCollection.prototype = Object.create(Collection && Collection.prototype);\n                IndexedCollection.prototype.constructor = IndexedCollection;\n                return IndexedCollection;\n            }(Collection);\n            var SetCollection = /*@__PURE__*/ function(Collection) {\n                function SetCollection(value) {\n                    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n                }\n                if (Collection) SetCollection.__proto__ = Collection;\n                SetCollection.prototype = Object.create(Collection && Collection.prototype);\n                SetCollection.prototype.constructor = SetCollection;\n                return SetCollection;\n            }(Collection);\n            Collection.Keyed = KeyedCollection;\n            Collection.Indexed = IndexedCollection;\n            Collection.Set = SetCollection;\n            var IS_SEQ_SYMBOL = \"@@__IMMUTABLE_SEQ__@@\";\n            function isSeq(maybeSeq) {\n                return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);\n            }\n            var IS_RECORD_SYMBOL = \"@@__IMMUTABLE_RECORD__@@\";\n            function isRecord(maybeRecord) {\n                return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);\n            }\n            function isImmutable(maybeImmutable) {\n                return isCollection(maybeImmutable) || isRecord(maybeImmutable);\n            }\n            var IS_ORDERED_SYMBOL = \"@@__IMMUTABLE_ORDERED__@@\";\n            function isOrdered(maybeOrdered) {\n                return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);\n            }\n            var ITERATE_KEYS = 0;\n            var ITERATE_VALUES = 1;\n            var ITERATE_ENTRIES = 2;\n            var REAL_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n            var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n            var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n            var Iterator = function Iterator(next) {\n                this.next = next;\n            };\n            Iterator.prototype.toString = function toString() {\n                return \"[Iterator]\";\n            };\n            Iterator.KEYS = ITERATE_KEYS;\n            Iterator.VALUES = ITERATE_VALUES;\n            Iterator.ENTRIES = ITERATE_ENTRIES;\n            Iterator.prototype.inspect = Iterator.prototype.toSource = function() {\n                return this.toString();\n            };\n            Iterator.prototype[ITERATOR_SYMBOL] = function() {\n                return this;\n            };\n            function iteratorValue(type, k, v, iteratorResult) {\n                var value = type === 0 ? k : type === 1 ? v : [\n                    k,\n                    v\n                ];\n                iteratorResult ? iteratorResult.value = value : iteratorResult = {\n                    value: value,\n                    done: false\n                };\n                return iteratorResult;\n            }\n            function iteratorDone() {\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n            function hasIterator(maybeIterable) {\n                return !!getIteratorFn(maybeIterable);\n            }\n            function isIterator(maybeIterator) {\n                return maybeIterator && typeof maybeIterator.next === \"function\";\n            }\n            function getIterator(iterable) {\n                var iteratorFn = getIteratorFn(iterable);\n                return iteratorFn && iteratorFn.call(iterable);\n            }\n            function getIteratorFn(iterable) {\n                var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);\n                if (typeof iteratorFn === \"function\") {\n                    return iteratorFn;\n                }\n            }\n            var hasOwnProperty = Object.prototype.hasOwnProperty;\n            function isArrayLike(value) {\n                if (Array.isArray(value) || typeof value === \"string\") {\n                    return true;\n                }\n                return value && typeof value === \"object\" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? Object.keys(value).length === 1 : // in the array-like may be found (which could be undefined).\n                value.hasOwnProperty(value.length - 1));\n            }\n            var Seq = /*@__PURE__*/ function(Collection$$1) {\n                function Seq(value) {\n                    return value === null || value === undefined ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);\n                }\n                if (Collection$$1) Seq.__proto__ = Collection$$1;\n                Seq.prototype = Object.create(Collection$$1 && Collection$$1.prototype);\n                Seq.prototype.constructor = Seq;\n                Seq.prototype.toSeq = function toSeq() {\n                    return this;\n                };\n                Seq.prototype.toString = function toString() {\n                    return this.__toString(\"Seq {\", \"}\");\n                };\n                Seq.prototype.cacheResult = function cacheResult() {\n                    if (!this._cache && this.__iterateUncached) {\n                        this._cache = this.entrySeq().toArray();\n                        this.size = this._cache.length;\n                    }\n                    return this;\n                };\n                // abstract __iterateUncached(fn, reverse)\n                Seq.prototype.__iterate = function __iterate(fn, reverse) {\n                    var cache = this._cache;\n                    if (cache) {\n                        var size = cache.length;\n                        var i = 0;\n                        while(i !== size){\n                            var entry = cache[reverse ? size - ++i : i++];\n                            if (fn(entry[1], entry[0], this) === false) {\n                                break;\n                            }\n                        }\n                        return i;\n                    }\n                    return this.__iterateUncached(fn, reverse);\n                };\n                // abstract __iteratorUncached(type, reverse)\n                Seq.prototype.__iterator = function __iterator(type, reverse) {\n                    var cache = this._cache;\n                    if (cache) {\n                        var size = cache.length;\n                        var i = 0;\n                        return new Iterator(function() {\n                            if (i === size) {\n                                return iteratorDone();\n                            }\n                            var entry = cache[reverse ? size - ++i : i++];\n                            return iteratorValue(type, entry[0], entry[1]);\n                        });\n                    }\n                    return this.__iteratorUncached(type, reverse);\n                };\n                return Seq;\n            }(Collection);\n            var KeyedSeq = /*@__PURE__*/ function(Seq) {\n                function KeyedSeq(value) {\n                    return value === null || value === undefined ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);\n                }\n                if (Seq) KeyedSeq.__proto__ = Seq;\n                KeyedSeq.prototype = Object.create(Seq && Seq.prototype);\n                KeyedSeq.prototype.constructor = KeyedSeq;\n                KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {\n                    return this;\n                };\n                return KeyedSeq;\n            }(Seq);\n            var IndexedSeq = /*@__PURE__*/ function(Seq) {\n                function IndexedSeq(value) {\n                    return value === null || value === undefined ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);\n                }\n                if (Seq) IndexedSeq.__proto__ = Seq;\n                IndexedSeq.prototype = Object.create(Seq && Seq.prototype);\n                IndexedSeq.prototype.constructor = IndexedSeq;\n                IndexedSeq.of = function of() {\n                    return IndexedSeq(arguments);\n                };\n                IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {\n                    return this;\n                };\n                IndexedSeq.prototype.toString = function toString() {\n                    return this.__toString(\"Seq [\", \"]\");\n                };\n                return IndexedSeq;\n            }(Seq);\n            var SetSeq = /*@__PURE__*/ function(Seq) {\n                function SetSeq(value) {\n                    return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();\n                }\n                if (Seq) SetSeq.__proto__ = Seq;\n                SetSeq.prototype = Object.create(Seq && Seq.prototype);\n                SetSeq.prototype.constructor = SetSeq;\n                SetSeq.of = function of() {\n                    return SetSeq(arguments);\n                };\n                SetSeq.prototype.toSetSeq = function toSetSeq() {\n                    return this;\n                };\n                return SetSeq;\n            }(Seq);\n            Seq.isSeq = isSeq;\n            Seq.Keyed = KeyedSeq;\n            Seq.Set = SetSeq;\n            Seq.Indexed = IndexedSeq;\n            Seq.prototype[IS_SEQ_SYMBOL] = true;\n            // #pragma Root Sequences\n            var ArraySeq = /*@__PURE__*/ function(IndexedSeq) {\n                function ArraySeq(array) {\n                    this._array = array;\n                    this.size = array.length;\n                }\n                if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;\n                ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n                ArraySeq.prototype.constructor = ArraySeq;\n                ArraySeq.prototype.get = function get(index, notSetValue) {\n                    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n                };\n                ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {\n                    var array = this._array;\n                    var size = array.length;\n                    var i = 0;\n                    while(i !== size){\n                        var ii = reverse ? size - ++i : i++;\n                        if (fn(array[ii], ii, this) === false) {\n                            break;\n                        }\n                    }\n                    return i;\n                };\n                ArraySeq.prototype.__iterator = function __iterator(type, reverse) {\n                    var array = this._array;\n                    var size = array.length;\n                    var i = 0;\n                    return new Iterator(function() {\n                        if (i === size) {\n                            return iteratorDone();\n                        }\n                        var ii = reverse ? size - ++i : i++;\n                        return iteratorValue(type, ii, array[ii]);\n                    });\n                };\n                return ArraySeq;\n            }(IndexedSeq);\n            var ObjectSeq = /*@__PURE__*/ function(KeyedSeq) {\n                function ObjectSeq(object) {\n                    var keys = Object.keys(object);\n                    this._object = object;\n                    this._keys = keys;\n                    this.size = keys.length;\n                }\n                if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;\n                ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);\n                ObjectSeq.prototype.constructor = ObjectSeq;\n                ObjectSeq.prototype.get = function get(key, notSetValue) {\n                    if (notSetValue !== undefined && !this.has(key)) {\n                        return notSetValue;\n                    }\n                    return this._object[key];\n                };\n                ObjectSeq.prototype.has = function has(key) {\n                    return hasOwnProperty.call(this._object, key);\n                };\n                ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {\n                    var object = this._object;\n                    var keys = this._keys;\n                    var size = keys.length;\n                    var i = 0;\n                    while(i !== size){\n                        var key = keys[reverse ? size - ++i : i++];\n                        if (fn(object[key], key, this) === false) {\n                            break;\n                        }\n                    }\n                    return i;\n                };\n                ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {\n                    var object = this._object;\n                    var keys = this._keys;\n                    var size = keys.length;\n                    var i = 0;\n                    return new Iterator(function() {\n                        if (i === size) {\n                            return iteratorDone();\n                        }\n                        var key = keys[reverse ? size - ++i : i++];\n                        return iteratorValue(type, key, object[key]);\n                    });\n                };\n                return ObjectSeq;\n            }(KeyedSeq);\n            ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;\n            var CollectionSeq = /*@__PURE__*/ function(IndexedSeq) {\n                function CollectionSeq(collection) {\n                    this._collection = collection;\n                    this.size = collection.length || collection.size;\n                }\n                if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;\n                CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n                CollectionSeq.prototype.constructor = CollectionSeq;\n                CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {\n                    if (reverse) {\n                        return this.cacheResult().__iterate(fn, reverse);\n                    }\n                    var collection = this._collection;\n                    var iterator = getIterator(collection);\n                    var iterations = 0;\n                    if (isIterator(iterator)) {\n                        var step;\n                        while(!(step = iterator.next()).done){\n                            if (fn(step.value, iterations++, this) === false) {\n                                break;\n                            }\n                        }\n                    }\n                    return iterations;\n                };\n                CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {\n                    if (reverse) {\n                        return this.cacheResult().__iterator(type, reverse);\n                    }\n                    var collection = this._collection;\n                    var iterator = getIterator(collection);\n                    if (!isIterator(iterator)) {\n                        return new Iterator(iteratorDone);\n                    }\n                    var iterations = 0;\n                    return new Iterator(function() {\n                        var step = iterator.next();\n                        return step.done ? step : iteratorValue(type, iterations++, step.value);\n                    });\n                };\n                return CollectionSeq;\n            }(IndexedSeq);\n            // # pragma Helper functions\n            var EMPTY_SEQ;\n            function emptySequence() {\n                return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n            }\n            function keyedSeqFromValue(value) {\n                var seq = Array.isArray(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;\n                if (seq) {\n                    return seq.fromEntrySeq();\n                }\n                if (typeof value === \"object\") {\n                    return new ObjectSeq(value);\n                }\n                throw new TypeError(\"Expected Array or collection object of [k, v] entries, or keyed object: \" + value);\n            }\n            function indexedSeqFromValue(value) {\n                var seq = maybeIndexedSeqFromValue(value);\n                if (seq) {\n                    return seq;\n                }\n                throw new TypeError(\"Expected Array or collection object of values: \" + value);\n            }\n            function seqFromValue(value) {\n                var seq = maybeIndexedSeqFromValue(value);\n                if (seq) {\n                    return seq;\n                }\n                if (typeof value === \"object\") {\n                    return new ObjectSeq(value);\n                }\n                throw new TypeError(\"Expected Array or collection object of values, or keyed object: \" + value);\n            }\n            function maybeIndexedSeqFromValue(value) {\n                return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;\n            }\n            var IS_MAP_SYMBOL = \"@@__IMMUTABLE_MAP__@@\";\n            function isMap(maybeMap) {\n                return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);\n            }\n            function isOrderedMap(maybeOrderedMap) {\n                return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n            }\n            function isValueObject(maybeValue) {\n                return Boolean(maybeValue && typeof maybeValue.equals === \"function\" && typeof maybeValue.hashCode === \"function\");\n            }\n            /**\n * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n *\n * NaN is considered the same as NaN, however -0 and 0 are considered the same\n * value, which is different from the algorithm described by\n * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n *\n * This is extended further to allow Objects to describe the values they\n * represent, by way of `valueOf` or `equals` (and `hashCode`).\n *\n * Note: because of this extension, the key equality of Immutable.Map and the\n * value equality of Immutable.Set will differ from ES6 Map and Set.\n *\n * ### Defining custom values\n *\n * The easiest way to describe the value an object represents is by implementing\n * `valueOf`. For example, `Date` represents a value by returning a unix\n * timestamp for `valueOf`:\n *\n *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n *     var date2 = new Date(1234567890000);\n *     date1.valueOf(); // 1234567890000\n *     assert( date1 !== date2 );\n *     assert( Immutable.is( date1, date2 ) );\n *\n * Note: overriding `valueOf` may have other implications if you use this object\n * where JavaScript expects a primitive, such as implicit string coercion.\n *\n * For more complex types, especially collections, implementing `valueOf` may\n * not be performant. An alternative is to implement `equals` and `hashCode`.\n *\n * `equals` takes another object, presumably of similar type, and returns true\n * if it is equal. Equality is symmetrical, so the same result should be\n * returned if this and the argument are flipped.\n *\n *     assert( a.equals(b) === b.equals(a) );\n *\n * `hashCode` returns a 32bit integer number representing the object which will\n * be used to determine how to store the value object in a Map or Set. You must\n * provide both or neither methods, one must not exist without the other.\n *\n * Also, an important relationship between these methods must be upheld: if two\n * values are equal, they *must* return the same hashCode. If the values are not\n * equal, they might have the same hashCode; this is called a hash collision,\n * and while undesirable for performance reasons, it is acceptable.\n *\n *     if (a.equals(b)) {\n *       assert( a.hashCode() === b.hashCode() );\n *     }\n *\n * All Immutable collections are Value Objects: they implement `equals()`\n * and `hashCode()`.\n */ function is(valueA, valueB) {\n                if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n                    return true;\n                }\n                if (!valueA || !valueB) {\n                    return false;\n                }\n                if (typeof valueA.valueOf === \"function\" && typeof valueB.valueOf === \"function\") {\n                    valueA = valueA.valueOf();\n                    valueB = valueB.valueOf();\n                    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n                        return true;\n                    }\n                    if (!valueA || !valueB) {\n                        return false;\n                    }\n                }\n                return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));\n            }\n            var imul = typeof Math.imul === \"function\" && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {\n                a |= 0; // int\n                b |= 0; // int\n                var c = a & 0xffff;\n                var d = b & 0xffff;\n                // Shift by 0 fixes the sign on the high part.\n                return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int\n            };\n            // v8 has an optimization for storing 31-bit signed numbers.\n            // Values which have either 00 or 11 as the high order bits qualify.\n            // This function drops the highest order bit in a signed number, maintaining\n            // the sign bit.\n            function smi(i32) {\n                return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;\n            }\n            var defaultValueOf = Object.prototype.valueOf;\n            function hash(o) {\n                switch(typeof o){\n                    case \"boolean\":\n                        // The hash values for built-in constants are a 1 value for each 5-byte\n                        // shift region expect for the first, which encodes the value. This\n                        // reduces the odds of a hash collision for these common values.\n                        return o ? 0x42108421 : 0x42108420;\n                    case \"number\":\n                        return hashNumber(o);\n                    case \"string\":\n                        return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n                    case \"object\":\n                    case \"function\":\n                        if (o === null) {\n                            return 0x42108422;\n                        }\n                        if (typeof o.hashCode === \"function\") {\n                            // Drop any high bits from accidentally long hash codes.\n                            return smi(o.hashCode(o));\n                        }\n                        if (o.valueOf !== defaultValueOf && typeof o.valueOf === \"function\") {\n                            o = o.valueOf(o);\n                        }\n                        return hashJSObj(o);\n                    case \"undefined\":\n                        return 0x42108423;\n                    default:\n                        if (typeof o.toString === \"function\") {\n                            return hashString(o.toString());\n                        }\n                        throw new Error(\"Value type \" + typeof o + \" cannot be hashed.\");\n                }\n            }\n            // Compress arbitrarily large numbers into smi hashes.\n            function hashNumber(n) {\n                if (n !== n || n === Infinity) {\n                    return 0;\n                }\n                var hash = n | 0;\n                if (hash !== n) {\n                    hash ^= n * 0xffffffff;\n                }\n                while(n > 0xffffffff){\n                    n /= 0xffffffff;\n                    hash ^= n;\n                }\n                return smi(hash);\n            }\n            function cachedHashString(string) {\n                var hashed = stringHashCache[string];\n                if (hashed === undefined) {\n                    hashed = hashString(string);\n                    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n                        STRING_HASH_CACHE_SIZE = 0;\n                        stringHashCache = {};\n                    }\n                    STRING_HASH_CACHE_SIZE++;\n                    stringHashCache[string] = hashed;\n                }\n                return hashed;\n            }\n            // http://jsperf.com/hashing-strings\n            function hashString(string) {\n                // This is the hash from JVM\n                // The hash code for a string is computed as\n                // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n                // where s[i] is the ith character of the string and n is the length of\n                // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n                // (exclusive) by dropping high bits.\n                var hashed = 0;\n                for(var ii = 0; ii < string.length; ii++){\n                    hashed = 31 * hashed + string.charCodeAt(ii) | 0;\n                }\n                return smi(hashed);\n            }\n            function hashJSObj(obj) {\n                var hashed;\n                if (usingWeakMap) {\n                    hashed = weakMap.get(obj);\n                    if (hashed !== undefined) {\n                        return hashed;\n                    }\n                }\n                hashed = obj[UID_HASH_KEY];\n                if (hashed !== undefined) {\n                    return hashed;\n                }\n                if (!canDefineProperty) {\n                    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n                    if (hashed !== undefined) {\n                        return hashed;\n                    }\n                    hashed = getIENodeHash(obj);\n                    if (hashed !== undefined) {\n                        return hashed;\n                    }\n                }\n                hashed = ++objHashUID;\n                if (objHashUID & 0x40000000) {\n                    objHashUID = 0;\n                }\n                if (usingWeakMap) {\n                    weakMap.set(obj, hashed);\n                } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n                    throw new Error(\"Non-extensible objects are not allowed as keys.\");\n                } else if (canDefineProperty) {\n                    Object.defineProperty(obj, UID_HASH_KEY, {\n                        enumerable: false,\n                        configurable: false,\n                        writable: false,\n                        value: hashed\n                    });\n                } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n                    // Since we can't define a non-enumerable property on the object\n                    // we'll hijack one of the less-used non-enumerable properties to\n                    // save our hash on it. Since this is a function it will not show up in\n                    // `JSON.stringify` which is what we want.\n                    obj.propertyIsEnumerable = function() {\n                        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n                    };\n                    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n                } else if (obj.nodeType !== undefined) {\n                    // At this point we couldn't get the IE `uniqueID` to use as a hash\n                    // and we couldn't use a non-enumerable property to exploit the\n                    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n                    // itself.\n                    obj[UID_HASH_KEY] = hashed;\n                } else {\n                    throw new Error(\"Unable to set a non-enumerable property on object.\");\n                }\n                return hashed;\n            }\n            // Get references to ES5 object methods.\n            var isExtensible = Object.isExtensible;\n            // True if Object.defineProperty works as expected. IE8 fails this test.\n            var canDefineProperty = function() {\n                try {\n                    Object.defineProperty({}, \"@\", {});\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }();\n            // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n            // and avoid memory leaks from the IE cloneNode bug.\n            function getIENodeHash(node) {\n                if (node && node.nodeType > 0) {\n                    switch(node.nodeType){\n                        case 1:\n                            return node.uniqueID;\n                        case 9:\n                            return node.documentElement && node.documentElement.uniqueID;\n                    }\n                }\n            }\n            // If possible, use a WeakMap.\n            var usingWeakMap = typeof WeakMap === \"function\";\n            var weakMap;\n            if (usingWeakMap) {\n                weakMap = new WeakMap();\n            }\n            var objHashUID = 0;\n            var UID_HASH_KEY = \"__immutablehash__\";\n            if (typeof Symbol === \"function\") {\n                UID_HASH_KEY = Symbol(UID_HASH_KEY);\n            }\n            var STRING_HASH_CACHE_MIN_STRLEN = 16;\n            var STRING_HASH_CACHE_MAX_SIZE = 255;\n            var STRING_HASH_CACHE_SIZE = 0;\n            var stringHashCache = {};\n            var ToKeyedSequence = /*@__PURE__*/ function(KeyedSeq$$1) {\n                function ToKeyedSequence(indexed, useKeys) {\n                    this._iter = indexed;\n                    this._useKeys = useKeys;\n                    this.size = indexed.size;\n                }\n                if (KeyedSeq$$1) ToKeyedSequence.__proto__ = KeyedSeq$$1;\n                ToKeyedSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);\n                ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n                ToKeyedSequence.prototype.get = function get(key, notSetValue) {\n                    return this._iter.get(key, notSetValue);\n                };\n                ToKeyedSequence.prototype.has = function has(key) {\n                    return this._iter.has(key);\n                };\n                ToKeyedSequence.prototype.valueSeq = function valueSeq() {\n                    return this._iter.valueSeq();\n                };\n                ToKeyedSequence.prototype.reverse = function reverse() {\n                    var this$1 = this;\n                    var reversedSequence = reverseFactory(this, true);\n                    if (!this._useKeys) {\n                        reversedSequence.valueSeq = function() {\n                            return this$1._iter.toSeq().reverse();\n                        };\n                    }\n                    return reversedSequence;\n                };\n                ToKeyedSequence.prototype.map = function map(mapper, context) {\n                    var this$1 = this;\n                    var mappedSequence = mapFactory(this, mapper, context);\n                    if (!this._useKeys) {\n                        mappedSequence.valueSeq = function() {\n                            return this$1._iter.toSeq().map(mapper, context);\n                        };\n                    }\n                    return mappedSequence;\n                };\n                ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {\n                    var this$1 = this;\n                    return this._iter.__iterate(function(v, k) {\n                        return fn(v, k, this$1);\n                    }, reverse);\n                };\n                ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {\n                    return this._iter.__iterator(type, reverse);\n                };\n                return ToKeyedSequence;\n            }(KeyedSeq);\n            ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;\n            var ToIndexedSequence = /*@__PURE__*/ function(IndexedSeq$$1) {\n                function ToIndexedSequence(iter) {\n                    this._iter = iter;\n                    this.size = iter.size;\n                }\n                if (IndexedSeq$$1) ToIndexedSequence.__proto__ = IndexedSeq$$1;\n                ToIndexedSequence.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n                ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n                ToIndexedSequence.prototype.includes = function includes(value) {\n                    return this._iter.includes(value);\n                };\n                ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {\n                    var this$1 = this;\n                    var i = 0;\n                    reverse && ensureSize(this);\n                    return this._iter.__iterate(function(v) {\n                        return fn(v, reverse ? this$1.size - ++i : i++, this$1);\n                    }, reverse);\n                };\n                ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {\n                    var this$1 = this;\n                    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n                    var i = 0;\n                    reverse && ensureSize(this);\n                    return new Iterator(function() {\n                        var step = iterator.next();\n                        return step.done ? step : iteratorValue(type, reverse ? this$1.size - ++i : i++, step.value, step);\n                    });\n                };\n                return ToIndexedSequence;\n            }(IndexedSeq);\n            var ToSetSequence = /*@__PURE__*/ function(SetSeq$$1) {\n                function ToSetSequence(iter) {\n                    this._iter = iter;\n                    this.size = iter.size;\n                }\n                if (SetSeq$$1) ToSetSequence.__proto__ = SetSeq$$1;\n                ToSetSequence.prototype = Object.create(SetSeq$$1 && SetSeq$$1.prototype);\n                ToSetSequence.prototype.constructor = ToSetSequence;\n                ToSetSequence.prototype.has = function has(key) {\n                    return this._iter.includes(key);\n                };\n                ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {\n                    var this$1 = this;\n                    return this._iter.__iterate(function(v) {\n                        return fn(v, v, this$1);\n                    }, reverse);\n                };\n                ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {\n                    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n                    return new Iterator(function() {\n                        var step = iterator.next();\n                        return step.done ? step : iteratorValue(type, step.value, step.value, step);\n                    });\n                };\n                return ToSetSequence;\n            }(SetSeq);\n            var FromEntriesSequence = /*@__PURE__*/ function(KeyedSeq$$1) {\n                function FromEntriesSequence(entries) {\n                    this._iter = entries;\n                    this.size = entries.size;\n                }\n                if (KeyedSeq$$1) FromEntriesSequence.__proto__ = KeyedSeq$$1;\n                FromEntriesSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);\n                FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n                FromEntriesSequence.prototype.entrySeq = function entrySeq() {\n                    return this._iter.toSeq();\n                };\n                FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {\n                    var this$1 = this;\n                    return this._iter.__iterate(function(entry) {\n                        // Check if entry exists first so array access doesn't throw for holes\n                        // in the parent iteration.\n                        if (entry) {\n                            validateEntry(entry);\n                            var indexedCollection = isCollection(entry);\n                            return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1);\n                        }\n                    }, reverse);\n                };\n                FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {\n                    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n                    return new Iterator(function() {\n                        while(true){\n                            var step = iterator.next();\n                            if (step.done) {\n                                return step;\n                            }\n                            var entry = step.value;\n                            // Check if entry exists first so array access doesn't throw for holes\n                            // in the parent iteration.\n                            if (entry) {\n                                validateEntry(entry);\n                                var indexedCollection = isCollection(entry);\n                                return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);\n                            }\n                        }\n                    });\n                };\n                return FromEntriesSequence;\n            }(KeyedSeq);\n            ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;\n            function flipFactory(collection) {\n                var flipSequence = makeSequence(collection);\n                flipSequence._iter = collection;\n                flipSequence.size = collection.size;\n                flipSequence.flip = function() {\n                    return collection;\n                };\n                flipSequence.reverse = function() {\n                    var reversedSequence = collection.reverse.apply(this); // super.reverse()\n                    reversedSequence.flip = function() {\n                        return collection.reverse();\n                    };\n                    return reversedSequence;\n                };\n                flipSequence.has = function(key) {\n                    return collection.includes(key);\n                };\n                flipSequence.includes = function(key) {\n                    return collection.has(key);\n                };\n                flipSequence.cacheResult = cacheResultThrough;\n                flipSequence.__iterateUncached = function(fn, reverse) {\n                    var this$1 = this;\n                    return collection.__iterate(function(v, k) {\n                        return fn(k, v, this$1) !== false;\n                    }, reverse);\n                };\n                flipSequence.__iteratorUncached = function(type, reverse) {\n                    if (type === ITERATE_ENTRIES) {\n                        var iterator = collection.__iterator(type, reverse);\n                        return new Iterator(function() {\n                            var step = iterator.next();\n                            if (!step.done) {\n                                var k = step.value[0];\n                                step.value[0] = step.value[1];\n                                step.value[1] = k;\n                            }\n                            return step;\n                        });\n                    }\n                    return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);\n                };\n                return flipSequence;\n            }\n            function mapFactory(collection, mapper, context) {\n                var mappedSequence = makeSequence(collection);\n                mappedSequence.size = collection.size;\n                mappedSequence.has = function(key) {\n                    return collection.has(key);\n                };\n                mappedSequence.get = function(key, notSetValue) {\n                    var v = collection.get(key, NOT_SET);\n                    return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);\n                };\n                mappedSequence.__iterateUncached = function(fn, reverse) {\n                    var this$1 = this;\n                    return collection.__iterate(function(v, k, c) {\n                        return fn(mapper.call(context, v, k, c), k, this$1) !== false;\n                    }, reverse);\n                };\n                mappedSequence.__iteratorUncached = function(type, reverse) {\n                    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n                    return new Iterator(function() {\n                        var step = iterator.next();\n                        if (step.done) {\n                            return step;\n                        }\n                        var entry = step.value;\n                        var key = entry[0];\n                        return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);\n                    });\n                };\n                return mappedSequence;\n            }\n            function reverseFactory(collection, useKeys) {\n                var this$1 = this;\n                var reversedSequence = makeSequence(collection);\n                reversedSequence._iter = collection;\n                reversedSequence.size = collection.size;\n                reversedSequence.reverse = function() {\n                    return collection;\n                };\n                if (collection.flip) {\n                    reversedSequence.flip = function() {\n                        var flipSequence = flipFactory(collection);\n                        flipSequence.reverse = function() {\n                            return collection.flip();\n                        };\n                        return flipSequence;\n                    };\n                }\n                reversedSequence.get = function(key, notSetValue) {\n                    return collection.get(useKeys ? key : -1 - key, notSetValue);\n                };\n                reversedSequence.has = function(key) {\n                    return collection.has(useKeys ? key : -1 - key);\n                };\n                reversedSequence.includes = function(value) {\n                    return collection.includes(value);\n                };\n                reversedSequence.cacheResult = cacheResultThrough;\n                reversedSequence.__iterate = function(fn, reverse) {\n                    var this$1 = this;\n                    var i = 0;\n                    reverse && ensureSize(collection);\n                    return collection.__iterate(function(v, k) {\n                        return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1);\n                    }, !reverse);\n                };\n                reversedSequence.__iterator = function(type, reverse) {\n                    var i = 0;\n                    reverse && ensureSize(collection);\n                    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n                    return new Iterator(function() {\n                        var step = iterator.next();\n                        if (step.done) {\n                            return step;\n                        }\n                        var entry = step.value;\n                        return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1.size - ++i : i++, entry[1], step);\n                    });\n                };\n                return reversedSequence;\n            }\n            function filterFactory(collection, predicate, context, useKeys) {\n                var filterSequence = makeSequence(collection);\n                if (useKeys) {\n                    filterSequence.has = function(key) {\n                        var v = collection.get(key, NOT_SET);\n                        return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n                    };\n                    filterSequence.get = function(key, notSetValue) {\n                        var v = collection.get(key, NOT_SET);\n                        return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;\n                    };\n                }\n                filterSequence.__iterateUncached = function(fn, reverse) {\n                    var this$1 = this;\n                    var iterations = 0;\n                    collection.__iterate(function(v, k, c) {\n                        if (predicate.call(context, v, k, c)) {\n                            iterations++;\n                            return fn(v, useKeys ? k : iterations - 1, this$1);\n                        }\n                    }, reverse);\n                    return iterations;\n                };\n                filterSequence.__iteratorUncached = function(type, reverse) {\n                    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n                    var iterations = 0;\n                    return new Iterator(function() {\n                        while(true){\n                            var step = iterator.next();\n                            if (step.done) {\n                                return step;\n                            }\n                            var entry = step.value;\n                            var key = entry[0];\n                            var value = entry[1];\n                            if (predicate.call(context, value, key, collection)) {\n                                return iteratorValue(type, useKeys ? key : iterations++, value, step);\n                            }\n                        }\n                    });\n                };\n                return filterSequence;\n            }\n            function countByFactory(collection, grouper, context) {\n                var groups = Map().asMutable();\n                collection.__iterate(function(v, k) {\n                    groups.update(grouper.call(context, v, k, collection), 0, function(a) {\n                        return a + 1;\n                    });\n                });\n                return groups.asImmutable();\n            }\n            function groupByFactory(collection, grouper, context) {\n                var isKeyedIter = isKeyed(collection);\n                var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n                collection.__iterate(function(v, k) {\n                    groups.update(grouper.call(context, v, k, collection), function(a) {\n                        return a = a || [], a.push(isKeyedIter ? [\n                            k,\n                            v\n                        ] : v), a;\n                    });\n                });\n                var coerce = collectionClass(collection);\n                return groups.map(function(arr) {\n                    return reify(collection, coerce(arr));\n                }).asImmutable();\n            }\n            function sliceFactory(collection, begin, end, useKeys) {\n                var originalSize = collection.size;\n                if (wholeSlice(begin, end, originalSize)) {\n                    return collection;\n                }\n                var resolvedBegin = resolveBegin(begin, originalSize);\n                var resolvedEnd = resolveEnd(end, originalSize);\n                // begin or end will be NaN if they were provided as negative numbers and\n                // this collection's size is unknown. In that case, cache first so there is\n                // a known size and these do not resolve to NaN.\n                if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n                    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n                }\n                // Note: resolvedEnd is undefined when the original sequence's length is\n                // unknown and this slice did not supply an end and should contain all\n                // elements after resolvedBegin.\n                // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n                var resolvedSize = resolvedEnd - resolvedBegin;\n                var sliceSize;\n                if (resolvedSize === resolvedSize) {\n                    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n                }\n                var sliceSeq = makeSequence(collection);\n                // If collection.size is undefined, the size of the realized sliceSeq is\n                // unknown at this point unless the number of items to slice is 0\n                sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;\n                if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n                    sliceSeq.get = function(index, notSetValue) {\n                        index = wrapIndex(this, index);\n                        return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;\n                    };\n                }\n                sliceSeq.__iterateUncached = function(fn, reverse) {\n                    var this$1 = this;\n                    if (sliceSize === 0) {\n                        return 0;\n                    }\n                    if (reverse) {\n                        return this.cacheResult().__iterate(fn, reverse);\n                    }\n                    var skipped = 0;\n                    var isSkipping = true;\n                    var iterations = 0;\n                    collection.__iterate(function(v, k) {\n                        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n                            iterations++;\n                            return fn(v, useKeys ? k : iterations - 1, this$1) !== false && iterations !== sliceSize;\n                        }\n                    });\n                    return iterations;\n                };\n                sliceSeq.__iteratorUncached = function(type, reverse) {\n                    if (sliceSize !== 0 && reverse) {\n                        return this.cacheResult().__iterator(type, reverse);\n                    }\n                    // Don't bother instantiating parent iterator if taking 0.\n                    if (sliceSize === 0) {\n                        return new Iterator(iteratorDone);\n                    }\n                    var iterator = collection.__iterator(type, reverse);\n                    var skipped = 0;\n                    var iterations = 0;\n                    return new Iterator(function() {\n                        while(skipped++ < resolvedBegin){\n                            iterator.next();\n                        }\n                        if (++iterations > sliceSize) {\n                            return iteratorDone();\n                        }\n                        var step = iterator.next();\n                        if (useKeys || type === ITERATE_VALUES || step.done) {\n                            return step;\n                        }\n                        if (type === ITERATE_KEYS) {\n                            return iteratorValue(type, iterations - 1, undefined, step);\n                        }\n                        return iteratorValue(type, iterations - 1, step.value[1], step);\n                    });\n                };\n                return sliceSeq;\n            }\n            function takeWhileFactory(collection, predicate, context) {\n                var takeSequence = makeSequence(collection);\n                takeSequence.__iterateUncached = function(fn, reverse) {\n                    var this$1 = this;\n                    if (reverse) {\n                        return this.cacheResult().__iterate(fn, reverse);\n                    }\n                    var iterations = 0;\n                    collection.__iterate(function(v, k, c) {\n                        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1);\n                    });\n                    return iterations;\n                };\n                takeSequence.__iteratorUncached = function(type, reverse) {\n                    var this$1 = this;\n                    if (reverse) {\n                        return this.cacheResult().__iterator(type, reverse);\n                    }\n                    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n                    var iterating = true;\n                    return new Iterator(function() {\n                        if (!iterating) {\n                            return iteratorDone();\n                        }\n                        var step = iterator.next();\n                        if (step.done) {\n                            return step;\n                        }\n                        var entry = step.value;\n                        var k = entry[0];\n                        var v = entry[1];\n                        if (!predicate.call(context, v, k, this$1)) {\n                            iterating = false;\n                            return iteratorDone();\n                        }\n                        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n                    });\n                };\n                return takeSequence;\n            }\n            function skipWhileFactory(collection, predicate, context, useKeys) {\n                var skipSequence = makeSequence(collection);\n                skipSequence.__iterateUncached = function(fn, reverse) {\n                    var this$1 = this;\n                    if (reverse) {\n                        return this.cacheResult().__iterate(fn, reverse);\n                    }\n                    var isSkipping = true;\n                    var iterations = 0;\n                    collection.__iterate(function(v, k, c) {\n                        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n                            iterations++;\n                            return fn(v, useKeys ? k : iterations - 1, this$1);\n                        }\n                    });\n                    return iterations;\n                };\n                skipSequence.__iteratorUncached = function(type, reverse) {\n                    var this$1 = this;\n                    if (reverse) {\n                        return this.cacheResult().__iterator(type, reverse);\n                    }\n                    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n                    var skipping = true;\n                    var iterations = 0;\n                    return new Iterator(function() {\n                        var step;\n                        var k;\n                        var v;\n                        do {\n                            step = iterator.next();\n                            if (step.done) {\n                                if (useKeys || type === ITERATE_VALUES) {\n                                    return step;\n                                }\n                                if (type === ITERATE_KEYS) {\n                                    return iteratorValue(type, iterations++, undefined, step);\n                                }\n                                return iteratorValue(type, iterations++, step.value[1], step);\n                            }\n                            var entry = step.value;\n                            k = entry[0];\n                            v = entry[1];\n                            skipping && (skipping = predicate.call(context, v, k, this$1));\n                        }while (skipping);\n                        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n                    });\n                };\n                return skipSequence;\n            }\n            function concatFactory(collection, values) {\n                var isKeyedCollection = isKeyed(collection);\n                var iters = [\n                    collection\n                ].concat(values).map(function(v) {\n                    if (!isCollection(v)) {\n                        v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [\n                            v\n                        ]);\n                    } else if (isKeyedCollection) {\n                        v = KeyedCollection(v);\n                    }\n                    return v;\n                }).filter(function(v) {\n                    return v.size !== 0;\n                });\n                if (iters.length === 0) {\n                    return collection;\n                }\n                if (iters.length === 1) {\n                    var singleton = iters[0];\n                    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {\n                        return singleton;\n                    }\n                }\n                var concatSeq = new ArraySeq(iters);\n                if (isKeyedCollection) {\n                    concatSeq = concatSeq.toKeyedSeq();\n                } else if (!isIndexed(collection)) {\n                    concatSeq = concatSeq.toSetSeq();\n                }\n                concatSeq = concatSeq.flatten(true);\n                concatSeq.size = iters.reduce(function(sum, seq) {\n                    if (sum !== undefined) {\n                        var size = seq.size;\n                        if (size !== undefined) {\n                            return sum + size;\n                        }\n                    }\n                }, 0);\n                return concatSeq;\n            }\n            function flattenFactory(collection, depth, useKeys) {\n                var flatSequence = makeSequence(collection);\n                flatSequence.__iterateUncached = function(fn, reverse) {\n                    if (reverse) {\n                        return this.cacheResult().__iterate(fn, reverse);\n                    }\n                    var iterations = 0;\n                    var stopped = false;\n                    function flatDeep(iter, currentDepth) {\n                        iter.__iterate(function(v, k) {\n                            if ((!depth || currentDepth < depth) && isCollection(v)) {\n                                flatDeep(v, currentDepth + 1);\n                            } else {\n                                iterations++;\n                                if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n                                    stopped = true;\n                                }\n                            }\n                            return !stopped;\n                        }, reverse);\n                    }\n                    flatDeep(collection, 0);\n                    return iterations;\n                };\n                flatSequence.__iteratorUncached = function(type, reverse) {\n                    if (reverse) {\n                        return this.cacheResult().__iterator(type, reverse);\n                    }\n                    var iterator = collection.__iterator(type, reverse);\n                    var stack = [];\n                    var iterations = 0;\n                    return new Iterator(function() {\n                        while(iterator){\n                            var step = iterator.next();\n                            if (step.done !== false) {\n                                iterator = stack.pop();\n                                continue;\n                            }\n                            var v = step.value;\n                            if (type === ITERATE_ENTRIES) {\n                                v = v[1];\n                            }\n                            if ((!depth || stack.length < depth) && isCollection(v)) {\n                                stack.push(iterator);\n                                iterator = v.__iterator(type, reverse);\n                            } else {\n                                return useKeys ? step : iteratorValue(type, iterations++, v, step);\n                            }\n                        }\n                        return iteratorDone();\n                    });\n                };\n                return flatSequence;\n            }\n            function flatMapFactory(collection, mapper, context) {\n                var coerce = collectionClass(collection);\n                return collection.toSeq().map(function(v, k) {\n                    return coerce(mapper.call(context, v, k, collection));\n                }).flatten(true);\n            }\n            function interposeFactory(collection, separator) {\n                var interposedSequence = makeSequence(collection);\n                interposedSequence.size = collection.size && collection.size * 2 - 1;\n                interposedSequence.__iterateUncached = function(fn, reverse) {\n                    var this$1 = this;\n                    var iterations = 0;\n                    collection.__iterate(function(v) {\n                        return (!iterations || fn(separator, iterations++, this$1) !== false) && fn(v, iterations++, this$1) !== false;\n                    }, reverse);\n                    return iterations;\n                };\n                interposedSequence.__iteratorUncached = function(type, reverse) {\n                    var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n                    var iterations = 0;\n                    var step;\n                    return new Iterator(function() {\n                        if (!step || iterations % 2) {\n                            step = iterator.next();\n                            if (step.done) {\n                                return step;\n                            }\n                        }\n                        return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);\n                    });\n                };\n                return interposedSequence;\n            }\n            function sortFactory(collection, comparator, mapper) {\n                if (!comparator) {\n                    comparator = defaultComparator;\n                }\n                var isKeyedCollection = isKeyed(collection);\n                var index = 0;\n                var entries = collection.toSeq().map(function(v, k) {\n                    return [\n                        k,\n                        v,\n                        index++,\n                        mapper ? mapper(v, k, collection) : v\n                    ];\n                }).valueSeq().toArray();\n                entries.sort(function(a, b) {\n                    return comparator(a[3], b[3]) || a[2] - b[2];\n                }).forEach(isKeyedCollection ? function(v, i) {\n                    entries[i].length = 2;\n                } : function(v, i) {\n                    entries[i] = v[1];\n                });\n                return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);\n            }\n            function maxFactory(collection, comparator, mapper) {\n                if (!comparator) {\n                    comparator = defaultComparator;\n                }\n                if (mapper) {\n                    var entry = collection.toSeq().map(function(v, k) {\n                        return [\n                            v,\n                            mapper(v, k, collection)\n                        ];\n                    }).reduce(function(a, b) {\n                        return maxCompare(comparator, a[1], b[1]) ? b : a;\n                    });\n                    return entry && entry[0];\n                }\n                return collection.reduce(function(a, b) {\n                    return maxCompare(comparator, a, b) ? b : a;\n                });\n            }\n            function maxCompare(comparator, a, b) {\n                var comp = comparator(b, a);\n                // b is considered the new max if the comparator declares them equal, but\n                // they are not equal and b is in fact a nullish value.\n                return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;\n            }\n            function zipWithFactory(keyIter, zipper, iters, zipAll) {\n                var zipSequence = makeSequence(keyIter);\n                var sizes = new ArraySeq(iters).map(function(i) {\n                    return i.size;\n                });\n                zipSequence.size = zipAll ? sizes.max() : sizes.min();\n                // Note: this a generic base implementation of __iterate in terms of\n                // __iterator which may be more generically useful in the future.\n                zipSequence.__iterate = function(fn, reverse) {\n                    /* generic:\n    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      iterations++;\n      if (fn(step.value[1], step.value[0], this) === false) {\n        break;\n      }\n    }\n    return iterations;\n    */ // indexed:\n                    var iterator = this.__iterator(ITERATE_VALUES, reverse);\n                    var step;\n                    var iterations = 0;\n                    while(!(step = iterator.next()).done){\n                        if (fn(step.value, iterations++, this) === false) {\n                            break;\n                        }\n                    }\n                    return iterations;\n                };\n                zipSequence.__iteratorUncached = function(type, reverse) {\n                    var iterators = iters.map(function(i) {\n                        return i = Collection(i), getIterator(reverse ? i.reverse() : i);\n                    });\n                    var iterations = 0;\n                    var isDone = false;\n                    return new Iterator(function() {\n                        var steps;\n                        if (!isDone) {\n                            steps = iterators.map(function(i) {\n                                return i.next();\n                            });\n                            isDone = zipAll ? steps.every(function(s) {\n                                return s.done;\n                            }) : steps.some(function(s) {\n                                return s.done;\n                            });\n                        }\n                        if (isDone) {\n                            return iteratorDone();\n                        }\n                        return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function(s) {\n                            return s.value;\n                        })));\n                    });\n                };\n                return zipSequence;\n            }\n            // #pragma Helper Functions\n            function reify(iter, seq) {\n                return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n            }\n            function validateEntry(entry) {\n                if (entry !== Object(entry)) {\n                    throw new TypeError(\"Expected [K, V] tuple: \" + entry);\n                }\n            }\n            function collectionClass(collection) {\n                return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;\n            }\n            function makeSequence(collection) {\n                return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);\n            }\n            function cacheResultThrough() {\n                if (this._iter.cacheResult) {\n                    this._iter.cacheResult();\n                    this.size = this._iter.size;\n                    return this;\n                }\n                return Seq.prototype.cacheResult.call(this);\n            }\n            function defaultComparator(a, b) {\n                if (a === undefined && b === undefined) {\n                    return 0;\n                }\n                if (a === undefined) {\n                    return 1;\n                }\n                if (b === undefined) {\n                    return -1;\n                }\n                return a > b ? 1 : a < b ? -1 : 0;\n            }\n            // http://jsperf.com/copy-array-inline\n            function arrCopy(arr, offset) {\n                offset = offset || 0;\n                var len = Math.max(0, arr.length - offset);\n                var newArr = new Array(len);\n                for(var ii = 0; ii < len; ii++){\n                    newArr[ii] = arr[ii + offset];\n                }\n                return newArr;\n            }\n            function invariant(condition, error) {\n                if (!condition) {\n                    throw new Error(error);\n                }\n            }\n            function assertNotInfinite(size) {\n                invariant(size !== Infinity, \"Cannot perform this action with an infinite size.\");\n            }\n            function coerceKeyPath(keyPath) {\n                if (isArrayLike(keyPath) && typeof keyPath !== \"string\") {\n                    return keyPath;\n                }\n                if (isOrdered(keyPath)) {\n                    return keyPath.toArray();\n                }\n                throw new TypeError(\"Invalid keyPath: expected Ordered Collection or Array: \" + keyPath);\n            }\n            function isPlainObj(value) {\n                return value && (typeof value.constructor !== \"function\" || value.constructor.name === \"Object\");\n            }\n            /**\n * Returns true if the value is a potentially-persistent data structure, either\n * provided by Immutable.js or a plain Array or Object.\n */ function isDataStructure(value) {\n                return typeof value === \"object\" && (isImmutable(value) || Array.isArray(value) || isPlainObj(value));\n            }\n            /**\n * Converts a value to a string, adding quotes if a string was provided.\n */ function quoteString(value) {\n                try {\n                    return typeof value === \"string\" ? JSON.stringify(value) : String(value);\n                } catch (_ignoreError) {\n                    return JSON.stringify(value);\n                }\n            }\n            function has(collection, key) {\n                return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);\n            }\n            function get(collection, key, notSetValue) {\n                return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === \"function\" ? collection.get(key) : collection[key];\n            }\n            function shallowCopy(from) {\n                if (Array.isArray(from)) {\n                    return arrCopy(from);\n                }\n                var to = {};\n                for(var key in from){\n                    if (hasOwnProperty.call(from, key)) {\n                        to[key] = from[key];\n                    }\n                }\n                return to;\n            }\n            function remove(collection, key) {\n                if (!isDataStructure(collection)) {\n                    throw new TypeError(\"Cannot update non-data-structure value: \" + collection);\n                }\n                if (isImmutable(collection)) {\n                    if (!collection.remove) {\n                        throw new TypeError(\"Cannot update immutable value without .remove() method: \" + collection);\n                    }\n                    return collection.remove(key);\n                }\n                if (!hasOwnProperty.call(collection, key)) {\n                    return collection;\n                }\n                var collectionCopy = shallowCopy(collection);\n                if (Array.isArray(collectionCopy)) {\n                    collectionCopy.splice(key, 1);\n                } else {\n                    delete collectionCopy[key];\n                }\n                return collectionCopy;\n            }\n            function set(collection, key, value) {\n                if (!isDataStructure(collection)) {\n                    throw new TypeError(\"Cannot update non-data-structure value: \" + collection);\n                }\n                if (isImmutable(collection)) {\n                    if (!collection.set) {\n                        throw new TypeError(\"Cannot update immutable value without .set() method: \" + collection);\n                    }\n                    return collection.set(key, value);\n                }\n                if (hasOwnProperty.call(collection, key) && value === collection[key]) {\n                    return collection;\n                }\n                var collectionCopy = shallowCopy(collection);\n                collectionCopy[key] = value;\n                return collectionCopy;\n            }\n            function updateIn(collection, keyPath, notSetValue, updater) {\n                if (!updater) {\n                    updater = notSetValue;\n                    notSetValue = undefined;\n                }\n                var updatedValue = updateInDeeply(isImmutable(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);\n                return updatedValue === NOT_SET ? notSetValue : updatedValue;\n            }\n            function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {\n                var wasNotSet = existing === NOT_SET;\n                if (i === keyPath.length) {\n                    var existingValue = wasNotSet ? notSetValue : existing;\n                    var newValue = updater(existingValue);\n                    return newValue === existingValue ? existing : newValue;\n                }\n                if (!wasNotSet && !isDataStructure(existing)) {\n                    throw new TypeError(\"Cannot update within non-data-structure value in path [\" + keyPath.slice(0, i).map(quoteString) + \"]: \" + existing);\n                }\n                var key = keyPath[i];\n                var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n                var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);\n                return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key, nextUpdated);\n            }\n            function setIn(collection, keyPath, value) {\n                return updateIn(collection, keyPath, NOT_SET, function() {\n                    return value;\n                });\n            }\n            function setIn$1(keyPath, v) {\n                return setIn(this, keyPath, v);\n            }\n            function removeIn(collection, keyPath) {\n                return updateIn(collection, keyPath, function() {\n                    return NOT_SET;\n                });\n            }\n            function deleteIn(keyPath) {\n                return removeIn(this, keyPath);\n            }\n            function update(collection, key, notSetValue, updater) {\n                return updateIn(collection, [\n                    key\n                ], notSetValue, updater);\n            }\n            function update$1(key, notSetValue, updater) {\n                return arguments.length === 1 ? key(this) : update(this, key, notSetValue, updater);\n            }\n            function updateIn$1(keyPath, notSetValue, updater) {\n                return updateIn(this, keyPath, notSetValue, updater);\n            }\n            function merge() {\n                var iters = [], len = arguments.length;\n                while(len--)iters[len] = arguments[len];\n                return mergeIntoKeyedWith(this, iters);\n            }\n            function mergeWith(merger) {\n                var iters = [], len = arguments.length - 1;\n                while(len-- > 0)iters[len] = arguments[len + 1];\n                if (typeof merger !== \"function\") {\n                    throw new TypeError(\"Invalid merger function: \" + merger);\n                }\n                return mergeIntoKeyedWith(this, iters, merger);\n            }\n            function mergeIntoKeyedWith(collection, collections, merger) {\n                var iters = [];\n                for(var ii = 0; ii < collections.length; ii++){\n                    var collection$1 = KeyedCollection(collections[ii]);\n                    if (collection$1.size !== 0) {\n                        iters.push(collection$1);\n                    }\n                }\n                if (iters.length === 0) {\n                    return collection;\n                }\n                if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {\n                    return collection.constructor(iters[0]);\n                }\n                return collection.withMutations(function(collection) {\n                    var mergeIntoCollection = merger ? function(value, key) {\n                        update(collection, key, NOT_SET, function(oldVal) {\n                            return oldVal === NOT_SET ? value : merger(oldVal, value, key);\n                        });\n                    } : function(value, key) {\n                        collection.set(key, value);\n                    };\n                    for(var ii = 0; ii < iters.length; ii++){\n                        iters[ii].forEach(mergeIntoCollection);\n                    }\n                });\n            }\n            function merge$1(collection) {\n                var sources = [], len = arguments.length - 1;\n                while(len-- > 0)sources[len] = arguments[len + 1];\n                return mergeWithSources(collection, sources);\n            }\n            function mergeWith$1(merger, collection) {\n                var sources = [], len = arguments.length - 2;\n                while(len-- > 0)sources[len] = arguments[len + 2];\n                return mergeWithSources(collection, sources, merger);\n            }\n            function mergeDeep(collection) {\n                var sources = [], len = arguments.length - 1;\n                while(len-- > 0)sources[len] = arguments[len + 1];\n                return mergeDeepWithSources(collection, sources);\n            }\n            function mergeDeepWith(merger, collection) {\n                var sources = [], len = arguments.length - 2;\n                while(len-- > 0)sources[len] = arguments[len + 2];\n                return mergeDeepWithSources(collection, sources, merger);\n            }\n            function mergeDeepWithSources(collection, sources, merger) {\n                return mergeWithSources(collection, sources, deepMergerWith(merger));\n            }\n            function mergeWithSources(collection, sources, merger) {\n                if (!isDataStructure(collection)) {\n                    throw new TypeError(\"Cannot merge into non-data-structure value: \" + collection);\n                }\n                if (isImmutable(collection)) {\n                    return typeof merger === \"function\" && collection.mergeWith ? collection.mergeWith.apply(collection, [\n                        merger\n                    ].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);\n                }\n                var isArray = Array.isArray(collection);\n                var merged = collection;\n                var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;\n                var mergeItem = isArray ? function(value) {\n                    // Copy on write\n                    if (merged === collection) {\n                        merged = shallowCopy(merged);\n                    }\n                    merged.push(value);\n                } : function(value, key) {\n                    var hasVal = hasOwnProperty.call(merged, key);\n                    var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;\n                    if (!hasVal || nextVal !== merged[key]) {\n                        // Copy on write\n                        if (merged === collection) {\n                            merged = shallowCopy(merged);\n                        }\n                        merged[key] = nextVal;\n                    }\n                };\n                for(var i = 0; i < sources.length; i++){\n                    Collection$$1(sources[i]).forEach(mergeItem);\n                }\n                return merged;\n            }\n            function deepMergerWith(merger) {\n                function deepMerger(oldValue, newValue, key) {\n                    return isDataStructure(oldValue) && isDataStructure(newValue) ? mergeWithSources(oldValue, [\n                        newValue\n                    ], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;\n                }\n                return deepMerger;\n            }\n            function mergeDeep$1() {\n                var iters = [], len = arguments.length;\n                while(len--)iters[len] = arguments[len];\n                return mergeDeepWithSources(this, iters);\n            }\n            function mergeDeepWith$1(merger) {\n                var iters = [], len = arguments.length - 1;\n                while(len-- > 0)iters[len] = arguments[len + 1];\n                return mergeDeepWithSources(this, iters, merger);\n            }\n            function mergeIn(keyPath) {\n                var iters = [], len = arguments.length - 1;\n                while(len-- > 0)iters[len] = arguments[len + 1];\n                return updateIn(this, keyPath, emptyMap(), function(m) {\n                    return mergeWithSources(m, iters);\n                });\n            }\n            function mergeDeepIn(keyPath) {\n                var iters = [], len = arguments.length - 1;\n                while(len-- > 0)iters[len] = arguments[len + 1];\n                return updateIn(this, keyPath, emptyMap(), function(m) {\n                    return mergeDeepWithSources(m, iters);\n                });\n            }\n            function withMutations(fn) {\n                var mutable = this.asMutable();\n                fn(mutable);\n                return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n            }\n            function asMutable() {\n                return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n            }\n            function asImmutable() {\n                return this.__ensureOwner();\n            }\n            function wasAltered() {\n                return this.__altered;\n            }\n            var Map = /*@__PURE__*/ function(KeyedCollection$$1) {\n                function Map(value) {\n                    return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map) {\n                        var iter = KeyedCollection$$1(value);\n                        assertNotInfinite(iter.size);\n                        iter.forEach(function(v, k) {\n                            return map.set(k, v);\n                        });\n                    });\n                }\n                if (KeyedCollection$$1) Map.__proto__ = KeyedCollection$$1;\n                Map.prototype = Object.create(KeyedCollection$$1 && KeyedCollection$$1.prototype);\n                Map.prototype.constructor = Map;\n                Map.of = function of() {\n                    var keyValues = [], len = arguments.length;\n                    while(len--)keyValues[len] = arguments[len];\n                    return emptyMap().withMutations(function(map) {\n                        for(var i = 0; i < keyValues.length; i += 2){\n                            if (i + 1 >= keyValues.length) {\n                                throw new Error(\"Missing value for key: \" + keyValues[i]);\n                            }\n                            map.set(keyValues[i], keyValues[i + 1]);\n                        }\n                    });\n                };\n                Map.prototype.toString = function toString() {\n                    return this.__toString(\"Map {\", \"}\");\n                };\n                // @pragma Access\n                Map.prototype.get = function get(k, notSetValue) {\n                    return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;\n                };\n                // @pragma Modification\n                Map.prototype.set = function set(k, v) {\n                    return updateMap(this, k, v);\n                };\n                Map.prototype.remove = function remove(k) {\n                    return updateMap(this, k, NOT_SET);\n                };\n                Map.prototype.deleteAll = function deleteAll(keys) {\n                    var collection = Collection(keys);\n                    if (collection.size === 0) {\n                        return this;\n                    }\n                    return this.withMutations(function(map) {\n                        collection.forEach(function(key) {\n                            return map.remove(key);\n                        });\n                    });\n                };\n                Map.prototype.clear = function clear() {\n                    if (this.size === 0) {\n                        return this;\n                    }\n                    if (this.__ownerID) {\n                        this.size = 0;\n                        this._root = null;\n                        this.__hash = undefined;\n                        this.__altered = true;\n                        return this;\n                    }\n                    return emptyMap();\n                };\n                // @pragma Composition\n                Map.prototype.sort = function sort(comparator) {\n                    // Late binding\n                    return OrderedMap(sortFactory(this, comparator));\n                };\n                Map.prototype.sortBy = function sortBy(mapper, comparator) {\n                    // Late binding\n                    return OrderedMap(sortFactory(this, comparator, mapper));\n                };\n                Map.prototype.map = function map(mapper, context) {\n                    return this.withMutations(function(map) {\n                        map.forEach(function(value, key) {\n                            map.set(key, mapper.call(context, value, key, map));\n                        });\n                    });\n                };\n                // @pragma Mutability\n                Map.prototype.__iterator = function __iterator(type, reverse) {\n                    return new MapIterator(this, type, reverse);\n                };\n                Map.prototype.__iterate = function __iterate(fn, reverse) {\n                    var this$1 = this;\n                    var iterations = 0;\n                    this._root && this._root.iterate(function(entry) {\n                        iterations++;\n                        return fn(entry[1], entry[0], this$1);\n                    }, reverse);\n                    return iterations;\n                };\n                Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n                    if (ownerID === this.__ownerID) {\n                        return this;\n                    }\n                    if (!ownerID) {\n                        if (this.size === 0) {\n                            return emptyMap();\n                        }\n                        this.__ownerID = ownerID;\n                        this.__altered = false;\n                        return this;\n                    }\n                    return makeMap(this.size, this._root, ownerID, this.__hash);\n                };\n                return Map;\n            }(KeyedCollection);\n            Map.isMap = isMap;\n            var MapPrototype = Map.prototype;\n            MapPrototype[IS_MAP_SYMBOL] = true;\n            MapPrototype[DELETE] = MapPrototype.remove;\n            MapPrototype.removeAll = MapPrototype.deleteAll;\n            MapPrototype.setIn = setIn$1;\n            MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\n            MapPrototype.update = update$1;\n            MapPrototype.updateIn = updateIn$1;\n            MapPrototype.merge = MapPrototype.concat = merge;\n            MapPrototype.mergeWith = mergeWith;\n            MapPrototype.mergeDeep = mergeDeep$1;\n            MapPrototype.mergeDeepWith = mergeDeepWith$1;\n            MapPrototype.mergeIn = mergeIn;\n            MapPrototype.mergeDeepIn = mergeDeepIn;\n            MapPrototype.withMutations = withMutations;\n            MapPrototype.wasAltered = wasAltered;\n            MapPrototype.asImmutable = asImmutable;\n            MapPrototype[\"@@transducer/init\"] = MapPrototype.asMutable = asMutable;\n            MapPrototype[\"@@transducer/step\"] = function(result, arr) {\n                return result.set(arr[0], arr[1]);\n            };\n            MapPrototype[\"@@transducer/result\"] = function(obj) {\n                return obj.asImmutable();\n            };\n            // #pragma Trie Nodes\n            var ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n                this.ownerID = ownerID;\n                this.entries = entries;\n            };\n            ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n                var entries = this.entries;\n                for(var ii = 0, len = entries.length; ii < len; ii++){\n                    if (is(key, entries[ii][0])) {\n                        return entries[ii][1];\n                    }\n                }\n                return notSetValue;\n            };\n            ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n                var removed = value === NOT_SET;\n                var entries = this.entries;\n                var idx = 0;\n                var len = entries.length;\n                for(; idx < len; idx++){\n                    if (is(key, entries[idx][0])) {\n                        break;\n                    }\n                }\n                var exists = idx < len;\n                if (exists ? entries[idx][1] === value : removed) {\n                    return this;\n                }\n                SetRef(didAlter);\n                (removed || !exists) && SetRef(didChangeSize);\n                if (removed && entries.length === 1) {\n                    return; // undefined\n                }\n                if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n                    return createNodes(ownerID, entries, key, value);\n                }\n                var isEditable = ownerID && ownerID === this.ownerID;\n                var newEntries = isEditable ? entries : arrCopy(entries);\n                if (exists) {\n                    if (removed) {\n                        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n                    } else {\n                        newEntries[idx] = [\n                            key,\n                            value\n                        ];\n                    }\n                } else {\n                    newEntries.push([\n                        key,\n                        value\n                    ]);\n                }\n                if (isEditable) {\n                    this.entries = newEntries;\n                    return this;\n                }\n                return new ArrayMapNode(ownerID, newEntries);\n            };\n            var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n                this.ownerID = ownerID;\n                this.bitmap = bitmap;\n                this.nodes = nodes;\n            };\n            BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n                if (keyHash === undefined) {\n                    keyHash = hash(key);\n                }\n                var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n                var bitmap = this.bitmap;\n                return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);\n            };\n            BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n                if (keyHash === undefined) {\n                    keyHash = hash(key);\n                }\n                var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n                var bit = 1 << keyHashFrag;\n                var bitmap = this.bitmap;\n                var exists = (bitmap & bit) !== 0;\n                if (!exists && value === NOT_SET) {\n                    return this;\n                }\n                var idx = popCount(bitmap & bit - 1);\n                var nodes = this.nodes;\n                var node = exists ? nodes[idx] : undefined;\n                var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n                if (newNode === node) {\n                    return this;\n                }\n                if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n                    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n                }\n                if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n                    return nodes[idx ^ 1];\n                }\n                if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n                    return newNode;\n                }\n                var isEditable = ownerID && ownerID === this.ownerID;\n                var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n                var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);\n                if (isEditable) {\n                    this.bitmap = newBitmap;\n                    this.nodes = newNodes;\n                    return this;\n                }\n                return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n            };\n            var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n                this.ownerID = ownerID;\n                this.count = count;\n                this.nodes = nodes;\n            };\n            HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n                if (keyHash === undefined) {\n                    keyHash = hash(key);\n                }\n                var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n                var node = this.nodes[idx];\n                return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n            };\n            HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n                if (keyHash === undefined) {\n                    keyHash = hash(key);\n                }\n                var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n                var removed = value === NOT_SET;\n                var nodes = this.nodes;\n                var node = nodes[idx];\n                if (removed && !node) {\n                    return this;\n                }\n                var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n                if (newNode === node) {\n                    return this;\n                }\n                var newCount = this.count;\n                if (!node) {\n                    newCount++;\n                } else if (!newNode) {\n                    newCount--;\n                    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n                        return packNodes(ownerID, nodes, newCount, idx);\n                    }\n                }\n                var isEditable = ownerID && ownerID === this.ownerID;\n                var newNodes = setAt(nodes, idx, newNode, isEditable);\n                if (isEditable) {\n                    this.count = newCount;\n                    this.nodes = newNodes;\n                    return this;\n                }\n                return new HashArrayMapNode(ownerID, newCount, newNodes);\n            };\n            var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n                this.ownerID = ownerID;\n                this.keyHash = keyHash;\n                this.entries = entries;\n            };\n            HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n                var entries = this.entries;\n                for(var ii = 0, len = entries.length; ii < len; ii++){\n                    if (is(key, entries[ii][0])) {\n                        return entries[ii][1];\n                    }\n                }\n                return notSetValue;\n            };\n            HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n                if (keyHash === undefined) {\n                    keyHash = hash(key);\n                }\n                var removed = value === NOT_SET;\n                if (keyHash !== this.keyHash) {\n                    if (removed) {\n                        return this;\n                    }\n                    SetRef(didAlter);\n                    SetRef(didChangeSize);\n                    return mergeIntoNode(this, ownerID, shift, keyHash, [\n                        key,\n                        value\n                    ]);\n                }\n                var entries = this.entries;\n                var idx = 0;\n                var len = entries.length;\n                for(; idx < len; idx++){\n                    if (is(key, entries[idx][0])) {\n                        break;\n                    }\n                }\n                var exists = idx < len;\n                if (exists ? entries[idx][1] === value : removed) {\n                    return this;\n                }\n                SetRef(didAlter);\n                (removed || !exists) && SetRef(didChangeSize);\n                if (removed && len === 2) {\n                    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n                }\n                var isEditable = ownerID && ownerID === this.ownerID;\n                var newEntries = isEditable ? entries : arrCopy(entries);\n                if (exists) {\n                    if (removed) {\n                        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n                    } else {\n                        newEntries[idx] = [\n                            key,\n                            value\n                        ];\n                    }\n                } else {\n                    newEntries.push([\n                        key,\n                        value\n                    ]);\n                }\n                if (isEditable) {\n                    this.entries = newEntries;\n                    return this;\n                }\n                return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n            };\n            var ValueNode = function ValueNode(ownerID, keyHash, entry) {\n                this.ownerID = ownerID;\n                this.keyHash = keyHash;\n                this.entry = entry;\n            };\n            ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n                return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n            };\n            ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n                var removed = value === NOT_SET;\n                var keyMatch = is(key, this.entry[0]);\n                if (keyMatch ? value === this.entry[1] : removed) {\n                    return this;\n                }\n                SetRef(didAlter);\n                if (removed) {\n                    SetRef(didChangeSize);\n                    return; // undefined\n                }\n                if (keyMatch) {\n                    if (ownerID && ownerID === this.ownerID) {\n                        this.entry[1] = value;\n                        return this;\n                    }\n                    return new ValueNode(ownerID, this.keyHash, [\n                        key,\n                        value\n                    ]);\n                }\n                SetRef(didChangeSize);\n                return mergeIntoNode(this, ownerID, shift, hash(key), [\n                    key,\n                    value\n                ]);\n            };\n            // #pragma Iterators\n            ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse) {\n                var entries = this.entries;\n                for(var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++){\n                    if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n                        return false;\n                    }\n                }\n            };\n            BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse) {\n                var nodes = this.nodes;\n                for(var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++){\n                    var node = nodes[reverse ? maxIndex - ii : ii];\n                    if (node && node.iterate(fn, reverse) === false) {\n                        return false;\n                    }\n                }\n            };\n            // eslint-disable-next-line no-unused-vars\n            ValueNode.prototype.iterate = function(fn, reverse) {\n                return fn(this.entry);\n            };\n            var MapIterator = /*@__PURE__*/ function(Iterator$$1) {\n                function MapIterator(map, type, reverse) {\n                    this._type = type;\n                    this._reverse = reverse;\n                    this._stack = map._root && mapIteratorFrame(map._root);\n                }\n                if (Iterator$$1) MapIterator.__proto__ = Iterator$$1;\n                MapIterator.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);\n                MapIterator.prototype.constructor = MapIterator;\n                MapIterator.prototype.next = function next() {\n                    var type = this._type;\n                    var stack = this._stack;\n                    while(stack){\n                        var node = stack.node;\n                        var index = stack.index++;\n                        var maxIndex = void 0;\n                        if (node.entry) {\n                            if (index === 0) {\n                                return mapIteratorValue(type, node.entry);\n                            }\n                        } else if (node.entries) {\n                            maxIndex = node.entries.length - 1;\n                            if (index <= maxIndex) {\n                                return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n                            }\n                        } else {\n                            maxIndex = node.nodes.length - 1;\n                            if (index <= maxIndex) {\n                                var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n                                if (subNode) {\n                                    if (subNode.entry) {\n                                        return mapIteratorValue(type, subNode.entry);\n                                    }\n                                    stack = this._stack = mapIteratorFrame(subNode, stack);\n                                }\n                                continue;\n                            }\n                        }\n                        stack = this._stack = this._stack.__prev;\n                    }\n                    return iteratorDone();\n                };\n                return MapIterator;\n            }(Iterator);\n            function mapIteratorValue(type, entry) {\n                return iteratorValue(type, entry[0], entry[1]);\n            }\n            function mapIteratorFrame(node, prev) {\n                return {\n                    node: node,\n                    index: 0,\n                    __prev: prev\n                };\n            }\n            function makeMap(size, root, ownerID, hash$$1) {\n                var map = Object.create(MapPrototype);\n                map.size = size;\n                map._root = root;\n                map.__ownerID = ownerID;\n                map.__hash = hash$$1;\n                map.__altered = false;\n                return map;\n            }\n            var EMPTY_MAP;\n            function emptyMap() {\n                return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n            }\n            function updateMap(map, k, v) {\n                var newRoot;\n                var newSize;\n                if (!map._root) {\n                    if (v === NOT_SET) {\n                        return map;\n                    }\n                    newSize = 1;\n                    newRoot = new ArrayMapNode(map.__ownerID, [\n                        [\n                            k,\n                            v\n                        ]\n                    ]);\n                } else {\n                    var didChangeSize = MakeRef();\n                    var didAlter = MakeRef();\n                    newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n                    if (!didAlter.value) {\n                        return map;\n                    }\n                    newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n                }\n                if (map.__ownerID) {\n                    map.size = newSize;\n                    map._root = newRoot;\n                    map.__hash = undefined;\n                    map.__altered = true;\n                    return map;\n                }\n                return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n            }\n            function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n                if (!node) {\n                    if (value === NOT_SET) {\n                        return node;\n                    }\n                    SetRef(didAlter);\n                    SetRef(didChangeSize);\n                    return new ValueNode(ownerID, keyHash, [\n                        key,\n                        value\n                    ]);\n                }\n                return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n            }\n            function isLeafNode(node) {\n                return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n            }\n            function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n                if (node.keyHash === keyHash) {\n                    return new HashCollisionNode(ownerID, keyHash, [\n                        node.entry,\n                        entry\n                    ]);\n                }\n                var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n                var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n                var newNode;\n                var nodes = idx1 === idx2 ? [\n                    mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)\n                ] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [\n                    node,\n                    newNode\n                ] : [\n                    newNode,\n                    node\n                ]);\n                return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);\n            }\n            function createNodes(ownerID, entries, key, value) {\n                if (!ownerID) {\n                    ownerID = new OwnerID();\n                }\n                var node = new ValueNode(ownerID, hash(key), [\n                    key,\n                    value\n                ]);\n                for(var ii = 0; ii < entries.length; ii++){\n                    var entry = entries[ii];\n                    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n                }\n                return node;\n            }\n            function packNodes(ownerID, nodes, count, excluding) {\n                var bitmap = 0;\n                var packedII = 0;\n                var packedNodes = new Array(count);\n                for(var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1){\n                    var node = nodes[ii];\n                    if (node !== undefined && ii !== excluding) {\n                        bitmap |= bit;\n                        packedNodes[packedII++] = node;\n                    }\n                }\n                return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n            }\n            function expandNodes(ownerID, nodes, bitmap, including, node) {\n                var count = 0;\n                var expandedNodes = new Array(SIZE);\n                for(var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1){\n                    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n                }\n                expandedNodes[including] = node;\n                return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n            }\n            function popCount(x) {\n                x -= x >> 1 & 0x55555555;\n                x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n                x = x + (x >> 4) & 0x0f0f0f0f;\n                x += x >> 8;\n                x += x >> 16;\n                return x & 0x7f;\n            }\n            function setAt(array, idx, val, canEdit) {\n                var newArray = canEdit ? array : arrCopy(array);\n                newArray[idx] = val;\n                return newArray;\n            }\n            function spliceIn(array, idx, val, canEdit) {\n                var newLen = array.length + 1;\n                if (canEdit && idx + 1 === newLen) {\n                    array[idx] = val;\n                    return array;\n                }\n                var newArray = new Array(newLen);\n                var after = 0;\n                for(var ii = 0; ii < newLen; ii++){\n                    if (ii === idx) {\n                        newArray[ii] = val;\n                        after = -1;\n                    } else {\n                        newArray[ii] = array[ii + after];\n                    }\n                }\n                return newArray;\n            }\n            function spliceOut(array, idx, canEdit) {\n                var newLen = array.length - 1;\n                if (canEdit && idx === newLen) {\n                    array.pop();\n                    return array;\n                }\n                var newArray = new Array(newLen);\n                var after = 0;\n                for(var ii = 0; ii < newLen; ii++){\n                    if (ii === idx) {\n                        after = 1;\n                    }\n                    newArray[ii] = array[ii + after];\n                }\n                return newArray;\n            }\n            var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n            var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n            var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n            var IS_LIST_SYMBOL = \"@@__IMMUTABLE_LIST__@@\";\n            function isList(maybeList) {\n                return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);\n            }\n            var List = /*@__PURE__*/ function(IndexedCollection$$1) {\n                function List(value) {\n                    var empty = emptyList();\n                    if (value === null || value === undefined) {\n                        return empty;\n                    }\n                    if (isList(value)) {\n                        return value;\n                    }\n                    var iter = IndexedCollection$$1(value);\n                    var size = iter.size;\n                    if (size === 0) {\n                        return empty;\n                    }\n                    assertNotInfinite(size);\n                    if (size > 0 && size < SIZE) {\n                        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n                    }\n                    return empty.withMutations(function(list) {\n                        list.setSize(size);\n                        iter.forEach(function(v, i) {\n                            return list.set(i, v);\n                        });\n                    });\n                }\n                if (IndexedCollection$$1) List.__proto__ = IndexedCollection$$1;\n                List.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);\n                List.prototype.constructor = List;\n                List.of = function of() {\n                    return this(arguments);\n                };\n                List.prototype.toString = function toString() {\n                    return this.__toString(\"List [\", \"]\");\n                };\n                // @pragma Access\n                List.prototype.get = function get(index, notSetValue) {\n                    index = wrapIndex(this, index);\n                    if (index >= 0 && index < this.size) {\n                        index += this._origin;\n                        var node = listNodeFor(this, index);\n                        return node && node.array[index & MASK];\n                    }\n                    return notSetValue;\n                };\n                // @pragma Modification\n                List.prototype.set = function set(index, value) {\n                    return updateList(this, index, value);\n                };\n                List.prototype.remove = function remove(index) {\n                    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);\n                };\n                List.prototype.insert = function insert(index, value) {\n                    return this.splice(index, 0, value);\n                };\n                List.prototype.clear = function clear() {\n                    if (this.size === 0) {\n                        return this;\n                    }\n                    if (this.__ownerID) {\n                        this.size = this._origin = this._capacity = 0;\n                        this._level = SHIFT;\n                        this._root = this._tail = null;\n                        this.__hash = undefined;\n                        this.__altered = true;\n                        return this;\n                    }\n                    return emptyList();\n                };\n                List.prototype.push = function push() {\n                    var values = arguments;\n                    var oldSize = this.size;\n                    return this.withMutations(function(list) {\n                        setListBounds(list, 0, oldSize + values.length);\n                        for(var ii = 0; ii < values.length; ii++){\n                            list.set(oldSize + ii, values[ii]);\n                        }\n                    });\n                };\n                List.prototype.pop = function pop() {\n                    return setListBounds(this, 0, -1);\n                };\n                List.prototype.unshift = function unshift() {\n                    var values = arguments;\n                    return this.withMutations(function(list) {\n                        setListBounds(list, -values.length);\n                        for(var ii = 0; ii < values.length; ii++){\n                            list.set(ii, values[ii]);\n                        }\n                    });\n                };\n                List.prototype.shift = function shift() {\n                    return setListBounds(this, 1);\n                };\n                // @pragma Composition\n                List.prototype.concat = function concat() {\n                    var arguments$1 = arguments;\n                    var seqs = [];\n                    for(var i = 0; i < arguments.length; i++){\n                        var argument = arguments$1[i];\n                        var seq = IndexedCollection$$1(typeof argument !== \"string\" && hasIterator(argument) ? argument : [\n                            argument\n                        ]);\n                        if (seq.size !== 0) {\n                            seqs.push(seq);\n                        }\n                    }\n                    if (seqs.length === 0) {\n                        return this;\n                    }\n                    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n                        return this.constructor(seqs[0]);\n                    }\n                    return this.withMutations(function(list) {\n                        seqs.forEach(function(seq) {\n                            return seq.forEach(function(value) {\n                                return list.push(value);\n                            });\n                        });\n                    });\n                };\n                List.prototype.setSize = function setSize(size) {\n                    return setListBounds(this, 0, size);\n                };\n                List.prototype.map = function map(mapper, context) {\n                    var this$1 = this;\n                    return this.withMutations(function(list) {\n                        for(var i = 0; i < this$1.size; i++){\n                            list.set(i, mapper.call(context, list.get(i), i, list));\n                        }\n                    });\n                };\n                // @pragma Iteration\n                List.prototype.slice = function slice(begin, end) {\n                    var size = this.size;\n                    if (wholeSlice(begin, end, size)) {\n                        return this;\n                    }\n                    return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));\n                };\n                List.prototype.__iterator = function __iterator(type, reverse) {\n                    var index = reverse ? this.size : 0;\n                    var values = iterateList(this, reverse);\n                    return new Iterator(function() {\n                        var value = values();\n                        return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);\n                    });\n                };\n                List.prototype.__iterate = function __iterate(fn, reverse) {\n                    var index = reverse ? this.size : 0;\n                    var values = iterateList(this, reverse);\n                    var value;\n                    while((value = values()) !== DONE){\n                        if (fn(value, reverse ? --index : index++, this) === false) {\n                            break;\n                        }\n                    }\n                    return index;\n                };\n                List.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n                    if (ownerID === this.__ownerID) {\n                        return this;\n                    }\n                    if (!ownerID) {\n                        if (this.size === 0) {\n                            return emptyList();\n                        }\n                        this.__ownerID = ownerID;\n                        this.__altered = false;\n                        return this;\n                    }\n                    return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n                };\n                return List;\n            }(IndexedCollection);\n            List.isList = isList;\n            var ListPrototype = List.prototype;\n            ListPrototype[IS_LIST_SYMBOL] = true;\n            ListPrototype[DELETE] = ListPrototype.remove;\n            ListPrototype.merge = ListPrototype.concat;\n            ListPrototype.setIn = setIn$1;\n            ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\n            ListPrototype.update = update$1;\n            ListPrototype.updateIn = updateIn$1;\n            ListPrototype.mergeIn = mergeIn;\n            ListPrototype.mergeDeepIn = mergeDeepIn;\n            ListPrototype.withMutations = withMutations;\n            ListPrototype.wasAltered = wasAltered;\n            ListPrototype.asImmutable = asImmutable;\n            ListPrototype[\"@@transducer/init\"] = ListPrototype.asMutable = asMutable;\n            ListPrototype[\"@@transducer/step\"] = function(result, arr) {\n                return result.push(arr);\n            };\n            ListPrototype[\"@@transducer/result\"] = function(obj) {\n                return obj.asImmutable();\n            };\n            var VNode = function VNode(array, ownerID) {\n                this.array = array;\n                this.ownerID = ownerID;\n            };\n            // TODO: seems like these methods are very similar\n            VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {\n                if (index === level ? 1 << level : this.array.length === 0) {\n                    return this;\n                }\n                var originIndex = index >>> level & MASK;\n                if (originIndex >= this.array.length) {\n                    return new VNode([], ownerID);\n                }\n                var removingFirst = originIndex === 0;\n                var newChild;\n                if (level > 0) {\n                    var oldChild = this.array[originIndex];\n                    newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n                    if (newChild === oldChild && removingFirst) {\n                        return this;\n                    }\n                }\n                if (removingFirst && !newChild) {\n                    return this;\n                }\n                var editable = editableVNode(this, ownerID);\n                if (!removingFirst) {\n                    for(var ii = 0; ii < originIndex; ii++){\n                        editable.array[ii] = undefined;\n                    }\n                }\n                if (newChild) {\n                    editable.array[originIndex] = newChild;\n                }\n                return editable;\n            };\n            VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {\n                if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n                    return this;\n                }\n                var sizeIndex = index - 1 >>> level & MASK;\n                if (sizeIndex >= this.array.length) {\n                    return this;\n                }\n                var newChild;\n                if (level > 0) {\n                    var oldChild = this.array[sizeIndex];\n                    newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n                    if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n                        return this;\n                    }\n                }\n                var editable = editableVNode(this, ownerID);\n                editable.array.splice(sizeIndex + 1);\n                if (newChild) {\n                    editable.array[sizeIndex] = newChild;\n                }\n                return editable;\n            };\n            var DONE = {};\n            function iterateList(list, reverse) {\n                var left = list._origin;\n                var right = list._capacity;\n                var tailPos = getTailOffset(right);\n                var tail = list._tail;\n                return iterateNodeOrLeaf(list._root, list._level, 0);\n                function iterateNodeOrLeaf(node, level, offset) {\n                    return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);\n                }\n                function iterateLeaf(node, offset) {\n                    var array = offset === tailPos ? tail && tail.array : node && node.array;\n                    var from = offset > left ? 0 : left - offset;\n                    var to = right - offset;\n                    if (to > SIZE) {\n                        to = SIZE;\n                    }\n                    return function() {\n                        if (from === to) {\n                            return DONE;\n                        }\n                        var idx = reverse ? --to : from++;\n                        return array && array[idx];\n                    };\n                }\n                function iterateNode(node, level, offset) {\n                    var values;\n                    var array = node && node.array;\n                    var from = offset > left ? 0 : left - offset >> level;\n                    var to = (right - offset >> level) + 1;\n                    if (to > SIZE) {\n                        to = SIZE;\n                    }\n                    return function() {\n                        while(true){\n                            if (values) {\n                                var value = values();\n                                if (value !== DONE) {\n                                    return value;\n                                }\n                                values = null;\n                            }\n                            if (from === to) {\n                                return DONE;\n                            }\n                            var idx = reverse ? --to : from++;\n                            values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));\n                        }\n                    };\n                }\n            }\n            function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n                var list = Object.create(ListPrototype);\n                list.size = capacity - origin;\n                list._origin = origin;\n                list._capacity = capacity;\n                list._level = level;\n                list._root = root;\n                list._tail = tail;\n                list.__ownerID = ownerID;\n                list.__hash = hash;\n                list.__altered = false;\n                return list;\n            }\n            var EMPTY_LIST;\n            function emptyList() {\n                return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n            }\n            function updateList(list, index, value) {\n                index = wrapIndex(list, index);\n                if (index !== index) {\n                    return list;\n                }\n                if (index >= list.size || index < 0) {\n                    return list.withMutations(function(list) {\n                        index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);\n                    });\n                }\n                index += list._origin;\n                var newTail = list._tail;\n                var newRoot = list._root;\n                var didAlter = MakeRef();\n                if (index >= getTailOffset(list._capacity)) {\n                    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n                } else {\n                    newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n                }\n                if (!didAlter.value) {\n                    return list;\n                }\n                if (list.__ownerID) {\n                    list._root = newRoot;\n                    list._tail = newTail;\n                    list.__hash = undefined;\n                    list.__altered = true;\n                    return list;\n                }\n                return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n            }\n            function updateVNode(node, ownerID, level, index, value, didAlter) {\n                var idx = index >>> level & MASK;\n                var nodeHas = node && idx < node.array.length;\n                if (!nodeHas && value === undefined) {\n                    return node;\n                }\n                var newNode;\n                if (level > 0) {\n                    var lowerNode = node && node.array[idx];\n                    var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n                    if (newLowerNode === lowerNode) {\n                        return node;\n                    }\n                    newNode = editableVNode(node, ownerID);\n                    newNode.array[idx] = newLowerNode;\n                    return newNode;\n                }\n                if (nodeHas && node.array[idx] === value) {\n                    return node;\n                }\n                if (didAlter) {\n                    SetRef(didAlter);\n                }\n                newNode = editableVNode(node, ownerID);\n                if (value === undefined && idx === newNode.array.length - 1) {\n                    newNode.array.pop();\n                } else {\n                    newNode.array[idx] = value;\n                }\n                return newNode;\n            }\n            function editableVNode(node, ownerID) {\n                if (ownerID && node && ownerID === node.ownerID) {\n                    return node;\n                }\n                return new VNode(node ? node.array.slice() : [], ownerID);\n            }\n            function listNodeFor(list, rawIndex) {\n                if (rawIndex >= getTailOffset(list._capacity)) {\n                    return list._tail;\n                }\n                if (rawIndex < 1 << list._level + SHIFT) {\n                    var node = list._root;\n                    var level = list._level;\n                    while(node && level > 0){\n                        node = node.array[rawIndex >>> level & MASK];\n                        level -= SHIFT;\n                    }\n                    return node;\n                }\n            }\n            function setListBounds(list, begin, end) {\n                // Sanitize begin & end using this shorthand for ToInt32(argument)\n                // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n                if (begin !== undefined) {\n                    begin |= 0;\n                }\n                if (end !== undefined) {\n                    end |= 0;\n                }\n                var owner = list.__ownerID || new OwnerID();\n                var oldOrigin = list._origin;\n                var oldCapacity = list._capacity;\n                var newOrigin = oldOrigin + begin;\n                var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n                if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n                    return list;\n                }\n                // If it's going to end after it starts, it's empty.\n                if (newOrigin >= newCapacity) {\n                    return list.clear();\n                }\n                var newLevel = list._level;\n                var newRoot = list._root;\n                // New origin might need creating a higher root.\n                var offsetShift = 0;\n                while(newOrigin + offsetShift < 0){\n                    newRoot = new VNode(newRoot && newRoot.array.length ? [\n                        undefined,\n                        newRoot\n                    ] : [], owner);\n                    newLevel += SHIFT;\n                    offsetShift += 1 << newLevel;\n                }\n                if (offsetShift) {\n                    newOrigin += offsetShift;\n                    oldOrigin += offsetShift;\n                    newCapacity += offsetShift;\n                    oldCapacity += offsetShift;\n                }\n                var oldTailOffset = getTailOffset(oldCapacity);\n                var newTailOffset = getTailOffset(newCapacity);\n                // New size might need creating a higher root.\n                while(newTailOffset >= 1 << newLevel + SHIFT){\n                    newRoot = new VNode(newRoot && newRoot.array.length ? [\n                        newRoot\n                    ] : [], owner);\n                    newLevel += SHIFT;\n                }\n                // Locate or create the new tail.\n                var oldTail = list._tail;\n                var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n                // Merge Tail into tree.\n                if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n                    newRoot = editableVNode(newRoot, owner);\n                    var node = newRoot;\n                    for(var level = newLevel; level > SHIFT; level -= SHIFT){\n                        var idx = oldTailOffset >>> level & MASK;\n                        node = node.array[idx] = editableVNode(node.array[idx], owner);\n                    }\n                    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;\n                }\n                // If the size has been reduced, there's a chance the tail needs to be trimmed.\n                if (newCapacity < oldCapacity) {\n                    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n                }\n                // If the new origin is within the tail, then we do not need a root.\n                if (newOrigin >= newTailOffset) {\n                    newOrigin -= newTailOffset;\n                    newCapacity -= newTailOffset;\n                    newLevel = SHIFT;\n                    newRoot = null;\n                    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n                // Otherwise, if the root has been trimmed, garbage collect.\n                } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n                    offsetShift = 0;\n                    // Identify the new top root node of the subtree of the old root.\n                    while(newRoot){\n                        var beginIndex = newOrigin >>> newLevel & MASK;\n                        if (beginIndex !== newTailOffset >>> newLevel & MASK) {\n                            break;\n                        }\n                        if (beginIndex) {\n                            offsetShift += (1 << newLevel) * beginIndex;\n                        }\n                        newLevel -= SHIFT;\n                        newRoot = newRoot.array[beginIndex];\n                    }\n                    // Trim the new sides of the new root.\n                    if (newRoot && newOrigin > oldOrigin) {\n                        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n                    }\n                    if (newRoot && newTailOffset < oldTailOffset) {\n                        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n                    }\n                    if (offsetShift) {\n                        newOrigin -= offsetShift;\n                        newCapacity -= offsetShift;\n                    }\n                }\n                if (list.__ownerID) {\n                    list.size = newCapacity - newOrigin;\n                    list._origin = newOrigin;\n                    list._capacity = newCapacity;\n                    list._level = newLevel;\n                    list._root = newRoot;\n                    list._tail = newTail;\n                    list.__hash = undefined;\n                    list.__altered = true;\n                    return list;\n                }\n                return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n            }\n            function getTailOffset(size) {\n                return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;\n            }\n            var OrderedMap = /*@__PURE__*/ function(Map$$1) {\n                function OrderedMap(value) {\n                    return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map) {\n                        var iter = KeyedCollection(value);\n                        assertNotInfinite(iter.size);\n                        iter.forEach(function(v, k) {\n                            return map.set(k, v);\n                        });\n                    });\n                }\n                if (Map$$1) OrderedMap.__proto__ = Map$$1;\n                OrderedMap.prototype = Object.create(Map$$1 && Map$$1.prototype);\n                OrderedMap.prototype.constructor = OrderedMap;\n                OrderedMap.of = function of() {\n                    return this(arguments);\n                };\n                OrderedMap.prototype.toString = function toString() {\n                    return this.__toString(\"OrderedMap {\", \"}\");\n                };\n                // @pragma Access\n                OrderedMap.prototype.get = function get(k, notSetValue) {\n                    var index = this._map.get(k);\n                    return index !== undefined ? this._list.get(index)[1] : notSetValue;\n                };\n                // @pragma Modification\n                OrderedMap.prototype.clear = function clear() {\n                    if (this.size === 0) {\n                        return this;\n                    }\n                    if (this.__ownerID) {\n                        this.size = 0;\n                        this._map.clear();\n                        this._list.clear();\n                        return this;\n                    }\n                    return emptyOrderedMap();\n                };\n                OrderedMap.prototype.set = function set(k, v) {\n                    return updateOrderedMap(this, k, v);\n                };\n                OrderedMap.prototype.remove = function remove(k) {\n                    return updateOrderedMap(this, k, NOT_SET);\n                };\n                OrderedMap.prototype.wasAltered = function wasAltered() {\n                    return this._map.wasAltered() || this._list.wasAltered();\n                };\n                OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {\n                    var this$1 = this;\n                    return this._list.__iterate(function(entry) {\n                        return entry && fn(entry[1], entry[0], this$1);\n                    }, reverse);\n                };\n                OrderedMap.prototype.__iterator = function __iterator(type, reverse) {\n                    return this._list.fromEntrySeq().__iterator(type, reverse);\n                };\n                OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n                    if (ownerID === this.__ownerID) {\n                        return this;\n                    }\n                    var newMap = this._map.__ensureOwner(ownerID);\n                    var newList = this._list.__ensureOwner(ownerID);\n                    if (!ownerID) {\n                        if (this.size === 0) {\n                            return emptyOrderedMap();\n                        }\n                        this.__ownerID = ownerID;\n                        this._map = newMap;\n                        this._list = newList;\n                        return this;\n                    }\n                    return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n                };\n                return OrderedMap;\n            }(Map);\n            OrderedMap.isOrderedMap = isOrderedMap;\n            OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;\n            OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n            function makeOrderedMap(map, list, ownerID, hash) {\n                var omap = Object.create(OrderedMap.prototype);\n                omap.size = map ? map.size : 0;\n                omap._map = map;\n                omap._list = list;\n                omap.__ownerID = ownerID;\n                omap.__hash = hash;\n                return omap;\n            }\n            var EMPTY_ORDERED_MAP;\n            function emptyOrderedMap() {\n                return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n            }\n            function updateOrderedMap(omap, k, v) {\n                var map = omap._map;\n                var list = omap._list;\n                var i = map.get(k);\n                var has = i !== undefined;\n                var newMap;\n                var newList;\n                if (v === NOT_SET) {\n                    // removed\n                    if (!has) {\n                        return omap;\n                    }\n                    if (list.size >= SIZE && list.size >= map.size * 2) {\n                        newList = list.filter(function(entry, idx) {\n                            return entry !== undefined && i !== idx;\n                        });\n                        newMap = newList.toKeyedSeq().map(function(entry) {\n                            return entry[0];\n                        }).flip().toMap();\n                        if (omap.__ownerID) {\n                            newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n                        }\n                    } else {\n                        newMap = map.remove(k);\n                        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n                    }\n                } else if (has) {\n                    if (v === list.get(i)[1]) {\n                        return omap;\n                    }\n                    newMap = map;\n                    newList = list.set(i, [\n                        k,\n                        v\n                    ]);\n                } else {\n                    newMap = map.set(k, list.size);\n                    newList = list.set(list.size, [\n                        k,\n                        v\n                    ]);\n                }\n                if (omap.__ownerID) {\n                    omap.size = newMap.size;\n                    omap._map = newMap;\n                    omap._list = newList;\n                    omap.__hash = undefined;\n                    return omap;\n                }\n                return makeOrderedMap(newMap, newList);\n            }\n            var IS_STACK_SYMBOL = \"@@__IMMUTABLE_STACK__@@\";\n            function isStack(maybeStack) {\n                return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);\n            }\n            var Stack = /*@__PURE__*/ function(IndexedCollection$$1) {\n                function Stack(value) {\n                    return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);\n                }\n                if (IndexedCollection$$1) Stack.__proto__ = IndexedCollection$$1;\n                Stack.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);\n                Stack.prototype.constructor = Stack;\n                Stack.of = function of() {\n                    return this(arguments);\n                };\n                Stack.prototype.toString = function toString() {\n                    return this.__toString(\"Stack [\", \"]\");\n                };\n                // @pragma Access\n                Stack.prototype.get = function get(index, notSetValue) {\n                    var head = this._head;\n                    index = wrapIndex(this, index);\n                    while(head && index--){\n                        head = head.next;\n                    }\n                    return head ? head.value : notSetValue;\n                };\n                Stack.prototype.peek = function peek() {\n                    return this._head && this._head.value;\n                };\n                // @pragma Modification\n                Stack.prototype.push = function push() {\n                    var arguments$1 = arguments;\n                    if (arguments.length === 0) {\n                        return this;\n                    }\n                    var newSize = this.size + arguments.length;\n                    var head = this._head;\n                    for(var ii = arguments.length - 1; ii >= 0; ii--){\n                        head = {\n                            value: arguments$1[ii],\n                            next: head\n                        };\n                    }\n                    if (this.__ownerID) {\n                        this.size = newSize;\n                        this._head = head;\n                        this.__hash = undefined;\n                        this.__altered = true;\n                        return this;\n                    }\n                    return makeStack(newSize, head);\n                };\n                Stack.prototype.pushAll = function pushAll(iter) {\n                    iter = IndexedCollection$$1(iter);\n                    if (iter.size === 0) {\n                        return this;\n                    }\n                    if (this.size === 0 && isStack(iter)) {\n                        return iter;\n                    }\n                    assertNotInfinite(iter.size);\n                    var newSize = this.size;\n                    var head = this._head;\n                    iter.__iterate(function(value) {\n                        newSize++;\n                        head = {\n                            value: value,\n                            next: head\n                        };\n                    }, /* reverse */ true);\n                    if (this.__ownerID) {\n                        this.size = newSize;\n                        this._head = head;\n                        this.__hash = undefined;\n                        this.__altered = true;\n                        return this;\n                    }\n                    return makeStack(newSize, head);\n                };\n                Stack.prototype.pop = function pop() {\n                    return this.slice(1);\n                };\n                Stack.prototype.clear = function clear() {\n                    if (this.size === 0) {\n                        return this;\n                    }\n                    if (this.__ownerID) {\n                        this.size = 0;\n                        this._head = undefined;\n                        this.__hash = undefined;\n                        this.__altered = true;\n                        return this;\n                    }\n                    return emptyStack();\n                };\n                Stack.prototype.slice = function slice(begin, end) {\n                    if (wholeSlice(begin, end, this.size)) {\n                        return this;\n                    }\n                    var resolvedBegin = resolveBegin(begin, this.size);\n                    var resolvedEnd = resolveEnd(end, this.size);\n                    if (resolvedEnd !== this.size) {\n                        // super.slice(begin, end);\n                        return IndexedCollection$$1.prototype.slice.call(this, begin, end);\n                    }\n                    var newSize = this.size - resolvedBegin;\n                    var head = this._head;\n                    while(resolvedBegin--){\n                        head = head.next;\n                    }\n                    if (this.__ownerID) {\n                        this.size = newSize;\n                        this._head = head;\n                        this.__hash = undefined;\n                        this.__altered = true;\n                        return this;\n                    }\n                    return makeStack(newSize, head);\n                };\n                // @pragma Mutability\n                Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n                    if (ownerID === this.__ownerID) {\n                        return this;\n                    }\n                    if (!ownerID) {\n                        if (this.size === 0) {\n                            return emptyStack();\n                        }\n                        this.__ownerID = ownerID;\n                        this.__altered = false;\n                        return this;\n                    }\n                    return makeStack(this.size, this._head, ownerID, this.__hash);\n                };\n                // @pragma Iteration\n                Stack.prototype.__iterate = function __iterate(fn, reverse) {\n                    var this$1 = this;\n                    if (reverse) {\n                        return new ArraySeq(this.toArray()).__iterate(function(v, k) {\n                            return fn(v, k, this$1);\n                        }, reverse);\n                    }\n                    var iterations = 0;\n                    var node = this._head;\n                    while(node){\n                        if (fn(node.value, iterations++, this) === false) {\n                            break;\n                        }\n                        node = node.next;\n                    }\n                    return iterations;\n                };\n                Stack.prototype.__iterator = function __iterator(type, reverse) {\n                    if (reverse) {\n                        return new ArraySeq(this.toArray()).__iterator(type, reverse);\n                    }\n                    var iterations = 0;\n                    var node = this._head;\n                    return new Iterator(function() {\n                        if (node) {\n                            var value = node.value;\n                            node = node.next;\n                            return iteratorValue(type, iterations++, value);\n                        }\n                        return iteratorDone();\n                    });\n                };\n                return Stack;\n            }(IndexedCollection);\n            Stack.isStack = isStack;\n            var StackPrototype = Stack.prototype;\n            StackPrototype[IS_STACK_SYMBOL] = true;\n            StackPrototype.shift = StackPrototype.pop;\n            StackPrototype.unshift = StackPrototype.push;\n            StackPrototype.unshiftAll = StackPrototype.pushAll;\n            StackPrototype.withMutations = withMutations;\n            StackPrototype.wasAltered = wasAltered;\n            StackPrototype.asImmutable = asImmutable;\n            StackPrototype[\"@@transducer/init\"] = StackPrototype.asMutable = asMutable;\n            StackPrototype[\"@@transducer/step\"] = function(result, arr) {\n                return result.unshift(arr);\n            };\n            StackPrototype[\"@@transducer/result\"] = function(obj) {\n                return obj.asImmutable();\n            };\n            function makeStack(size, head, ownerID, hash) {\n                var map = Object.create(StackPrototype);\n                map.size = size;\n                map._head = head;\n                map.__ownerID = ownerID;\n                map.__hash = hash;\n                map.__altered = false;\n                return map;\n            }\n            var EMPTY_STACK;\n            function emptyStack() {\n                return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n            }\n            var IS_SET_SYMBOL = \"@@__IMMUTABLE_SET__@@\";\n            function isSet(maybeSet) {\n                return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);\n            }\n            function isOrderedSet(maybeOrderedSet) {\n                return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n            }\n            function deepEqual(a, b) {\n                if (a === b) {\n                    return true;\n                }\n                if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {\n                    return false;\n                }\n                if (a.size === 0 && b.size === 0) {\n                    return true;\n                }\n                var notAssociative = !isAssociative(a);\n                if (isOrdered(a)) {\n                    var entries = a.entries();\n                    return b.every(function(v, k) {\n                        var entry = entries.next().value;\n                        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n                    }) && entries.next().done;\n                }\n                var flipped = false;\n                if (a.size === undefined) {\n                    if (b.size === undefined) {\n                        if (typeof a.cacheResult === \"function\") {\n                            a.cacheResult();\n                        }\n                    } else {\n                        flipped = true;\n                        var _ = a;\n                        a = b;\n                        b = _;\n                    }\n                }\n                var allEqual = true;\n                var bSize = b.__iterate(function(v, k) {\n                    if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n                        allEqual = false;\n                        return false;\n                    }\n                });\n                return allEqual && a.size === bSize;\n            }\n            /**\n * Contributes additional methods to a constructor\n */ function mixin(ctor, methods) {\n                var keyCopier = function(key) {\n                    ctor.prototype[key] = methods[key];\n                };\n                Object.keys(methods).forEach(keyCopier);\n                Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n                return ctor;\n            }\n            function toJS(value) {\n                if (!value || typeof value !== \"object\") {\n                    return value;\n                }\n                if (!isCollection(value)) {\n                    if (!isDataStructure(value)) {\n                        return value;\n                    }\n                    value = Seq(value);\n                }\n                if (isKeyed(value)) {\n                    var result$1 = {};\n                    value.__iterate(function(v, k) {\n                        result$1[k] = toJS(v);\n                    });\n                    return result$1;\n                }\n                var result = [];\n                value.__iterate(function(v) {\n                    result.push(toJS(v));\n                });\n                return result;\n            }\n            var Set = /*@__PURE__*/ function(SetCollection$$1) {\n                function Set(value) {\n                    return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set) {\n                        var iter = SetCollection$$1(value);\n                        assertNotInfinite(iter.size);\n                        iter.forEach(function(v) {\n                            return set.add(v);\n                        });\n                    });\n                }\n                if (SetCollection$$1) Set.__proto__ = SetCollection$$1;\n                Set.prototype = Object.create(SetCollection$$1 && SetCollection$$1.prototype);\n                Set.prototype.constructor = Set;\n                Set.of = function of() {\n                    return this(arguments);\n                };\n                Set.fromKeys = function fromKeys(value) {\n                    return this(KeyedCollection(value).keySeq());\n                };\n                Set.intersect = function intersect(sets) {\n                    sets = Collection(sets).toArray();\n                    return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();\n                };\n                Set.union = function union(sets) {\n                    sets = Collection(sets).toArray();\n                    return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();\n                };\n                Set.prototype.toString = function toString() {\n                    return this.__toString(\"Set {\", \"}\");\n                };\n                // @pragma Access\n                Set.prototype.has = function has(value) {\n                    return this._map.has(value);\n                };\n                // @pragma Modification\n                Set.prototype.add = function add(value) {\n                    return updateSet(this, this._map.set(value, value));\n                };\n                Set.prototype.remove = function remove(value) {\n                    return updateSet(this, this._map.remove(value));\n                };\n                Set.prototype.clear = function clear() {\n                    return updateSet(this, this._map.clear());\n                };\n                // @pragma Composition\n                Set.prototype.map = function map(mapper, context) {\n                    var this$1 = this;\n                    var removes = [];\n                    var adds = [];\n                    this.forEach(function(value) {\n                        var mapped = mapper.call(context, value, value, this$1);\n                        if (mapped !== value) {\n                            removes.push(value);\n                            adds.push(mapped);\n                        }\n                    });\n                    return this.withMutations(function(set) {\n                        removes.forEach(function(value) {\n                            return set.remove(value);\n                        });\n                        adds.forEach(function(value) {\n                            return set.add(value);\n                        });\n                    });\n                };\n                Set.prototype.union = function union() {\n                    var iters = [], len = arguments.length;\n                    while(len--)iters[len] = arguments[len];\n                    iters = iters.filter(function(x) {\n                        return x.size !== 0;\n                    });\n                    if (iters.length === 0) {\n                        return this;\n                    }\n                    if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n                        return this.constructor(iters[0]);\n                    }\n                    return this.withMutations(function(set) {\n                        for(var ii = 0; ii < iters.length; ii++){\n                            SetCollection$$1(iters[ii]).forEach(function(value) {\n                                return set.add(value);\n                            });\n                        }\n                    });\n                };\n                Set.prototype.intersect = function intersect() {\n                    var iters = [], len = arguments.length;\n                    while(len--)iters[len] = arguments[len];\n                    if (iters.length === 0) {\n                        return this;\n                    }\n                    iters = iters.map(function(iter) {\n                        return SetCollection$$1(iter);\n                    });\n                    var toRemove = [];\n                    this.forEach(function(value) {\n                        if (!iters.every(function(iter) {\n                            return iter.includes(value);\n                        })) {\n                            toRemove.push(value);\n                        }\n                    });\n                    return this.withMutations(function(set) {\n                        toRemove.forEach(function(value) {\n                            set.remove(value);\n                        });\n                    });\n                };\n                Set.prototype.subtract = function subtract() {\n                    var iters = [], len = arguments.length;\n                    while(len--)iters[len] = arguments[len];\n                    if (iters.length === 0) {\n                        return this;\n                    }\n                    iters = iters.map(function(iter) {\n                        return SetCollection$$1(iter);\n                    });\n                    var toRemove = [];\n                    this.forEach(function(value) {\n                        if (iters.some(function(iter) {\n                            return iter.includes(value);\n                        })) {\n                            toRemove.push(value);\n                        }\n                    });\n                    return this.withMutations(function(set) {\n                        toRemove.forEach(function(value) {\n                            set.remove(value);\n                        });\n                    });\n                };\n                Set.prototype.sort = function sort(comparator) {\n                    // Late binding\n                    return OrderedSet(sortFactory(this, comparator));\n                };\n                Set.prototype.sortBy = function sortBy(mapper, comparator) {\n                    // Late binding\n                    return OrderedSet(sortFactory(this, comparator, mapper));\n                };\n                Set.prototype.wasAltered = function wasAltered() {\n                    return this._map.wasAltered();\n                };\n                Set.prototype.__iterate = function __iterate(fn, reverse) {\n                    var this$1 = this;\n                    return this._map.__iterate(function(k) {\n                        return fn(k, k, this$1);\n                    }, reverse);\n                };\n                Set.prototype.__iterator = function __iterator(type, reverse) {\n                    return this._map.__iterator(type, reverse);\n                };\n                Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n                    if (ownerID === this.__ownerID) {\n                        return this;\n                    }\n                    var newMap = this._map.__ensureOwner(ownerID);\n                    if (!ownerID) {\n                        if (this.size === 0) {\n                            return this.__empty();\n                        }\n                        this.__ownerID = ownerID;\n                        this._map = newMap;\n                        return this;\n                    }\n                    return this.__make(newMap, ownerID);\n                };\n                return Set;\n            }(SetCollection);\n            Set.isSet = isSet;\n            var SetPrototype = Set.prototype;\n            SetPrototype[IS_SET_SYMBOL] = true;\n            SetPrototype[DELETE] = SetPrototype.remove;\n            SetPrototype.merge = SetPrototype.concat = SetPrototype.union;\n            SetPrototype.withMutations = withMutations;\n            SetPrototype.asImmutable = asImmutable;\n            SetPrototype[\"@@transducer/init\"] = SetPrototype.asMutable = asMutable;\n            SetPrototype[\"@@transducer/step\"] = function(result, arr) {\n                return result.add(arr);\n            };\n            SetPrototype[\"@@transducer/result\"] = function(obj) {\n                return obj.asImmutable();\n            };\n            SetPrototype.__empty = emptySet;\n            SetPrototype.__make = makeSet;\n            function updateSet(set, newMap) {\n                if (set.__ownerID) {\n                    set.size = newMap.size;\n                    set._map = newMap;\n                    return set;\n                }\n                return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);\n            }\n            function makeSet(map, ownerID) {\n                var set = Object.create(SetPrototype);\n                set.size = map ? map.size : 0;\n                set._map = map;\n                set.__ownerID = ownerID;\n                return set;\n            }\n            var EMPTY_SET;\n            function emptySet() {\n                return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n            }\n            /**\n * Returns a lazy seq of nums from start (inclusive) to end\n * (exclusive), by step, where start defaults to 0, step to 1, and end to\n * infinity. When start is equal to end, returns empty list.\n */ var Range = /*@__PURE__*/ function(IndexedSeq$$1) {\n                function Range(start, end, step) {\n                    if (!(this instanceof Range)) {\n                        return new Range(start, end, step);\n                    }\n                    invariant(step !== 0, \"Cannot step a Range by 0\");\n                    start = start || 0;\n                    if (end === undefined) {\n                        end = Infinity;\n                    }\n                    step = step === undefined ? 1 : Math.abs(step);\n                    if (end < start) {\n                        step = -step;\n                    }\n                    this._start = start;\n                    this._end = end;\n                    this._step = step;\n                    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n                    if (this.size === 0) {\n                        if (EMPTY_RANGE) {\n                            return EMPTY_RANGE;\n                        }\n                        EMPTY_RANGE = this;\n                    }\n                }\n                if (IndexedSeq$$1) Range.__proto__ = IndexedSeq$$1;\n                Range.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n                Range.prototype.constructor = Range;\n                Range.prototype.toString = function toString() {\n                    if (this.size === 0) {\n                        return \"Range []\";\n                    }\n                    return \"Range [ \" + this._start + \"...\" + this._end + (this._step !== 1 ? \" by \" + this._step : \"\") + \" ]\";\n                };\n                Range.prototype.get = function get(index, notSetValue) {\n                    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;\n                };\n                Range.prototype.includes = function includes(searchValue) {\n                    var possibleIndex = (searchValue - this._start) / this._step;\n                    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);\n                };\n                Range.prototype.slice = function slice(begin, end) {\n                    if (wholeSlice(begin, end, this.size)) {\n                        return this;\n                    }\n                    begin = resolveBegin(begin, this.size);\n                    end = resolveEnd(end, this.size);\n                    if (end <= begin) {\n                        return new Range(0, 0);\n                    }\n                    return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n                };\n                Range.prototype.indexOf = function indexOf(searchValue) {\n                    var offsetValue = searchValue - this._start;\n                    if (offsetValue % this._step === 0) {\n                        var index = offsetValue / this._step;\n                        if (index >= 0 && index < this.size) {\n                            return index;\n                        }\n                    }\n                    return -1;\n                };\n                Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {\n                    return this.indexOf(searchValue);\n                };\n                Range.prototype.__iterate = function __iterate(fn, reverse) {\n                    var size = this.size;\n                    var step = this._step;\n                    var value = reverse ? this._start + (size - 1) * step : this._start;\n                    var i = 0;\n                    while(i !== size){\n                        if (fn(value, reverse ? size - ++i : i++, this) === false) {\n                            break;\n                        }\n                        value += reverse ? -step : step;\n                    }\n                    return i;\n                };\n                Range.prototype.__iterator = function __iterator(type, reverse) {\n                    var size = this.size;\n                    var step = this._step;\n                    var value = reverse ? this._start + (size - 1) * step : this._start;\n                    var i = 0;\n                    return new Iterator(function() {\n                        if (i === size) {\n                            return iteratorDone();\n                        }\n                        var v = value;\n                        value += reverse ? -step : step;\n                        return iteratorValue(type, reverse ? size - ++i : i++, v);\n                    });\n                };\n                Range.prototype.equals = function equals(other) {\n                    return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);\n                };\n                return Range;\n            }(IndexedSeq);\n            var EMPTY_RANGE;\n            function getIn(collection, searchKeyPath, notSetValue) {\n                var keyPath = coerceKeyPath(searchKeyPath);\n                var i = 0;\n                while(i !== keyPath.length){\n                    collection = get(collection, keyPath[i++], NOT_SET);\n                    if (collection === NOT_SET) {\n                        return notSetValue;\n                    }\n                }\n                return collection;\n            }\n            function getIn$1(searchKeyPath, notSetValue) {\n                return getIn(this, searchKeyPath, notSetValue);\n            }\n            function hasIn(collection, keyPath) {\n                return getIn(collection, keyPath, NOT_SET) !== NOT_SET;\n            }\n            function hasIn$1(searchKeyPath) {\n                return hasIn(this, searchKeyPath);\n            }\n            function toObject() {\n                assertNotInfinite(this.size);\n                var object = {};\n                this.__iterate(function(v, k) {\n                    object[k] = v;\n                });\n                return object;\n            }\n            // Note: all of these methods are deprecated.\n            Collection.isIterable = isCollection;\n            Collection.isKeyed = isKeyed;\n            Collection.isIndexed = isIndexed;\n            Collection.isAssociative = isAssociative;\n            Collection.isOrdered = isOrdered;\n            Collection.Iterator = Iterator;\n            mixin(Collection, {\n                // ### Conversion to other types\n                toArray: function toArray() {\n                    assertNotInfinite(this.size);\n                    var array = new Array(this.size || 0);\n                    var useTuples = isKeyed(this);\n                    var i = 0;\n                    this.__iterate(function(v, k) {\n                        // Keyed collections produce an array of tuples.\n                        array[i++] = useTuples ? [\n                            k,\n                            v\n                        ] : v;\n                    });\n                    return array;\n                },\n                toIndexedSeq: function toIndexedSeq() {\n                    return new ToIndexedSequence(this);\n                },\n                toJS: function toJS$1() {\n                    return toJS(this);\n                },\n                toKeyedSeq: function toKeyedSeq() {\n                    return new ToKeyedSequence(this, true);\n                },\n                toMap: function toMap() {\n                    // Use Late Binding here to solve the circular dependency.\n                    return Map(this.toKeyedSeq());\n                },\n                toObject: toObject,\n                toOrderedMap: function toOrderedMap() {\n                    // Use Late Binding here to solve the circular dependency.\n                    return OrderedMap(this.toKeyedSeq());\n                },\n                toOrderedSet: function toOrderedSet() {\n                    // Use Late Binding here to solve the circular dependency.\n                    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n                },\n                toSet: function toSet() {\n                    // Use Late Binding here to solve the circular dependency.\n                    return Set(isKeyed(this) ? this.valueSeq() : this);\n                },\n                toSetSeq: function toSetSeq() {\n                    return new ToSetSequence(this);\n                },\n                toSeq: function toSeq() {\n                    return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();\n                },\n                toStack: function toStack() {\n                    // Use Late Binding here to solve the circular dependency.\n                    return Stack(isKeyed(this) ? this.valueSeq() : this);\n                },\n                toList: function toList() {\n                    // Use Late Binding here to solve the circular dependency.\n                    return List(isKeyed(this) ? this.valueSeq() : this);\n                },\n                // ### Common JavaScript methods and properties\n                toString: function toString() {\n                    return \"[Collection]\";\n                },\n                __toString: function __toString(head, tail) {\n                    if (this.size === 0) {\n                        return head + tail;\n                    }\n                    return head + \" \" + this.toSeq().map(this.__toStringMapper).join(\", \") + \" \" + tail;\n                },\n                // ### ES6 Collection methods (ES6 Array and Map)\n                concat: function concat() {\n                    var values = [], len = arguments.length;\n                    while(len--)values[len] = arguments[len];\n                    return reify(this, concatFactory(this, values));\n                },\n                includes: function includes(searchValue) {\n                    return this.some(function(value) {\n                        return is(value, searchValue);\n                    });\n                },\n                entries: function entries() {\n                    return this.__iterator(ITERATE_ENTRIES);\n                },\n                every: function every(predicate, context) {\n                    assertNotInfinite(this.size);\n                    var returnValue = true;\n                    this.__iterate(function(v, k, c) {\n                        if (!predicate.call(context, v, k, c)) {\n                            returnValue = false;\n                            return false;\n                        }\n                    });\n                    return returnValue;\n                },\n                filter: function filter(predicate, context) {\n                    return reify(this, filterFactory(this, predicate, context, true));\n                },\n                find: function find(predicate, context, notSetValue) {\n                    var entry = this.findEntry(predicate, context);\n                    return entry ? entry[1] : notSetValue;\n                },\n                forEach: function forEach(sideEffect, context) {\n                    assertNotInfinite(this.size);\n                    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n                },\n                join: function join(separator) {\n                    assertNotInfinite(this.size);\n                    separator = separator !== undefined ? \"\" + separator : \",\";\n                    var joined = \"\";\n                    var isFirst = true;\n                    this.__iterate(function(v) {\n                        isFirst ? isFirst = false : joined += separator;\n                        joined += v !== null && v !== undefined ? v.toString() : \"\";\n                    });\n                    return joined;\n                },\n                keys: function keys() {\n                    return this.__iterator(ITERATE_KEYS);\n                },\n                map: function map(mapper, context) {\n                    return reify(this, mapFactory(this, mapper, context));\n                },\n                reduce: function reduce$1(reducer, initialReduction, context) {\n                    return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);\n                },\n                reduceRight: function reduceRight(reducer, initialReduction, context) {\n                    return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);\n                },\n                reverse: function reverse() {\n                    return reify(this, reverseFactory(this, true));\n                },\n                slice: function slice(begin, end) {\n                    return reify(this, sliceFactory(this, begin, end, true));\n                },\n                some: function some(predicate, context) {\n                    return !this.every(not(predicate), context);\n                },\n                sort: function sort(comparator) {\n                    return reify(this, sortFactory(this, comparator));\n                },\n                values: function values() {\n                    return this.__iterator(ITERATE_VALUES);\n                },\n                // ### More sequential methods\n                butLast: function butLast() {\n                    return this.slice(0, -1);\n                },\n                isEmpty: function isEmpty() {\n                    return this.size !== undefined ? this.size === 0 : !this.some(function() {\n                        return true;\n                    });\n                },\n                count: function count(predicate, context) {\n                    return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);\n                },\n                countBy: function countBy(grouper, context) {\n                    return countByFactory(this, grouper, context);\n                },\n                equals: function equals(other) {\n                    return deepEqual(this, other);\n                },\n                entrySeq: function entrySeq() {\n                    var collection = this;\n                    if (collection._cache) {\n                        // We cache as an entries array, so we can just return the cache!\n                        return new ArraySeq(collection._cache);\n                    }\n                    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n                    entriesSequence.fromEntrySeq = function() {\n                        return collection.toSeq();\n                    };\n                    return entriesSequence;\n                },\n                filterNot: function filterNot(predicate, context) {\n                    return this.filter(not(predicate), context);\n                },\n                findEntry: function findEntry(predicate, context, notSetValue) {\n                    var found = notSetValue;\n                    this.__iterate(function(v, k, c) {\n                        if (predicate.call(context, v, k, c)) {\n                            found = [\n                                k,\n                                v\n                            ];\n                            return false;\n                        }\n                    });\n                    return found;\n                },\n                findKey: function findKey(predicate, context) {\n                    var entry = this.findEntry(predicate, context);\n                    return entry && entry[0];\n                },\n                findLast: function findLast(predicate, context, notSetValue) {\n                    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n                },\n                findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n                    return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n                },\n                findLastKey: function findLastKey(predicate, context) {\n                    return this.toKeyedSeq().reverse().findKey(predicate, context);\n                },\n                first: function first(notSetValue) {\n                    return this.find(returnTrue, null, notSetValue);\n                },\n                flatMap: function flatMap(mapper, context) {\n                    return reify(this, flatMapFactory(this, mapper, context));\n                },\n                flatten: function flatten(depth) {\n                    return reify(this, flattenFactory(this, depth, true));\n                },\n                fromEntrySeq: function fromEntrySeq() {\n                    return new FromEntriesSequence(this);\n                },\n                get: function get(searchKey, notSetValue) {\n                    return this.find(function(_, key) {\n                        return is(key, searchKey);\n                    }, undefined, notSetValue);\n                },\n                getIn: getIn$1,\n                groupBy: function groupBy(grouper, context) {\n                    return groupByFactory(this, grouper, context);\n                },\n                has: function has(searchKey) {\n                    return this.get(searchKey, NOT_SET) !== NOT_SET;\n                },\n                hasIn: hasIn$1,\n                isSubset: function isSubset(iter) {\n                    iter = typeof iter.includes === \"function\" ? iter : Collection(iter);\n                    return this.every(function(value) {\n                        return iter.includes(value);\n                    });\n                },\n                isSuperset: function isSuperset(iter) {\n                    iter = typeof iter.isSubset === \"function\" ? iter : Collection(iter);\n                    return iter.isSubset(this);\n                },\n                keyOf: function keyOf(searchValue) {\n                    return this.findKey(function(value) {\n                        return is(value, searchValue);\n                    });\n                },\n                keySeq: function keySeq() {\n                    return this.toSeq().map(keyMapper).toIndexedSeq();\n                },\n                last: function last(notSetValue) {\n                    return this.toSeq().reverse().first(notSetValue);\n                },\n                lastKeyOf: function lastKeyOf(searchValue) {\n                    return this.toKeyedSeq().reverse().keyOf(searchValue);\n                },\n                max: function max(comparator) {\n                    return maxFactory(this, comparator);\n                },\n                maxBy: function maxBy(mapper, comparator) {\n                    return maxFactory(this, comparator, mapper);\n                },\n                min: function min(comparator) {\n                    return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n                },\n                minBy: function minBy(mapper, comparator) {\n                    return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n                },\n                rest: function rest() {\n                    return this.slice(1);\n                },\n                skip: function skip(amount) {\n                    return amount === 0 ? this : this.slice(Math.max(0, amount));\n                },\n                skipLast: function skipLast(amount) {\n                    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n                },\n                skipWhile: function skipWhile(predicate, context) {\n                    return reify(this, skipWhileFactory(this, predicate, context, true));\n                },\n                skipUntil: function skipUntil(predicate, context) {\n                    return this.skipWhile(not(predicate), context);\n                },\n                sortBy: function sortBy(mapper, comparator) {\n                    return reify(this, sortFactory(this, comparator, mapper));\n                },\n                take: function take(amount) {\n                    return this.slice(0, Math.max(0, amount));\n                },\n                takeLast: function takeLast(amount) {\n                    return this.slice(-Math.max(0, amount));\n                },\n                takeWhile: function takeWhile(predicate, context) {\n                    return reify(this, takeWhileFactory(this, predicate, context));\n                },\n                takeUntil: function takeUntil(predicate, context) {\n                    return this.takeWhile(not(predicate), context);\n                },\n                update: function update(fn) {\n                    return fn(this);\n                },\n                valueSeq: function valueSeq() {\n                    return this.toIndexedSeq();\n                },\n                // ### Hashable Object\n                hashCode: function hashCode() {\n                    return this.__hash || (this.__hash = hashCollection(this));\n                }\n            });\n            var CollectionPrototype = Collection.prototype;\n            CollectionPrototype[IS_COLLECTION_SYMBOL] = true;\n            CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\n            CollectionPrototype.toJSON = CollectionPrototype.toArray;\n            CollectionPrototype.__toStringMapper = quoteString;\n            CollectionPrototype.inspect = CollectionPrototype.toSource = function() {\n                return this.toString();\n            };\n            CollectionPrototype.chain = CollectionPrototype.flatMap;\n            CollectionPrototype.contains = CollectionPrototype.includes;\n            mixin(KeyedCollection, {\n                // ### More sequential methods\n                flip: function flip() {\n                    return reify(this, flipFactory(this));\n                },\n                mapEntries: function mapEntries(mapper, context) {\n                    var this$1 = this;\n                    var iterations = 0;\n                    return reify(this, this.toSeq().map(function(v, k) {\n                        return mapper.call(context, [\n                            k,\n                            v\n                        ], iterations++, this$1);\n                    }).fromEntrySeq());\n                },\n                mapKeys: function mapKeys(mapper, context) {\n                    var this$1 = this;\n                    return reify(this, this.toSeq().flip().map(function(k, v) {\n                        return mapper.call(context, k, v, this$1);\n                    }).flip());\n                }\n            });\n            var KeyedCollectionPrototype = KeyedCollection.prototype;\n            KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;\n            KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\n            KeyedCollectionPrototype.toJSON = toObject;\n            KeyedCollectionPrototype.__toStringMapper = function(v, k) {\n                return quoteString(k) + \": \" + quoteString(v);\n            };\n            mixin(IndexedCollection, {\n                // ### Conversion to other types\n                toKeyedSeq: function toKeyedSeq() {\n                    return new ToKeyedSequence(this, false);\n                },\n                // ### ES6 Collection methods (ES6 Array and Map)\n                filter: function filter(predicate, context) {\n                    return reify(this, filterFactory(this, predicate, context, false));\n                },\n                findIndex: function findIndex(predicate, context) {\n                    var entry = this.findEntry(predicate, context);\n                    return entry ? entry[0] : -1;\n                },\n                indexOf: function indexOf(searchValue) {\n                    var key = this.keyOf(searchValue);\n                    return key === undefined ? -1 : key;\n                },\n                lastIndexOf: function lastIndexOf(searchValue) {\n                    var key = this.lastKeyOf(searchValue);\n                    return key === undefined ? -1 : key;\n                },\n                reverse: function reverse() {\n                    return reify(this, reverseFactory(this, false));\n                },\n                slice: function slice(begin, end) {\n                    return reify(this, sliceFactory(this, begin, end, false));\n                },\n                splice: function splice(index, removeNum /*, ...values*/ ) {\n                    var numArgs = arguments.length;\n                    removeNum = Math.max(removeNum || 0, 0);\n                    if (numArgs === 0 || numArgs === 2 && !removeNum) {\n                        return this;\n                    }\n                    // If index is negative, it should resolve relative to the size of the\n                    // collection. However size may be expensive to compute if not cached, so\n                    // only call count() if the number is in fact negative.\n                    index = resolveBegin(index, index < 0 ? this.count() : this.size);\n                    var spliced = this.slice(0, index);\n                    return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));\n                },\n                // ### More collection methods\n                findLastIndex: function findLastIndex(predicate, context) {\n                    var entry = this.findLastEntry(predicate, context);\n                    return entry ? entry[0] : -1;\n                },\n                first: function first(notSetValue) {\n                    return this.get(0, notSetValue);\n                },\n                flatten: function flatten(depth) {\n                    return reify(this, flattenFactory(this, depth, false));\n                },\n                get: function get(index, notSetValue) {\n                    index = wrapIndex(this, index);\n                    return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function(_, key) {\n                        return key === index;\n                    }, undefined, notSetValue);\n                },\n                has: function has(index) {\n                    index = wrapIndex(this, index);\n                    return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);\n                },\n                interpose: function interpose(separator) {\n                    return reify(this, interposeFactory(this, separator));\n                },\n                interleave: function interleave() {\n                    var collections = [\n                        this\n                    ].concat(arrCopy(arguments));\n                    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n                    var interleaved = zipped.flatten(true);\n                    if (zipped.size) {\n                        interleaved.size = zipped.size * collections.length;\n                    }\n                    return reify(this, interleaved);\n                },\n                keySeq: function keySeq() {\n                    return Range(0, this.size);\n                },\n                last: function last(notSetValue) {\n                    return this.get(-1, notSetValue);\n                },\n                skipWhile: function skipWhile(predicate, context) {\n                    return reify(this, skipWhileFactory(this, predicate, context, false));\n                },\n                zip: function zip() {\n                    var collections = [\n                        this\n                    ].concat(arrCopy(arguments));\n                    return reify(this, zipWithFactory(this, defaultZipper, collections));\n                },\n                zipAll: function zipAll() {\n                    var collections = [\n                        this\n                    ].concat(arrCopy(arguments));\n                    return reify(this, zipWithFactory(this, defaultZipper, collections, true));\n                },\n                zipWith: function zipWith(zipper /*, ...collections */ ) {\n                    var collections = arrCopy(arguments);\n                    collections[0] = this;\n                    return reify(this, zipWithFactory(this, zipper, collections));\n                }\n            });\n            var IndexedCollectionPrototype = IndexedCollection.prototype;\n            IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;\n            IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;\n            mixin(SetCollection, {\n                // ### ES6 Collection methods (ES6 Array and Map)\n                get: function get(value, notSetValue) {\n                    return this.has(value) ? value : notSetValue;\n                },\n                includes: function includes(value) {\n                    return this.has(value);\n                },\n                // ### More sequential methods\n                keySeq: function keySeq() {\n                    return this.valueSeq();\n                }\n            });\n            SetCollection.prototype.has = CollectionPrototype.includes;\n            SetCollection.prototype.contains = SetCollection.prototype.includes;\n            // Mixin subclasses\n            mixin(KeyedSeq, KeyedCollection.prototype);\n            mixin(IndexedSeq, IndexedCollection.prototype);\n            mixin(SetSeq, SetCollection.prototype);\n            // #pragma Helper functions\n            function reduce(collection, reducer, reduction, context, useFirst, reverse) {\n                assertNotInfinite(collection.size);\n                collection.__iterate(function(v, k, c) {\n                    if (useFirst) {\n                        useFirst = false;\n                        reduction = v;\n                    } else {\n                        reduction = reducer.call(context, reduction, v, k, c);\n                    }\n                }, reverse);\n                return reduction;\n            }\n            function keyMapper(v, k) {\n                return k;\n            }\n            function entryMapper(v, k) {\n                return [\n                    k,\n                    v\n                ];\n            }\n            function not(predicate) {\n                return function() {\n                    return !predicate.apply(this, arguments);\n                };\n            }\n            function neg(predicate) {\n                return function() {\n                    return -predicate.apply(this, arguments);\n                };\n            }\n            function defaultZipper() {\n                return arrCopy(arguments);\n            }\n            function defaultNegComparator(a, b) {\n                return a < b ? 1 : a > b ? -1 : 0;\n            }\n            function hashCollection(collection) {\n                if (collection.size === Infinity) {\n                    return 0;\n                }\n                var ordered = isOrdered(collection);\n                var keyed = isKeyed(collection);\n                var h = ordered ? 1 : 0;\n                var size = collection.__iterate(keyed ? ordered ? function(v, k) {\n                    h = 31 * h + hashMerge(hash(v), hash(k)) | 0;\n                } : function(v, k) {\n                    h = h + hashMerge(hash(v), hash(k)) | 0;\n                } : ordered ? function(v) {\n                    h = 31 * h + hash(v) | 0;\n                } : function(v) {\n                    h = h + hash(v) | 0;\n                });\n                return murmurHashOfSize(size, h);\n            }\n            function murmurHashOfSize(size, h) {\n                h = imul(h, 0xcc9e2d51);\n                h = imul(h << 15 | h >>> -15, 0x1b873593);\n                h = imul(h << 13 | h >>> -13, 5);\n                h = (h + 0xe6546b64 | 0) ^ size;\n                h = imul(h ^ h >>> 16, 0x85ebca6b);\n                h = imul(h ^ h >>> 13, 0xc2b2ae35);\n                h = smi(h ^ h >>> 16);\n                return h;\n            }\n            function hashMerge(a, b) {\n                return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int\n            }\n            var OrderedSet = /*@__PURE__*/ function(Set$$1) {\n                function OrderedSet(value) {\n                    return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set) {\n                        var iter = SetCollection(value);\n                        assertNotInfinite(iter.size);\n                        iter.forEach(function(v) {\n                            return set.add(v);\n                        });\n                    });\n                }\n                if (Set$$1) OrderedSet.__proto__ = Set$$1;\n                OrderedSet.prototype = Object.create(Set$$1 && Set$$1.prototype);\n                OrderedSet.prototype.constructor = OrderedSet;\n                OrderedSet.of = function of() {\n                    return this(arguments);\n                };\n                OrderedSet.fromKeys = function fromKeys(value) {\n                    return this(KeyedCollection(value).keySeq());\n                };\n                OrderedSet.prototype.toString = function toString() {\n                    return this.__toString(\"OrderedSet {\", \"}\");\n                };\n                return OrderedSet;\n            }(Set);\n            OrderedSet.isOrderedSet = isOrderedSet;\n            var OrderedSetPrototype = OrderedSet.prototype;\n            OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;\n            OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\n            OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n            OrderedSetPrototype.__empty = emptyOrderedSet;\n            OrderedSetPrototype.__make = makeOrderedSet;\n            function makeOrderedSet(map, ownerID) {\n                var set = Object.create(OrderedSetPrototype);\n                set.size = map ? map.size : 0;\n                set._map = map;\n                set.__ownerID = ownerID;\n                return set;\n            }\n            var EMPTY_ORDERED_SET;\n            function emptyOrderedSet() {\n                return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n            }\n            var Record = function Record(defaultValues, name) {\n                var hasInitialized;\n                var RecordType = function Record(values) {\n                    var this$1 = this;\n                    if (values instanceof RecordType) {\n                        return values;\n                    }\n                    if (!(this instanceof RecordType)) {\n                        return new RecordType(values);\n                    }\n                    if (!hasInitialized) {\n                        hasInitialized = true;\n                        var keys = Object.keys(defaultValues);\n                        var indices = RecordTypePrototype._indices = {};\n                        // Deprecated: left to attempt not to break any external code which\n                        // relies on a ._name property existing on record instances.\n                        // Use Record.getDescriptiveName() instead\n                        RecordTypePrototype._name = name;\n                        RecordTypePrototype._keys = keys;\n                        RecordTypePrototype._defaultValues = defaultValues;\n                        for(var i = 0; i < keys.length; i++){\n                            var propName = keys[i];\n                            indices[propName] = i;\n                            if (RecordTypePrototype[propName]) {\n                                /* eslint-disable no-console */ typeof console === \"object\" && console.warn && console.warn(\"Cannot define \" + recordName(this) + ' with property \"' + propName + '\" since that property name is part of the Record API.');\n                            /* eslint-enable no-console */ } else {\n                                setProp(RecordTypePrototype, propName);\n                            }\n                        }\n                    }\n                    this.__ownerID = undefined;\n                    this._values = List().withMutations(function(l) {\n                        l.setSize(this$1._keys.length);\n                        KeyedCollection(values).forEach(function(v, k) {\n                            l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n                        });\n                    });\n                };\n                var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n                RecordTypePrototype.constructor = RecordType;\n                if (name) {\n                    RecordType.displayName = name;\n                }\n                return RecordType;\n            };\n            Record.prototype.toString = function toString() {\n                var str = recordName(this) + \" { \";\n                var keys = this._keys;\n                var k;\n                for(var i = 0, l = keys.length; i !== l; i++){\n                    k = keys[i];\n                    str += (i ? \", \" : \"\") + k + \": \" + quoteString(this.get(k));\n                }\n                return str + \" }\";\n            };\n            Record.prototype.equals = function equals(other) {\n                return this === other || other && this._keys === other._keys && recordSeq(this).equals(recordSeq(other));\n            };\n            Record.prototype.hashCode = function hashCode() {\n                return recordSeq(this).hashCode();\n            };\n            // @pragma Access\n            Record.prototype.has = function has(k) {\n                return this._indices.hasOwnProperty(k);\n            };\n            Record.prototype.get = function get(k, notSetValue) {\n                if (!this.has(k)) {\n                    return notSetValue;\n                }\n                var index = this._indices[k];\n                var value = this._values.get(index);\n                return value === undefined ? this._defaultValues[k] : value;\n            };\n            // @pragma Modification\n            Record.prototype.set = function set(k, v) {\n                if (this.has(k)) {\n                    var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);\n                    if (newValues !== this._values && !this.__ownerID) {\n                        return makeRecord(this, newValues);\n                    }\n                }\n                return this;\n            };\n            Record.prototype.remove = function remove(k) {\n                return this.set(k);\n            };\n            Record.prototype.clear = function clear() {\n                var newValues = this._values.clear().setSize(this._keys.length);\n                return this.__ownerID ? this : makeRecord(this, newValues);\n            };\n            Record.prototype.wasAltered = function wasAltered() {\n                return this._values.wasAltered();\n            };\n            Record.prototype.toSeq = function toSeq() {\n                return recordSeq(this);\n            };\n            Record.prototype.toJS = function toJS$1() {\n                return toJS(this);\n            };\n            Record.prototype.entries = function entries() {\n                return this.__iterator(ITERATE_ENTRIES);\n            };\n            Record.prototype.__iterator = function __iterator(type, reverse) {\n                return recordSeq(this).__iterator(type, reverse);\n            };\n            Record.prototype.__iterate = function __iterate(fn, reverse) {\n                return recordSeq(this).__iterate(fn, reverse);\n            };\n            Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n                if (ownerID === this.__ownerID) {\n                    return this;\n                }\n                var newValues = this._values.__ensureOwner(ownerID);\n                if (!ownerID) {\n                    this.__ownerID = ownerID;\n                    this._values = newValues;\n                    return this;\n                }\n                return makeRecord(this, newValues, ownerID);\n            };\n            Record.isRecord = isRecord;\n            Record.getDescriptiveName = recordName;\n            var RecordPrototype = Record.prototype;\n            RecordPrototype[IS_RECORD_SYMBOL] = true;\n            RecordPrototype[DELETE] = RecordPrototype.remove;\n            RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\n            RecordPrototype.getIn = getIn$1;\n            RecordPrototype.hasIn = CollectionPrototype.hasIn;\n            RecordPrototype.merge = merge;\n            RecordPrototype.mergeWith = mergeWith;\n            RecordPrototype.mergeIn = mergeIn;\n            RecordPrototype.mergeDeep = mergeDeep$1;\n            RecordPrototype.mergeDeepWith = mergeDeepWith$1;\n            RecordPrototype.mergeDeepIn = mergeDeepIn;\n            RecordPrototype.setIn = setIn$1;\n            RecordPrototype.update = update$1;\n            RecordPrototype.updateIn = updateIn$1;\n            RecordPrototype.withMutations = withMutations;\n            RecordPrototype.asMutable = asMutable;\n            RecordPrototype.asImmutable = asImmutable;\n            RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\n            RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;\n            RecordPrototype.inspect = RecordPrototype.toSource = function() {\n                return this.toString();\n            };\n            function makeRecord(likeRecord, values, ownerID) {\n                var record = Object.create(Object.getPrototypeOf(likeRecord));\n                record._values = values;\n                record.__ownerID = ownerID;\n                return record;\n            }\n            function recordName(record) {\n                return record.constructor.displayName || record.constructor.name || \"Record\";\n            }\n            function recordSeq(record) {\n                return keyedSeqFromValue(record._keys.map(function(k) {\n                    return [\n                        k,\n                        record.get(k)\n                    ];\n                }));\n            }\n            function setProp(prototype, name) {\n                try {\n                    Object.defineProperty(prototype, name, {\n                        get: function() {\n                            return this.get(name);\n                        },\n                        set: function(value) {\n                            invariant(this.__ownerID, \"Cannot set on an immutable record.\");\n                            this.set(name, value);\n                        }\n                    });\n                } catch (error) {\n                // Object.defineProperty failed. Probably IE8.\n                }\n            }\n            /**\n * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n * undefined, returns an infinite sequence of `value`.\n */ var Repeat = /*@__PURE__*/ function(IndexedSeq$$1) {\n                function Repeat(value, times) {\n                    if (!(this instanceof Repeat)) {\n                        return new Repeat(value, times);\n                    }\n                    this._value = value;\n                    this.size = times === undefined ? Infinity : Math.max(0, times);\n                    if (this.size === 0) {\n                        if (EMPTY_REPEAT) {\n                            return EMPTY_REPEAT;\n                        }\n                        EMPTY_REPEAT = this;\n                    }\n                }\n                if (IndexedSeq$$1) Repeat.__proto__ = IndexedSeq$$1;\n                Repeat.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n                Repeat.prototype.constructor = Repeat;\n                Repeat.prototype.toString = function toString() {\n                    if (this.size === 0) {\n                        return \"Repeat []\";\n                    }\n                    return \"Repeat [ \" + this._value + \" \" + this.size + \" times ]\";\n                };\n                Repeat.prototype.get = function get(index, notSetValue) {\n                    return this.has(index) ? this._value : notSetValue;\n                };\n                Repeat.prototype.includes = function includes(searchValue) {\n                    return is(this._value, searchValue);\n                };\n                Repeat.prototype.slice = function slice(begin, end) {\n                    var size = this.size;\n                    return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n                };\n                Repeat.prototype.reverse = function reverse() {\n                    return this;\n                };\n                Repeat.prototype.indexOf = function indexOf(searchValue) {\n                    if (is(this._value, searchValue)) {\n                        return 0;\n                    }\n                    return -1;\n                };\n                Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {\n                    if (is(this._value, searchValue)) {\n                        return this.size;\n                    }\n                    return -1;\n                };\n                Repeat.prototype.__iterate = function __iterate(fn, reverse) {\n                    var size = this.size;\n                    var i = 0;\n                    while(i !== size){\n                        if (fn(this._value, reverse ? size - ++i : i++, this) === false) {\n                            break;\n                        }\n                    }\n                    return i;\n                };\n                Repeat.prototype.__iterator = function __iterator(type, reverse) {\n                    var this$1 = this;\n                    var size = this.size;\n                    var i = 0;\n                    return new Iterator(function() {\n                        return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1._value);\n                    });\n                };\n                Repeat.prototype.equals = function equals(other) {\n                    return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);\n                };\n                return Repeat;\n            }(IndexedSeq);\n            var EMPTY_REPEAT;\n            function fromJS(value, converter) {\n                return fromJSWith([], converter || defaultConverter, value, \"\", converter && converter.length > 2 ? [] : undefined, {\n                    \"\": value\n                });\n            }\n            function fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n                var toSeq = Array.isArray(value) ? IndexedSeq : isPlainObj(value) ? KeyedSeq : null;\n                if (toSeq) {\n                    if (~stack.indexOf(value)) {\n                        throw new TypeError(\"Cannot convert circular structure to Immutable\");\n                    }\n                    stack.push(value);\n                    keyPath && key !== \"\" && keyPath.push(key);\n                    var converted = converter.call(parentValue, key, toSeq(value).map(function(v, k) {\n                        return fromJSWith(stack, converter, v, k, keyPath, value);\n                    }), keyPath && keyPath.slice());\n                    stack.pop();\n                    keyPath && keyPath.pop();\n                    return converted;\n                }\n                return value;\n            }\n            function defaultConverter(k, v) {\n                return isKeyed(v) ? v.toMap() : v.toList();\n            }\n            var version = \"4.0.0-rc.11\";\n            var Immutable = {\n                version: version,\n                Collection: Collection,\n                // Note: Iterable is deprecated\n                Iterable: Collection,\n                Seq: Seq,\n                Map: Map,\n                OrderedMap: OrderedMap,\n                List: List,\n                Stack: Stack,\n                Set: Set,\n                OrderedSet: OrderedSet,\n                Record: Record,\n                Range: Range,\n                Repeat: Repeat,\n                is: is,\n                fromJS: fromJS,\n                hash: hash,\n                isImmutable: isImmutable,\n                isCollection: isCollection,\n                isKeyed: isKeyed,\n                isIndexed: isIndexed,\n                isAssociative: isAssociative,\n                isOrdered: isOrdered,\n                isValueObject: isValueObject,\n                isSeq: isSeq,\n                isList: isList,\n                isMap: isMap,\n                isOrderedMap: isOrderedMap,\n                isStack: isStack,\n                isSet: isSet,\n                isOrderedSet: isOrderedSet,\n                isRecord: isRecord,\n                get: get,\n                getIn: getIn,\n                has: has,\n                hasIn: hasIn,\n                merge: merge$1,\n                mergeDeep: mergeDeep,\n                mergeWith: mergeWith$1,\n                mergeDeepWith: mergeDeepWith,\n                remove: remove,\n                removeIn: removeIn,\n                set: set,\n                setIn: setIn,\n                update: update,\n                updateIn: updateIn\n            };\n            // Note: Iterable is deprecated\n            var Iterable = Collection;\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = Immutable;\n        /***/ },\n        /***/ \"./node_modules/minimatch-capture/index.js\": /*!*************************************************!*\\\n  !*** ./node_modules/minimatch-capture/index.js ***!\n  \\*************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_268003__) {\n            \"use strict\";\n            const minimatch = __nested_webpack_require_268003__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\");\n            const splitRe = /([!?+*@]\\([^)]+\\)|\\*{1,2}|\\?)/;\n            const endWithNegRe = /!\\([^)]+\\)$/;\n            class Capture {\n                constructor(pattern, options){\n                    this.pattern = pattern;\n                    this.options = options || {};\n                }\n                makeRe() {\n                    if (!this.regexp && this.regexp !== false) {\n                        this.regexp = makeRe(this.pattern, this.options);\n                    }\n                    return this.regexp;\n                }\n                capture(path) {\n                    let result = false;\n                    let match = path.match(this.makeRe());\n                    if (match) {\n                        match = match.filter(isDef);\n                        result = match[1] || match[0];\n                        if (!this.options.notrim && result !== \"/\") {\n                            result = result.replace(/^\\/|\\/$/g, \"\");\n                        }\n                    }\n                    return result;\n                }\n            }\n            function split(pattern) {\n                const parts = pattern.split(splitRe);\n                if (parts.length === 1) {\n                    return [\n                        \"\",\n                        parts[0],\n                        \"\"\n                    ];\n                }\n                return [\n                    parts[0],\n                    parts.slice(1, -1).join(\"\"),\n                    parts[parts.length - 1]\n                ];\n            }\n            const nonegate = {\n                nonegate: true\n            };\n            function _makeRe(pattern, options) {\n                const flags = options && options.nocase ? \"i\" : \"\";\n                const subpatterns = minimatch.braceExpand(pattern, options);\n                const expressions = subpatterns.map((subpattern)=>{\n                    const parts = split(subpattern);\n                    const left = parts[0];\n                    const middle = parts[1];\n                    const right = parts[2];\n                    const opts = left ? Object.assign({}, options, nonegate) : options;\n                    const re = minimatch.makeRe(middle, opts);\n                    let capture = re.source.slice(4, -2);\n                    if (endWithNegRe.test(middle)) {\n                        capture = capture.replace(/\\)\\$\\)/g, \"(?\" + (right.startsWith(\"/\") ? \"=\" : \"!\") + \"/)))\");\n                    }\n                    return regExpEscape(left) + \"(\" + capture + \")\" + regExpEscape(right);\n                });\n                return new RegExp(\"^(?:\" + expressions.join(\"|\") + \")$\", flags);\n            }\n            function makeRe(pattern, options) {\n                try {\n                    return _makeRe(pattern, options);\n                } catch (e) {\n                    return false;\n                }\n            }\n            function match(list, pattern, options) {\n                const cap = new Capture(pattern, options);\n                const result = [];\n                for(let i = 0; i < list.length; i++){\n                    const path = list[i];\n                    const match = cap.capture(path);\n                    if (match) {\n                        result.push([\n                            path,\n                            match\n                        ]);\n                    }\n                }\n                return result;\n            }\n            module1.exports = function(path, pattern, options) {\n                return new Capture(pattern, options).capture(path);\n            };\n            Object.assign(module1.exports, {\n                Capture,\n                split,\n                makeRe,\n                match\n            });\n            function isDef(v) {\n                return v !== undefined;\n            }\n            // private function copied from https://github.com/isaacs/minimatch\n            function regExpEscape(s) {\n                return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n            }\n        /***/ },\n        /***/ \"./node_modules/minimatch/minimatch.js\": /*!*********************************************!*\\\n  !*** ./node_modules/minimatch/minimatch.js ***!\n  \\*********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_272481__) {\n            module1.exports = minimatch;\n            minimatch.Minimatch = Minimatch;\n            var path = {\n                sep: \"/\"\n            };\n            try {\n                path = __nested_webpack_require_272481__(/*! path */ \"./node_modules/path-browserify/index.js\");\n            } catch (er) {}\n            var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\n            var expand = __nested_webpack_require_272481__(/*! brace-expansion */ \"./node_modules/brace-expansion/index.js\");\n            var plTypes = {\n                \"!\": {\n                    open: \"(?:(?!(?:\",\n                    close: \"))[^/]*?)\"\n                },\n                \"?\": {\n                    open: \"(?:\",\n                    close: \")?\"\n                },\n                \"+\": {\n                    open: \"(?:\",\n                    close: \")+\"\n                },\n                \"*\": {\n                    open: \"(?:\",\n                    close: \")*\"\n                },\n                \"@\": {\n                    open: \"(?:\",\n                    close: \")\"\n                }\n            };\n            // any single thing other than /\n            // don't need to escape / when using new RegExp()\n            var qmark = \"[^/]\";\n            // * => any number of characters\n            var star = qmark + \"*?\";\n            // ** when dots are allowed.  Anything goes, except .. and .\n            // not (^ or / followed by one or two dots followed by $ or /),\n            // followed by anything, any number of times.\n            var twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n            // not a ^ or / followed by a dot,\n            // followed by anything, any number of times.\n            var twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\n            // characters that need to be escaped in RegExp.\n            var reSpecials = charSet(\"().*{}+?[]^$\\\\!\");\n            // \"abc\" -> { a:true, b:true, c:true }\n            function charSet(s) {\n                return s.split(\"\").reduce(function(set, c) {\n                    set[c] = true;\n                    return set;\n                }, {});\n            }\n            // normalizes slashes.\n            var slashSplit = /\\/+/;\n            minimatch.filter = filter;\n            function filter(pattern, options) {\n                options = options || {};\n                return function(p, i, list) {\n                    return minimatch(p, pattern, options);\n                };\n            }\n            function ext(a, b) {\n                a = a || {};\n                b = b || {};\n                var t = {};\n                Object.keys(b).forEach(function(k) {\n                    t[k] = b[k];\n                });\n                Object.keys(a).forEach(function(k) {\n                    t[k] = a[k];\n                });\n                return t;\n            }\n            minimatch.defaults = function(def) {\n                if (!def || !Object.keys(def).length) return minimatch;\n                var orig = minimatch;\n                var m = function minimatch(p, pattern, options) {\n                    return orig.minimatch(p, pattern, ext(def, options));\n                };\n                m.Minimatch = function Minimatch(pattern, options) {\n                    return new orig.Minimatch(pattern, ext(def, options));\n                };\n                return m;\n            };\n            Minimatch.defaults = function(def) {\n                if (!def || !Object.keys(def).length) return Minimatch;\n                return minimatch.defaults(def).Minimatch;\n            };\n            function minimatch(p, pattern, options) {\n                if (typeof pattern !== \"string\") {\n                    throw new TypeError(\"glob pattern string required\");\n                }\n                if (!options) options = {};\n                // shortcut: comments match nothing.\n                if (!options.nocomment && pattern.charAt(0) === \"#\") {\n                    return false;\n                }\n                // \"\" only matches \"\"\n                if (pattern.trim() === \"\") return p === \"\";\n                return new Minimatch(pattern, options).match(p);\n            }\n            function Minimatch(pattern, options) {\n                if (!(this instanceof Minimatch)) {\n                    return new Minimatch(pattern, options);\n                }\n                if (typeof pattern !== \"string\") {\n                    throw new TypeError(\"glob pattern string required\");\n                }\n                if (!options) options = {};\n                pattern = pattern.trim();\n                // windows support: need to use /, not \\\n                if (path.sep !== \"/\") {\n                    pattern = pattern.split(path.sep).join(\"/\");\n                }\n                this.options = options;\n                this.set = [];\n                this.pattern = pattern;\n                this.regexp = null;\n                this.negate = false;\n                this.comment = false;\n                this.empty = false;\n                // make the set of regexps etc.\n                this.make();\n            }\n            Minimatch.prototype.debug = function() {};\n            Minimatch.prototype.make = make;\n            function make() {\n                // don't do it more than once.\n                if (this._made) return;\n                var pattern = this.pattern;\n                var options = this.options;\n                // empty patterns and comments match nothing.\n                if (!options.nocomment && pattern.charAt(0) === \"#\") {\n                    this.comment = true;\n                    return;\n                }\n                if (!pattern) {\n                    this.empty = true;\n                    return;\n                }\n                // step 1: figure out negation, etc.\n                this.parseNegate();\n                // step 2: expand braces\n                var set = this.globSet = this.braceExpand();\n                if (options.debug) this.debug = console.error;\n                this.debug(this.pattern, set);\n                // step 3: now we have a set, so turn each one into a series of path-portion\n                // matching patterns.\n                // These will be regexps, except in the case of \"**\", which is\n                // set to the GLOBSTAR object for globstar behavior,\n                // and will not contain any / characters\n                set = this.globParts = set.map(function(s) {\n                    return s.split(slashSplit);\n                });\n                this.debug(this.pattern, set);\n                // glob --> regexps\n                set = set.map(function(s, si, set) {\n                    return s.map(this.parse, this);\n                }, this);\n                this.debug(this.pattern, set);\n                // filter out everything that didn't compile properly.\n                set = set.filter(function(s) {\n                    return s.indexOf(false) === -1;\n                });\n                this.debug(this.pattern, set);\n                this.set = set;\n            }\n            Minimatch.prototype.parseNegate = parseNegate;\n            function parseNegate() {\n                var pattern = this.pattern;\n                var negate = false;\n                var options = this.options;\n                var negateOffset = 0;\n                if (options.nonegate) return;\n                for(var i = 0, l = pattern.length; i < l && pattern.charAt(i) === \"!\"; i++){\n                    negate = !negate;\n                    negateOffset++;\n                }\n                if (negateOffset) this.pattern = pattern.substr(negateOffset);\n                this.negate = negate;\n            }\n            // Brace expansion:\n            // a{b,c}d -> abd acd\n            // a{b,}c -> abc ac\n            // a{0..3}d -> a0d a1d a2d a3d\n            // a{b,c{d,e}f}g -> abg acdfg acefg\n            // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n            //\n            // Invalid sets are not expanded.\n            // a{2..}b -> a{2..}b\n            // a{b}c -> a{b}c\n            minimatch.braceExpand = function(pattern, options) {\n                return braceExpand(pattern, options);\n            };\n            Minimatch.prototype.braceExpand = braceExpand;\n            function braceExpand(pattern, options) {\n                if (!options) {\n                    if (this instanceof Minimatch) {\n                        options = this.options;\n                    } else {\n                        options = {};\n                    }\n                }\n                pattern = typeof pattern === \"undefined\" ? this.pattern : pattern;\n                if (typeof pattern === \"undefined\") {\n                    throw new TypeError(\"undefined pattern\");\n                }\n                if (options.nobrace || !pattern.match(/\\{.*\\}/)) {\n                    // shortcut. no need to expand.\n                    return [\n                        pattern\n                    ];\n                }\n                return expand(pattern);\n            }\n            // parse a component of the expanded set.\n            // At this point, no pattern may contain \"/\" in it\n            // so we're going to return a 2d array, where each entry is the full\n            // pattern, split on '/', and then turned into a regular expression.\n            // A regexp is made at the end which joins each array with an\n            // escaped /, and another full one which joins each regexp with |.\n            //\n            // Following the lead of Bash 4.1, note that \"**\" only has special meaning\n            // when it is the *only* thing in a path portion.  Otherwise, any series\n            // of * is equivalent to a single *.  Globstar behavior is enabled by\n            // default, and can be disabled by setting options.noglobstar.\n            Minimatch.prototype.parse = parse;\n            var SUBPARSE = {};\n            function parse(pattern, isSub) {\n                if (pattern.length > 1024 * 64) {\n                    throw new TypeError(\"pattern is too long\");\n                }\n                var options = this.options;\n                // shortcuts\n                if (!options.noglobstar && pattern === \"**\") return GLOBSTAR;\n                if (pattern === \"\") return \"\";\n                var re = \"\";\n                var hasMagic = !!options.nocase;\n                var escaping = false;\n                // ? => one single character\n                var patternListStack = [];\n                var negativeLists = [];\n                var stateChar;\n                var inClass = false;\n                var reClassStart = -1;\n                var classStart = -1;\n                // . and .. never match anything that doesn't start with .,\n                // even when options.dot is set.\n                var patternStart = pattern.charAt(0) === \".\" ? \"\" // anything\n                 : options.dot ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n                var self = this;\n                function clearStateChar() {\n                    if (stateChar) {\n                        // we had some state-tracking character\n                        // that wasn't consumed by this pass.\n                        switch(stateChar){\n                            case \"*\":\n                                re += star;\n                                hasMagic = true;\n                                break;\n                            case \"?\":\n                                re += qmark;\n                                hasMagic = true;\n                                break;\n                            default:\n                                re += \"\\\\\" + stateChar;\n                                break;\n                        }\n                        self.debug(\"clearStateChar %j %j\", stateChar, re);\n                        stateChar = false;\n                    }\n                }\n                for(var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++){\n                    this.debug(\"%s\t%s %s %j\", pattern, i, re, c);\n                    // skip over any that are escaped.\n                    if (escaping && reSpecials[c]) {\n                        re += \"\\\\\" + c;\n                        escaping = false;\n                        continue;\n                    }\n                    switch(c){\n                        case \"/\":\n                            // completely not allowed, even escaped.\n                            // Should already be path-split by now.\n                            return false;\n                        case \"\\\\\":\n                            clearStateChar();\n                            escaping = true;\n                            continue;\n                        // the various stateChar values\n                        // for the \"extglob\" stuff.\n                        case \"?\":\n                        case \"*\":\n                        case \"+\":\n                        case \"@\":\n                        case \"!\":\n                            this.debug(\"%s\t%s %s %j <-- stateChar\", pattern, i, re, c);\n                            // all of those are literals inside a class, except that\n                            // the glob [!a] means [^a] in regexp\n                            if (inClass) {\n                                this.debug(\"  in class\");\n                                if (c === \"!\" && i === classStart + 1) c = \"^\";\n                                re += c;\n                                continue;\n                            }\n                            // if we already have a stateChar, then it means\n                            // that there was something like ** or +? in there.\n                            // Handle the stateChar, then proceed with this one.\n                            self.debug(\"call clearStateChar %j\", stateChar);\n                            clearStateChar();\n                            stateChar = c;\n                            // if extglob is disabled, then +(asdf|foo) isn't a thing.\n                            // just clear the statechar *now*, rather than even diving into\n                            // the patternList stuff.\n                            if (options.noext) clearStateChar();\n                            continue;\n                        case \"(\":\n                            if (inClass) {\n                                re += \"(\";\n                                continue;\n                            }\n                            if (!stateChar) {\n                                re += \"\\\\(\";\n                                continue;\n                            }\n                            patternListStack.push({\n                                type: stateChar,\n                                start: i - 1,\n                                reStart: re.length,\n                                open: plTypes[stateChar].open,\n                                close: plTypes[stateChar].close\n                            });\n                            // negation is (?:(?!js)[^/]*)\n                            re += stateChar === \"!\" ? \"(?:(?!(?:\" : \"(?:\";\n                            this.debug(\"plType %j %j\", stateChar, re);\n                            stateChar = false;\n                            continue;\n                        case \")\":\n                            if (inClass || !patternListStack.length) {\n                                re += \"\\\\)\";\n                                continue;\n                            }\n                            clearStateChar();\n                            hasMagic = true;\n                            var pl = patternListStack.pop();\n                            // negation is (?:(?!js)[^/]*)\n                            // The others are (?:<pattern>)<type>\n                            re += pl.close;\n                            if (pl.type === \"!\") {\n                                negativeLists.push(pl);\n                            }\n                            pl.reEnd = re.length;\n                            continue;\n                        case \"|\":\n                            if (inClass || !patternListStack.length || escaping) {\n                                re += \"\\\\|\";\n                                escaping = false;\n                                continue;\n                            }\n                            clearStateChar();\n                            re += \"|\";\n                            continue;\n                        // these are mostly the same in regexp and glob\n                        case \"[\":\n                            // swallow any state-tracking char before the [\n                            clearStateChar();\n                            if (inClass) {\n                                re += \"\\\\\" + c;\n                                continue;\n                            }\n                            inClass = true;\n                            classStart = i;\n                            reClassStart = re.length;\n                            re += c;\n                            continue;\n                        case \"]\":\n                            //  a right bracket shall lose its special\n                            //  meaning and represent itself in\n                            //  a bracket expression if it occurs\n                            //  first in the list.  -- POSIX.2 2.8.3.2\n                            if (i === classStart + 1 || !inClass) {\n                                re += \"\\\\\" + c;\n                                escaping = false;\n                                continue;\n                            }\n                            // handle the case where we left a class open.\n                            // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n                            if (inClass) {\n                                // split where the last [ was, make sure we don't have\n                                // an invalid re. if so, re-walk the contents of the\n                                // would-be class to re-translate any characters that\n                                // were passed through as-is\n                                // TODO: It would probably be faster to determine this\n                                // without a try/catch and a new RegExp, but it's tricky\n                                // to do safely.  For now, this is safe and works.\n                                var cs = pattern.substring(classStart + 1, i);\n                                try {\n                                    RegExp(\"[\" + cs + \"]\");\n                                } catch (er) {\n                                    // not a valid class!\n                                    var sp = this.parse(cs, SUBPARSE);\n                                    re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0] + \"\\\\]\";\n                                    hasMagic = hasMagic || sp[1];\n                                    inClass = false;\n                                    continue;\n                                }\n                            }\n                            // finish up the class.\n                            hasMagic = true;\n                            inClass = false;\n                            re += c;\n                            continue;\n                        default:\n                            // swallow any state char that wasn't consumed\n                            clearStateChar();\n                            if (escaping) {\n                                // no need\n                                escaping = false;\n                            } else if (reSpecials[c] && !(c === \"^\" && inClass)) {\n                                re += \"\\\\\";\n                            }\n                            re += c;\n                    } // switch\n                } // for\n                // handle the case where we left a class open.\n                // \"[abc\" is valid, equivalent to \"\\[abc\"\n                if (inClass) {\n                    // split where the last [ was, and escape it\n                    // this is a huge pita.  We now have to re-walk\n                    // the contents of the would-be class to re-translate\n                    // any characters that were passed through as-is\n                    cs = pattern.substr(classStart + 1);\n                    sp = this.parse(cs, SUBPARSE);\n                    re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0];\n                    hasMagic = hasMagic || sp[1];\n                }\n                // handle the case where we had a +( thing at the *end*\n                // of the pattern.\n                // each pattern list stack adds 3 chars, and we need to go through\n                // and escape any | chars that were passed through as-is for the regexp.\n                // Go through and escape them, taking care not to double-escape any\n                // | chars that were already escaped.\n                for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){\n                    var tail = re.slice(pl.reStart + pl.open.length);\n                    this.debug(\"setting tail\", re, pl);\n                    // maybe some even number of \\, then maybe 1 \\, followed by a |\n                    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function(_, $1, $2) {\n                        if (!$2) {\n                            // the | isn't already escaped, so escape it.\n                            $2 = \"\\\\\";\n                        }\n                        // need to escape all those slashes *again*, without escaping the\n                        // one that we need for escaping the | character.  As it works out,\n                        // escaping an even number of slashes can be done by simply repeating\n                        // it exactly after itself.  That's why this trick works.\n                        //\n                        // I am sorry that you have to see this.\n                        return $1 + $1 + $2 + \"|\";\n                    });\n                    this.debug(\"tail=%j\\n   %s\", tail, tail, pl, re);\n                    var t = pl.type === \"*\" ? star : pl.type === \"?\" ? qmark : \"\\\\\" + pl.type;\n                    hasMagic = true;\n                    re = re.slice(0, pl.reStart) + t + \"\\\\(\" + tail;\n                }\n                // handle trailing things that only matter at the very end.\n                clearStateChar();\n                if (escaping) {\n                    // trailing \\\\\n                    re += \"\\\\\\\\\";\n                }\n                // only need to apply the nodot start if the re starts with\n                // something that could conceivably capture a dot\n                var addPatternStart = false;\n                switch(re.charAt(0)){\n                    case \".\":\n                    case \"[\":\n                    case \"(\":\n                        addPatternStart = true;\n                }\n                // Hack to work around lack of negative lookbehind in JS\n                // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n                // like 'a.xyz.yz' doesn't match.  So, the first negative\n                // lookahead, has to look ALL the way ahead, to the end of\n                // the pattern.\n                for(var n = negativeLists.length - 1; n > -1; n--){\n                    var nl = negativeLists[n];\n                    var nlBefore = re.slice(0, nl.reStart);\n                    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n                    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);\n                    var nlAfter = re.slice(nl.reEnd);\n                    nlLast += nlAfter;\n                    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n                    // mean that we should *not* include the ) in the bit that is considered\n                    // \"after\" the negated section.\n                    var openParensBefore = nlBefore.split(\"(\").length - 1;\n                    var cleanAfter = nlAfter;\n                    for(i = 0; i < openParensBefore; i++){\n                        cleanAfter = cleanAfter.replace(/\\)[+*?]?/, \"\");\n                    }\n                    nlAfter = cleanAfter;\n                    var dollar = \"\";\n                    if (nlAfter === \"\" && isSub !== SUBPARSE) {\n                        dollar = \"$\";\n                    }\n                    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n                    re = newRe;\n                }\n                // if the re is not \"\" at this point, then we need to make sure\n                // it doesn't match against an empty path part.\n                // Otherwise a/* will match a/, which it should not.\n                if (re !== \"\" && hasMagic) {\n                    re = \"(?=.)\" + re;\n                }\n                if (addPatternStart) {\n                    re = patternStart + re;\n                }\n                // parsing just a piece of a larger pattern.\n                if (isSub === SUBPARSE) {\n                    return [\n                        re,\n                        hasMagic\n                    ];\n                }\n                // skip the regexp for non-magical patterns\n                // unescape anything in it, though, so that it'll be\n                // an exact match against a file etc.\n                if (!hasMagic) {\n                    return globUnescape(pattern);\n                }\n                var flags = options.nocase ? \"i\" : \"\";\n                try {\n                    var regExp = new RegExp(\"^\" + re + \"$\", flags);\n                } catch (er) {\n                    // If it was an invalid regular expression, then it can't match\n                    // anything.  This trick looks for a character after the end of\n                    // the string, which is of course impossible, except in multi-line\n                    // mode, but it's not a /m regex.\n                    return new RegExp(\"$.\");\n                }\n                regExp._glob = pattern;\n                regExp._src = re;\n                return regExp;\n            }\n            minimatch.makeRe = function(pattern, options) {\n                return new Minimatch(pattern, options || {}).makeRe();\n            };\n            Minimatch.prototype.makeRe = makeRe;\n            function makeRe() {\n                if (this.regexp || this.regexp === false) return this.regexp;\n                // at this point, this.set is a 2d array of partial\n                // pattern strings, or \"**\".\n                //\n                // It's better to use .match().  This function shouldn't\n                // be used, really, but it's pretty convenient sometimes,\n                // when you just want to work with a regex.\n                var set = this.set;\n                if (!set.length) {\n                    this.regexp = false;\n                    return this.regexp;\n                }\n                var options = this.options;\n                var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n                var flags = options.nocase ? \"i\" : \"\";\n                var re = set.map(function(pattern) {\n                    return pattern.map(function(p) {\n                        return p === GLOBSTAR ? twoStar : typeof p === \"string\" ? regExpEscape(p) : p._src;\n                    }).join(\"\\\\/\");\n                }).join(\"|\");\n                // must match entire pattern\n                // ending in a * or ** will make it less strict.\n                re = \"^(?:\" + re + \")$\";\n                // can match anything, as long as it's not this.\n                if (this.negate) re = \"^(?!\" + re + \").*$\";\n                try {\n                    this.regexp = new RegExp(re, flags);\n                } catch (ex) {\n                    this.regexp = false;\n                }\n                return this.regexp;\n            }\n            minimatch.match = function(list, pattern, options) {\n                options = options || {};\n                var mm = new Minimatch(pattern, options);\n                list = list.filter(function(f) {\n                    return mm.match(f);\n                });\n                if (mm.options.nonull && !list.length) {\n                    list.push(pattern);\n                }\n                return list;\n            };\n            Minimatch.prototype.match = match;\n            function match(f, partial) {\n                this.debug(\"match\", f, this.pattern);\n                // short-circuit in the case of busted things.\n                // comments, etc.\n                if (this.comment) return false;\n                if (this.empty) return f === \"\";\n                if (f === \"/\" && partial) return true;\n                var options = this.options;\n                // windows: need to use /, not \\\n                if (path.sep !== \"/\") {\n                    f = f.split(path.sep).join(\"/\");\n                }\n                // treat the test path as a set of pathparts.\n                f = f.split(slashSplit);\n                this.debug(this.pattern, \"split\", f);\n                // just ONE of the pattern sets in this.set needs to match\n                // in order for it to be valid.  If negating, then just one\n                // match means that we have failed.\n                // Either way, return on the first hit.\n                var set = this.set;\n                this.debug(this.pattern, \"set\", set);\n                // Find the basename of the path by looking for the last non-empty segment\n                var filename;\n                var i;\n                for(i = f.length - 1; i >= 0; i--){\n                    filename = f[i];\n                    if (filename) break;\n                }\n                for(i = 0; i < set.length; i++){\n                    var pattern = set[i];\n                    var file = f;\n                    if (options.matchBase && pattern.length === 1) {\n                        file = [\n                            filename\n                        ];\n                    }\n                    var hit = this.matchOne(file, pattern, partial);\n                    if (hit) {\n                        if (options.flipNegate) return true;\n                        return !this.negate;\n                    }\n                }\n                // didn't get any hits.  this is success if it's a negative\n                // pattern, failure otherwise.\n                if (options.flipNegate) return false;\n                return this.negate;\n            }\n            // set partial to true to test if, for example,\n            // \"/a/b\" matches the start of \"/*/b/*/d\"\n            // Partial means, if you run out of file before you run\n            // out of pattern, then that's fine, as long as all\n            // the parts match.\n            Minimatch.prototype.matchOne = function(file, pattern, partial) {\n                var options = this.options;\n                this.debug(\"matchOne\", {\n                    \"this\": this,\n                    file: file,\n                    pattern: pattern\n                });\n                this.debug(\"matchOne\", file.length, pattern.length);\n                for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){\n                    this.debug(\"matchOne loop\");\n                    var p = pattern[pi];\n                    var f = file[fi];\n                    this.debug(pattern, p, f);\n                    // should be impossible.\n                    // some invalid regexp stuff in the set.\n                    if (p === false) return false;\n                    if (p === GLOBSTAR) {\n                        this.debug(\"GLOBSTAR\", [\n                            pattern,\n                            p,\n                            f\n                        ]);\n                        // \"**\"\n                        // a/**/b/**/c would match the following:\n                        // a/b/x/y/z/c\n                        // a/x/y/z/b/c\n                        // a/b/x/b/x/c\n                        // a/b/c\n                        // To do this, take the rest of the pattern after\n                        // the **, and see if it would match the file remainder.\n                        // If so, return success.\n                        // If not, the ** \"swallows\" a segment, and try again.\n                        // This is recursively awful.\n                        //\n                        // a/**/b/**/c matching a/b/x/y/z/c\n                        // - a matches a\n                        // - doublestar\n                        //   - matchOne(b/x/y/z/c, b/**/c)\n                        //     - b matches b\n                        //     - doublestar\n                        //       - matchOne(x/y/z/c, c) -> no\n                        //       - matchOne(y/z/c, c) -> no\n                        //       - matchOne(z/c, c) -> no\n                        //       - matchOne(c, c) yes, hit\n                        var fr = fi;\n                        var pr = pi + 1;\n                        if (pr === pl) {\n                            this.debug(\"** at the end\");\n                            // a ** at the end will just swallow the rest.\n                            // We have found a match.\n                            // however, it will not swallow /.x, unless\n                            // options.dot is set.\n                            // . and .. are *never* matched by **, for explosively\n                            // exponential reasons.\n                            for(; fi < fl; fi++){\n                                if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n                            }\n                            return true;\n                        }\n                        // ok, let's see if we can swallow whatever we can.\n                        while(fr < fl){\n                            var swallowee = file[fr];\n                            this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);\n                            // XXX remove this slice.  Just pass the start index.\n                            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                                this.debug(\"globstar found match!\", fr, fl, swallowee);\n                                // found a match.\n                                return true;\n                            } else {\n                                // can't swallow \".\" or \"..\" ever.\n                                // can only swallow \".foo\" when explicitly asked.\n                                if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n                                    this.debug(\"dot detected!\", file, fr, pattern, pr);\n                                    break;\n                                }\n                                // ** swallows a segment, and continue.\n                                this.debug(\"globstar swallow a segment, and continue\");\n                                fr++;\n                            }\n                        }\n                        // no match was found.\n                        // However, in partial mode, we can't say this is necessarily over.\n                        // If there's more *pattern* left, then\n                        if (partial) {\n                            // ran out of file\n                            this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n                            if (fr === fl) return true;\n                        }\n                        return false;\n                    }\n                    // something other than **\n                    // non-magic patterns just have to match exactly\n                    // patterns with magic have been turned into regexps.\n                    var hit;\n                    if (typeof p === \"string\") {\n                        if (options.nocase) {\n                            hit = f.toLowerCase() === p.toLowerCase();\n                        } else {\n                            hit = f === p;\n                        }\n                        this.debug(\"string match\", p, f, hit);\n                    } else {\n                        hit = f.match(p);\n                        this.debug(\"pattern match\", p, f, hit);\n                    }\n                    if (!hit) return false;\n                }\n                // Note: ending in / means that we'll get a final \"\"\n                // at the end of the pattern.  This can only match a\n                // corresponding \"\" at the end of the file.\n                // If the file ends in /, then it can only match a\n                // a pattern that ends in /, unless the pattern just\n                // doesn't have any more for it. But, a/b/ should *not*\n                // match \"a/b/*\", even though \"\" matches against the\n                // [^/]*? pattern, except in partial mode, where it might\n                // simply not be reached yet.\n                // However, a/b/ should still satisfy a/*\n                // now either we fell off the end of the pattern, or we're done.\n                if (fi === fl && pi === pl) {\n                    // ran out of pattern and filename at the same time.\n                    // an exact hit!\n                    return true;\n                } else if (fi === fl) {\n                    // ran out of file, but still had pattern left.\n                    // this is ok if we're doing the match as part of\n                    // a glob fs traversal.\n                    return partial;\n                } else if (pi === pl) {\n                    // ran out of pattern, still have file left.\n                    // this is only acceptable if we're on the very last\n                    // empty segment of a file with a trailing slash.\n                    // a/* should match a/b/\n                    var emptyFileEnd = fi === fl - 1 && file[fi] === \"\";\n                    return emptyFileEnd;\n                }\n                // should be unreachable.\n                throw new Error(\"wtf?\");\n            };\n            // replace stuff like \\* with *\n            function globUnescape(s) {\n                return s.replace(/\\\\(.)/g, \"$1\");\n            }\n            function regExpEscape(s) {\n                return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n            }\n        /***/ },\n        /***/ \"./node_modules/path-browserify/index.js\": /*!***********************************************!*\\\n  !*** ./node_modules/path-browserify/index.js ***!\n  \\***********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_311062__) {\n            /* WEBPACK VAR INJECTION */ (function(process) {\n                // backported and transplited with Babel, with backwards-compat fixes\n                // Copyright Joyent, Inc. and other Node contributors.\n                //\n                // Permission is hereby granted, free of charge, to any person obtaining a\n                // copy of this software and associated documentation files (the\n                // \"Software\"), to deal in the Software without restriction, including\n                // without limitation the rights to use, copy, modify, merge, publish,\n                // distribute, sublicense, and/or sell copies of the Software, and to permit\n                // persons to whom the Software is furnished to do so, subject to the\n                // following conditions:\n                //\n                // The above copyright notice and this permission notice shall be included\n                // in all copies or substantial portions of the Software.\n                //\n                // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n                // USE OR OTHER DEALINGS IN THE SOFTWARE.\n                // resolves . and .. elements in a path array with directory names there\n                // must be no slashes, empty elements, or device names (c:\\) in the array\n                // (so also no leading and trailing slashes - it does not distinguish\n                // relative and absolute paths)\n                function normalizeArray(parts, allowAboveRoot) {\n                    // if the path tries to go above the root, `up` ends up > 0\n                    var up = 0;\n                    for(var i = parts.length - 1; i >= 0; i--){\n                        var last = parts[i];\n                        if (last === \".\") {\n                            parts.splice(i, 1);\n                        } else if (last === \"..\") {\n                            parts.splice(i, 1);\n                            up++;\n                        } else if (up) {\n                            parts.splice(i, 1);\n                            up--;\n                        }\n                    }\n                    // if the path is allowed to go above the root, restore leading ..s\n                    if (allowAboveRoot) {\n                        for(; up--; up){\n                            parts.unshift(\"..\");\n                        }\n                    }\n                    return parts;\n                }\n                // path.resolve([from ...], to)\n                // posix version\n                exports1.resolve = function() {\n                    var resolvedPath = \"\", resolvedAbsolute = false;\n                    for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){\n                        var path = i >= 0 ? arguments[i] : process.cwd();\n                        // Skip empty and invalid entries\n                        if (typeof path !== \"string\") {\n                            throw new TypeError(\"Arguments to path.resolve must be strings\");\n                        } else if (!path) {\n                            continue;\n                        }\n                        resolvedPath = path + \"/\" + resolvedPath;\n                        resolvedAbsolute = path.charAt(0) === \"/\";\n                    }\n                    // At this point the path should be resolved to a full absolute path, but\n                    // handle relative paths to be safe (might happen when process.cwd() fails)\n                    // Normalize the path\n                    resolvedPath = normalizeArray(filter(resolvedPath.split(\"/\"), function(p) {\n                        return !!p;\n                    }), !resolvedAbsolute).join(\"/\");\n                    return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n                };\n                // path.normalize(path)\n                // posix version\n                exports1.normalize = function(path) {\n                    var isAbsolute = exports1.isAbsolute(path), trailingSlash = substr(path, -1) === \"/\";\n                    // Normalize the path\n                    path = normalizeArray(filter(path.split(\"/\"), function(p) {\n                        return !!p;\n                    }), !isAbsolute).join(\"/\");\n                    if (!path && !isAbsolute) {\n                        path = \".\";\n                    }\n                    if (path && trailingSlash) {\n                        path += \"/\";\n                    }\n                    return (isAbsolute ? \"/\" : \"\") + path;\n                };\n                // posix version\n                exports1.isAbsolute = function(path) {\n                    return path.charAt(0) === \"/\";\n                };\n                // posix version\n                exports1.join = function() {\n                    var paths = Array.prototype.slice.call(arguments, 0);\n                    return exports1.normalize(filter(paths, function(p, index) {\n                        if (typeof p !== \"string\") {\n                            throw new TypeError(\"Arguments to path.join must be strings\");\n                        }\n                        return p;\n                    }).join(\"/\"));\n                };\n                // path.relative(from, to)\n                // posix version\n                exports1.relative = function(from, to) {\n                    from = exports1.resolve(from).substr(1);\n                    to = exports1.resolve(to).substr(1);\n                    function trim(arr) {\n                        var start = 0;\n                        for(; start < arr.length; start++){\n                            if (arr[start] !== \"\") break;\n                        }\n                        var end = arr.length - 1;\n                        for(; end >= 0; end--){\n                            if (arr[end] !== \"\") break;\n                        }\n                        if (start > end) return [];\n                        return arr.slice(start, end - start + 1);\n                    }\n                    var fromParts = trim(from.split(\"/\"));\n                    var toParts = trim(to.split(\"/\"));\n                    var length = Math.min(fromParts.length, toParts.length);\n                    var samePartsLength = length;\n                    for(var i = 0; i < length; i++){\n                        if (fromParts[i] !== toParts[i]) {\n                            samePartsLength = i;\n                            break;\n                        }\n                    }\n                    var outputParts = [];\n                    for(var i = samePartsLength; i < fromParts.length; i++){\n                        outputParts.push(\"..\");\n                    }\n                    outputParts = outputParts.concat(toParts.slice(samePartsLength));\n                    return outputParts.join(\"/\");\n                };\n                exports1.sep = \"/\";\n                exports1.delimiter = \":\";\n                exports1.dirname = function(path) {\n                    if (typeof path !== \"string\") path = path + \"\";\n                    if (path.length === 0) return \".\";\n                    var code = path.charCodeAt(0);\n                    var hasRoot = code === 47 /*/*/ ;\n                    var end = -1;\n                    var matchedSlash = true;\n                    for(var i = path.length - 1; i >= 1; --i){\n                        code = path.charCodeAt(i);\n                        if (code === 47 /*/*/ ) {\n                            if (!matchedSlash) {\n                                end = i;\n                                break;\n                            }\n                        } else {\n                            // We saw the first non-path separator\n                            matchedSlash = false;\n                        }\n                    }\n                    if (end === -1) return hasRoot ? \"/\" : \".\";\n                    if (hasRoot && end === 1) {\n                        // return '//';\n                        // Backwards-compat fix:\n                        return \"/\";\n                    }\n                    return path.slice(0, end);\n                };\n                function basename(path) {\n                    if (typeof path !== \"string\") path = path + \"\";\n                    var start = 0;\n                    var end = -1;\n                    var matchedSlash = true;\n                    var i;\n                    for(i = path.length - 1; i >= 0; --i){\n                        if (path.charCodeAt(i) === 47 /*/*/ ) {\n                            // If we reached a path separator that was not part of a set of path\n                            // separators at the end of the string, stop now\n                            if (!matchedSlash) {\n                                start = i + 1;\n                                break;\n                            }\n                        } else if (end === -1) {\n                            // We saw the first non-path separator, mark this as the end of our\n                            // path component\n                            matchedSlash = false;\n                            end = i + 1;\n                        }\n                    }\n                    if (end === -1) return \"\";\n                    return path.slice(start, end);\n                }\n                // Uses a mixed approach for backwards-compatibility, as ext behavior changed\n                // in new Node.js versions, so only basename() above is backported here\n                exports1.basename = function(path, ext) {\n                    var f = basename(path);\n                    if (ext && f.substr(-1 * ext.length) === ext) {\n                        f = f.substr(0, f.length - ext.length);\n                    }\n                    return f;\n                };\n                exports1.extname = function(path) {\n                    if (typeof path !== \"string\") path = path + \"\";\n                    var startDot = -1;\n                    var startPart = 0;\n                    var end = -1;\n                    var matchedSlash = true;\n                    // Track the state of characters (if any) we see before our first dot and\n                    // after any path separator we find\n                    var preDotState = 0;\n                    for(var i = path.length - 1; i >= 0; --i){\n                        var code = path.charCodeAt(i);\n                        if (code === 47 /*/*/ ) {\n                            // If we reached a path separator that was not part of a set of path\n                            // separators at the end of the string, stop now\n                            if (!matchedSlash) {\n                                startPart = i + 1;\n                                break;\n                            }\n                            continue;\n                        }\n                        if (end === -1) {\n                            // We saw the first non-path separator, mark this as the end of our\n                            // extension\n                            matchedSlash = false;\n                            end = i + 1;\n                        }\n                        if (code === 46 /*.*/ ) {\n                            // If this is our first dot, mark it as the start of our extension\n                            if (startDot === -1) startDot = i;\n                            else if (preDotState !== 1) preDotState = 1;\n                        } else if (startDot !== -1) {\n                            // We saw a non-dot and non-path separator before our dot, so we should\n                            // have a good chance at having a non-empty extension\n                            preDotState = -1;\n                        }\n                    }\n                    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n                    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n                    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n                        return \"\";\n                    }\n                    return path.slice(startDot, end);\n                };\n                function filter(xs, f) {\n                    if (xs.filter) return xs.filter(f);\n                    var res = [];\n                    for(var i = 0; i < xs.length; i++){\n                        if (f(xs[i], i, xs)) res.push(xs[i]);\n                    }\n                    return res;\n                }\n                // String.prototype.substr - negative index don't work in IE8\n                var substr =  true ? function(str, start, len) {\n                    return str.substr(start, len);\n                } : 0;\n            /* WEBPACK VAR INJECTION */ }).call(this, __nested_webpack_require_311062__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\"));\n        /***/ },\n        /***/ \"./node_modules/process/browser.js\": /*!*****************************************!*\\\n  !*** ./node_modules/process/browser.js ***!\n  \\*****************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            // shim for using process in browser\n            var process = module1.exports = {};\n            // cached from whatever global is present so that test runners that stub it\n            // don't break things.  But we need to wrap it in a try catch in case it is\n            // wrapped in strict mode code which doesn't define any globals.  It's inside a\n            // function because try/catches deoptimize in certain engines.\n            var cachedSetTimeout;\n            var cachedClearTimeout;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        cachedSetTimeout = setTimeout;\n                    } else {\n                        cachedSetTimeout = defaultSetTimout;\n                    }\n                } catch (e) {\n                    cachedSetTimeout = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        cachedClearTimeout = clearTimeout;\n                    } else {\n                        cachedClearTimeout = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    cachedClearTimeout = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(fun) {\n                if (cachedSetTimeout === setTimeout) {\n                    //normal enviroments in sane situations\n                    return setTimeout(fun, 0);\n                }\n                // if setTimeout wasn't available but was latter defined\n                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n                    cachedSetTimeout = setTimeout;\n                    return setTimeout(fun, 0);\n                }\n                try {\n                    // when when somebody has screwed with setTimeout but no I.E. maddness\n                    return cachedSetTimeout(fun, 0);\n                } catch (e) {\n                    try {\n                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n                        return cachedSetTimeout.call(null, fun, 0);\n                    } catch (e) {\n                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n                        return cachedSetTimeout.call(this, fun, 0);\n                    }\n                }\n            }\n            function runClearTimeout(marker) {\n                if (cachedClearTimeout === clearTimeout) {\n                    //normal enviroments in sane situations\n                    return clearTimeout(marker);\n                }\n                // if clearTimeout wasn't available but was latter defined\n                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n                    cachedClearTimeout = clearTimeout;\n                    return clearTimeout(marker);\n                }\n                try {\n                    // when when somebody has screwed with setTimeout but no I.E. maddness\n                    return cachedClearTimeout(marker);\n                } catch (e) {\n                    try {\n                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n                        return cachedClearTimeout.call(null, marker);\n                    } catch (e) {\n                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n                        return cachedClearTimeout.call(this, marker);\n                    }\n                }\n            }\n            var queue = [];\n            var draining = false;\n            var currentQueue;\n            var queueIndex = -1;\n            function cleanUpNextTick() {\n                if (!draining || !currentQueue) {\n                    return;\n                }\n                draining = false;\n                if (currentQueue.length) {\n                    queue = currentQueue.concat(queue);\n                } else {\n                    queueIndex = -1;\n                }\n                if (queue.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (draining) {\n                    return;\n                }\n                var timeout = runTimeout(cleanUpNextTick);\n                draining = true;\n                var len = queue.length;\n                while(len){\n                    currentQueue = queue;\n                    queue = [];\n                    while(++queueIndex < len){\n                        if (currentQueue) {\n                            currentQueue[queueIndex].run();\n                        }\n                    }\n                    queueIndex = -1;\n                    len = queue.length;\n                }\n                currentQueue = null;\n                draining = false;\n                runClearTimeout(timeout);\n            }\n            process.nextTick = function(fun) {\n                var args = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var i = 1; i < arguments.length; i++){\n                        args[i - 1] = arguments[i];\n                    }\n                }\n                queue.push(new Item(fun, args));\n                if (queue.length === 1 && !draining) {\n                    runTimeout(drainQueue);\n                }\n            };\n            // v8 likes predictible objects\n            function Item(fun, array) {\n                this.fun = fun;\n                this.array = array;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            process.title = \"browser\";\n            process.browser = true;\n            process.env = {};\n            process.argv = [];\n            process.version = \"\"; // empty string to avoid regexp issues\n            process.versions = {};\n            function noop() {}\n            process.on = noop;\n            process.addListener = noop;\n            process.once = noop;\n            process.off = noop;\n            process.removeListener = noop;\n            process.removeAllListeners = noop;\n            process.emit = noop;\n            process.prependListener = noop;\n            process.prependOnceListener = noop;\n            process.listeners = function(name) {\n                return [];\n            };\n            process.binding = function(name) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            process.cwd = function() {\n                return \"/\";\n            };\n            process.chdir = function(dir) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            process.umask = function() {\n                return 0;\n            };\n        /***/ },\n        /***/ \"./src/commands sync recursive ^\\\\.\\\\/.*$\": /*!************************************!*\\\n  !*** ./src/commands sync ^\\.\\/.*$ ***!\n  \\************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_332544__) {\n            var map = {\n                \"./\": \"./src/commands/index.js\",\n                \"./cat\": \"./src/commands/cat.js\",\n                \"./cat.js\": \"./src/commands/cat.js\",\n                \"./cd\": \"./src/commands/cd.js\",\n                \"./cd.js\": \"./src/commands/cd.js\",\n                \"./clear\": \"./src/commands/clear.js\",\n                \"./clear.js\": \"./src/commands/clear.js\",\n                \"./cp\": \"./src/commands/cp.js\",\n                \"./cp.js\": \"./src/commands/cp.js\",\n                \"./echo\": \"./src/commands/echo.js\",\n                \"./echo.js\": \"./src/commands/echo.js\",\n                \"./head\": \"./src/commands/head.js\",\n                \"./head.js\": \"./src/commands/head.js\",\n                \"./history\": \"./src/commands/history.js\",\n                \"./history.js\": \"./src/commands/history.js\",\n                \"./index\": \"./src/commands/index.js\",\n                \"./index.js\": \"./src/commands/index.js\",\n                \"./ls\": \"./src/commands/ls.js\",\n                \"./ls.js\": \"./src/commands/ls.js\",\n                \"./mkdir\": \"./src/commands/mkdir.js\",\n                \"./mkdir.js\": \"./src/commands/mkdir.js\",\n                \"./printenv\": \"./src/commands/printenv.js\",\n                \"./printenv.js\": \"./src/commands/printenv.js\",\n                \"./pwd\": \"./src/commands/pwd.js\",\n                \"./pwd.js\": \"./src/commands/pwd.js\",\n                \"./rm\": \"./src/commands/rm.js\",\n                \"./rm.js\": \"./src/commands/rm.js\",\n                \"./rmdir\": \"./src/commands/rmdir.js\",\n                \"./rmdir.js\": \"./src/commands/rmdir.js\",\n                \"./tail\": \"./src/commands/tail.js\",\n                \"./tail.js\": \"./src/commands/tail.js\",\n                \"./touch\": \"./src/commands/touch.js\",\n                \"./touch.js\": \"./src/commands/touch.js\",\n                \"./util/_head_tail_util\": \"./src/commands/util/_head_tail_util.js\",\n                \"./util/_head_tail_util.js\": \"./src/commands/util/_head_tail_util.js\",\n                \"./whoami\": \"./src/commands/whoami.js\",\n                \"./whoami.js\": \"./src/commands/whoami.js\"\n            };\n            function webpackContext(req) {\n                var id = webpackContextResolve(req);\n                return __nested_webpack_require_332544__(id);\n            }\n            function webpackContextResolve(req) {\n                if (!__nested_webpack_require_332544__.o(map, req)) {\n                    var e = new Error(\"Cannot find module '\" + req + \"'\");\n                    e.code = \"MODULE_NOT_FOUND\";\n                    throw e;\n                }\n                return map[req];\n            }\n            webpackContext.keys = function webpackContextKeys() {\n                return Object.keys(map);\n            };\n            webpackContext.resolve = webpackContextResolve;\n            module1.exports = webpackContext;\n            webpackContext.id = \"./src/commands sync recursive ^\\\\.\\\\/.*$\";\n        /***/ },\n        /***/ \"./src/commands/cat.js\": /*!*****************************!*\\\n  !*** ./src/commands/cat.js ***!\n  \\*****************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_335671__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_335671__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var FileOp = _interopRequireWildcard(__nested_webpack_require_335671__(/*! fs/operations-with-permissions/file-operations */ \"./src/fs/operations-with-permissions/file-operations.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_335671__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _util = __nested_webpack_require_335671__(/*! emulator-state/util */ \"./src/emulator-state/util.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Combines one or more files to display in the terminal output\n * Usage: cat file1.txt file2.txt\n */ var fileToTextOutput = function fileToTextOutput(fs, filePath) {\n                var _FileOp$readFile = FileOp.readFile(fs, filePath), err = _FileOp$readFile.err, file = _FileOp$readFile.file;\n                if (err) {\n                    return OutputFactory.makeErrorOutput(err);\n                }\n                ;\n                return OutputFactory.makeTextOutput(file.get(\"content\"));\n            };\n            var optDef = {};\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), argv = _parseOptions.argv;\n                if (argv.length === 0) {\n                    return {};\n                }\n                var filePaths = argv.map(function(pathArg) {\n                    return (0, _util.resolvePath)(state, pathArg);\n                });\n                return {\n                    outputs: filePaths.map(function(path) {\n                        return fileToTextOutput(state.getFileSystem(), path);\n                    })\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/cd.js\": /*!****************************!*\\\n  !*** ./src/commands/cd.js ***!\n  \\****************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_340422__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_340422__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var DirectoryOp = _interopRequireWildcard(__nested_webpack_require_340422__(/*! fs/operations-with-permissions/directory-operations */ \"./src/fs/operations-with-permissions/directory-operations.js\"));\n            var EnvVariableUtil = _interopRequireWildcard(__nested_webpack_require_340422__(/*! emulator-state/environment-variables */ \"./src/emulator-state/environment-variables.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_340422__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _fsError = __nested_webpack_require_340422__(/*! fs/fs-error */ \"./src/fs/fs-error.js\");\n            var _util = __nested_webpack_require_340422__(/*! emulator-state/util */ \"./src/emulator-state/util.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Changes the current working directory to another directory\n * Usage: cd /newDirectory\n */ var updateStateCwd = function updateStateCwd(state, newCwdPath) {\n                return EnvVariableUtil.setEnvironmentVariable(state.getEnvVariables(), \"cwd\", newCwdPath);\n            };\n            var optDef = {};\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), argv = _parseOptions.argv;\n                var newCwdPath = argv[0] ? (0, _util.resolvePath)(state, argv[0]) : \"/\";\n                if (!DirectoryOp.hasDirectory(state.getFileSystem(), newCwdPath)) {\n                    var newCwdPathDoesNotExistErr = (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_DIRECTORY);\n                    return {\n                        output: OutputFactory.makeErrorOutput(newCwdPathDoesNotExistErr)\n                    };\n                }\n                return {\n                    state: state.setEnvVariables(updateStateCwd(state, newCwdPath))\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/clear.js\": /*!*******************************!*\\\n  !*** ./src/commands/clear.js ***!\n  \\*******************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_345369__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _outputs = __nested_webpack_require_345369__(/*! emulator-state/outputs */ \"./src/emulator-state/outputs.js\");\n            /**\n * Removes all terminal output\n * Usage: clear\n */ var optDef = {};\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                return {\n                    state: state.setOutputs((0, _outputs.create)())\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/cp.js\": /*!****************************!*\\\n  !*** ./src/commands/cp.js ***!\n  \\****************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_346279__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_346279__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var FileOp = _interopRequireWildcard(__nested_webpack_require_346279__(/*! fs/operations-with-permissions/file-operations */ \"./src/fs/operations-with-permissions/file-operations.js\"));\n            var DirectoryOp = _interopRequireWildcard(__nested_webpack_require_346279__(/*! fs/operations-with-permissions/directory-operations */ \"./src/fs/operations-with-permissions/directory-operations.js\"));\n            var PathUtil = _interopRequireWildcard(__nested_webpack_require_346279__(/*! fs/util/path-util */ \"./src/fs/util/path-util.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_346279__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var FileUtil = _interopRequireWildcard(__nested_webpack_require_346279__(/*! fs/util/file-util */ \"./src/fs/util/file-util.js\"));\n            var _fsError = __nested_webpack_require_346279__(/*! fs/fs-error */ \"./src/fs/fs-error.js\");\n            var _util = __nested_webpack_require_346279__(/*! emulator-state/util */ \"./src/emulator-state/util.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Copies a file/directory to another file/directory\n * Usage: cp file new-file\n */ /**\n * Copy from a source file into a directory or another file.\n *\n * A trailing slash / can be used in the destination to explicitly state the\n * destination is a directory and not a file.\n * @param  {Map}     state              emulator state\n * @param  {string}  srcPath            source file path\n * @param  {string}  destPath           destination file or destination directory path\n * @param  {Boolean} isTrailingPathDest true if the destPath ended in a /\n * @return {object}                     cp command return object\n */ var copySourceFile = function copySourceFile(state, srcPath, destPath, isTrailingPathDest) {\n                var fs = state.getFileSystem();\n                if (isTrailingPathDest && !DirectoryOp.hasDirectory(fs, destPath)) {\n                    var dirAtTrailingPathNonExistentErr = (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_DIRECTORY);\n                    return {\n                        output: OutputFactory.makeErrorOutput(dirAtTrailingPathNonExistentErr)\n                    };\n                }\n                var _FileOp$copyFile = FileOp.copyFile(fs, srcPath, destPath), copiedFS = _FileOp$copyFile.fs, err = _FileOp$copyFile.err;\n                if (err) {\n                    return {\n                        output: OutputFactory.makeErrorOutput(err)\n                    };\n                }\n                return {\n                    state: state.setFileSystem(copiedFS)\n                };\n            };\n            /**\n * Copies a directory into another directory\n *\n * When the destination path exists, cp copies the source FOLDER into the\n * destination.\n *\n * When the destination DOES NOT exist, cp copies the source FILES into the\n * destination.\n * @param  {Map}    state      emulator state\n * @param  {string} srcPath    source directory path (copy from)\n * @param  {string} destPath   destination directory path (copy to)\n * @return {object}            cp command return object\n */ var copySourceDirectory = function copySourceDirectory(state, srcPath, destPath) {\n                if (DirectoryOp.hasDirectory(state.getFileSystem(), destPath)) {\n                    var lastPathComponent = PathUtil.getLastPathPart(srcPath); // Remap dest to copy source FOLDER, as destination path exists\n                    if (lastPathComponent !== \"/\") {\n                        destPath = \"\".concat(destPath, \"/\").concat(lastPathComponent);\n                    }\n                } // Make directory to copy into, if it doesn't already exist\n                if (!DirectoryOp.hasDirectory(state.getFileSystem(), destPath)) {\n                    var emptyDir = FileUtil.makeDirectory();\n                    var _DirectoryOp$addDirec = DirectoryOp.addDirectory(state.getFileSystem(), destPath, emptyDir, false), _fs = _DirectoryOp$addDirec.fs, _err = _DirectoryOp$addDirec.err;\n                    state = state.setFileSystem(_fs);\n                    if (_err) {\n                        return {\n                            output: OutputFactory.makeErrorOutput(_err)\n                        };\n                    }\n                }\n                var _DirectoryOp$copyDire = DirectoryOp.copyDirectory(state.getFileSystem(), srcPath, destPath), fs = _DirectoryOp$copyDire.fs, err = _DirectoryOp$copyDire.err;\n                if (err) {\n                    return {\n                        output: OutputFactory.makeErrorOutput(err)\n                    };\n                }\n                return {\n                    state: state.setFileSystem(fs)\n                };\n            };\n            var optDef = {\n                \"-r, --recursive\": \"\" // required to copy directories\n            };\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), argv = _parseOptions.argv, options = _parseOptions.options;\n                if (argv.length < 2) {\n                    return {};\n                }\n                var srcPath = (0, _util.resolvePath)(state, argv[0]);\n                var destPath = (0, _util.resolvePath)(state, argv[1]);\n                var isTrailingDestPath = PathUtil.isTrailingPath(argv[1]);\n                if (srcPath === destPath) {\n                    return {\n                        output: OutputFactory.makeTextOutput(\"Source and destination are the same (not copied).\")\n                    };\n                }\n                if (options.recursive) {\n                    return copySourceDirectory(state, srcPath, destPath);\n                }\n                return copySourceFile(state, srcPath, destPath, isTrailingDestPath);\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/echo.js\": /*!******************************!*\\\n  !*** ./src/commands/echo.js ***!\n  \\******************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_355124__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_355124__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _environmentVariables = __nested_webpack_require_355124__(/*! emulator-state/environment-variables */ \"./src/emulator-state/environment-variables.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            /**\n * Prints arguments to text output\n * Usage: echo 'hello world'\n */ var VARIABLE_GROUP_REGEX = /\\$(\\w+)/g;\n            var DOUBLE_SPACE_REGEX = /\\s\\s+/g;\n            var substituteEnvVariables = function substituteEnvVariables(environmentVariables, inputStr) {\n                return inputStr.replace(VARIABLE_GROUP_REGEX, function(match, varName) {\n                    return (0, _environmentVariables.getEnvironmentVariable)(environmentVariables, varName) || \"\";\n                });\n            };\n            var optDef = {};\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var input = commandOptions.join(\" \");\n                var outputStr = substituteEnvVariables(state.getEnvVariables(), input);\n                var cleanStr = outputStr.trim().replace(DOUBLE_SPACE_REGEX, \" \");\n                return {\n                    output: OutputFactory.makeTextOutput(cleanStr)\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/head.js\": /*!******************************!*\\\n  !*** ./src/commands/head.js ***!\n  \\******************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_359201__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_359201__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_359201__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _head_tail_util = __nested_webpack_require_359201__(/*! commands/util/_head_tail_util.js */ \"./src/commands/util/_head_tail_util.js\");\n            var _util = __nested_webpack_require_359201__(/*! emulator-state/util */ \"./src/emulator-state/util.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Prints the first n lines of a file\n * Usage: head -n 5 file.txt\n */ var optDef = {\n                \"-n, --lines\": \"<count>\"\n            };\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), argv = _parseOptions.argv, options = _parseOptions.options;\n                if (argv.length === 0) {\n                    return {};\n                }\n                var filePath = (0, _util.resolvePath)(state, argv[0]);\n                var headTrimmingFn = function headTrimmingFn(lines, lineCount) {\n                    return lines.slice(0, lineCount);\n                };\n                var _trimFileContent = (0, _head_tail_util.trimFileContent)(state.getFileSystem(), filePath, options, headTrimmingFn), content = _trimFileContent.content, err = _trimFileContent.err;\n                if (err) {\n                    return {\n                        output: OutputFactory.makeErrorOutput(err)\n                    };\n                }\n                return {\n                    output: OutputFactory.makeTextOutput(content)\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/history.js\": /*!*********************************!*\\\n  !*** ./src/commands/history.js ***!\n  \\*********************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_363906__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_363906__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_363906__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _history = __nested_webpack_require_363906__(/*! emulator-state/history */ \"./src/emulator-state/history.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Lists or clears commands executed in the terminal\n * Usage: history -c\n */ var clearStateHistory = function clearStateHistory(state) {\n                return state.setHistory((0, _history.create)());\n            };\n            var stringifyStateHistory = function stringifyStateHistory(state) {\n                return state.getHistory().join(\"\\n\");\n            };\n            var optDef = {\n                \"-c, --clear\": \"\" // remove history entries\n            };\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), options = _parseOptions.options;\n                if (options.clear) {\n                    return {\n                        state: clearStateHistory(state)\n                    };\n                }\n                ;\n                return {\n                    output: OutputFactory.makeTextOutput(stringifyStateHistory(state))\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/index.js\": /*!*******************************!*\\\n  !*** ./src/commands/index.js ***!\n  \\*******************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_368299__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.commandNames = void 0;\n            function ownKeys(object, enumerableOnly) {\n                var keys = Object.keys(object);\n                if (Object.getOwnPropertySymbols) {\n                    var symbols = Object.getOwnPropertySymbols(object);\n                    if (enumerableOnly) symbols = symbols.filter(function(sym) {\n                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n                    });\n                    keys.push.apply(keys, symbols);\n                }\n                return keys;\n            }\n            function _objectSpread(target) {\n                for(var i = 1; i < arguments.length; i++){\n                    var source = arguments[i] != null ? arguments[i] : {};\n                    if (i % 2) {\n                        ownKeys(Object(source), true).forEach(function(key) {\n                            _defineProperty(target, key, source[key]);\n                        });\n                    } else if (Object.getOwnPropertyDescriptors) {\n                        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n                    } else {\n                        ownKeys(Object(source)).forEach(function(key) {\n                            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n                        });\n                    }\n                }\n                return target;\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            var commandNames = [\n                \"cat\",\n                \"cd\",\n                \"clear\",\n                \"cp\",\n                \"echo\",\n                \"head\",\n                \"history\",\n                \"ls\",\n                \"mkdir\",\n                \"printenv\",\n                \"pwd\",\n                \"rm\",\n                \"rmdir\",\n                \"tail\",\n                \"touch\",\n                \"whoami\"\n            ];\n            exports1.commandNames = commandNames;\n            var _default = commandNames.reduce(function(mapping, commandName) {\n                return _objectSpread({}, mapping, _defineProperty({}, commandName, {\n                    \"function\": __nested_webpack_require_368299__(\"./src/commands sync recursive ^\\\\.\\\\/.*$\")(\"./\".concat(commandName))[\"default\"],\n                    optDef: __nested_webpack_require_368299__(\"./src/commands sync recursive ^\\\\.\\\\/.*$\")(\"./\".concat(commandName)).optDef\n                }));\n            }, {});\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/ls.js\": /*!****************************!*\\\n  !*** ./src/commands/ls.js ***!\n  \\****************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_371598__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_371598__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var DirectoryOp = _interopRequireWildcard(__nested_webpack_require_371598__(/*! fs/operations-with-permissions/directory-operations */ \"./src/fs/operations-with-permissions/directory-operations.js\"));\n            var EnvVariableUtil = _interopRequireWildcard(__nested_webpack_require_371598__(/*! emulator-state/environment-variables */ \"./src/emulator-state/environment-variables.js\"));\n            var PathUtil = _interopRequireWildcard(__nested_webpack_require_371598__(/*! fs/util/path-util */ \"./src/fs/util/path-util.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_371598__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _immutable = __nested_webpack_require_371598__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Lists the contents of a directory\n * Usage: ls /folderName\n */ var IMPLIED_DIRECTORY_ENTRIES = (0, _immutable.Seq)([\n                \".\",\n                \"..\"\n            ]); // . = listed folder, .. = parent folder\n            /**\n * Finds the directory path to list entries in.\n *\n * If ls has an argument passed in (example: ls /home/user/directory-to-list),\n * use the first argument as the directory to list.\n *\n * If ls is used without any path arguments (example: ls), the cwd (current\n * working directory) should be listed by ls.\n * @param  {Map}    envVariables  environment variables\n * @param  {array}  argv          argument vector\n * @return {string}               directory path to list\n */ var resolveDirectoryToList = function resolveDirectoryToList(envVariables, argv) {\n                var cwd = EnvVariableUtil.getEnvironmentVariable(envVariables, \"cwd\");\n                if (argv.length > 0) {\n                    return PathUtil.toAbsolutePath(argv[0], cwd);\n                }\n                return cwd;\n            };\n            /**\n * Alphabetically sorts the ls listing for display to the user\n * @param  {array}  listing list of files/directories to present to the user\n * @return {object}         return object of ls\n */ var makeSortedReturn = function makeSortedReturn(listing) {\n                var sortedListing = listing.sort();\n                return {\n                    output: OutputFactory.makeTextOutput(sortedListing.join(\" \"))\n                };\n            };\n            var removeHiddenFilesFilter = function removeHiddenFilesFilter(record) {\n                return !record.startsWith(\".\");\n            };\n            var optDef = {\n                \"-a, --all\": \"\",\n                // Include hidden directory entries starting with .\n                \"-A, --almost-all\": \"\" // Do not include . and .. as implied directory entries\n            };\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), options = _parseOptions.options, argv = _parseOptions.argv;\n                var dirPath = resolveDirectoryToList(state.getEnvVariables(), argv);\n                var _DirectoryOp$listDire = DirectoryOp.listDirectory(state.getFileSystem(), dirPath), err = _DirectoryOp$listDire.err, dirList = _DirectoryOp$listDire.list;\n                if (err) {\n                    return {\n                        output: OutputFactory.makeErrorOutput(err)\n                    };\n                }\n                if (options.all) {\n                    return makeSortedReturn(IMPLIED_DIRECTORY_ENTRIES.concat(dirList));\n                } else if (options.almostAll) {\n                    return makeSortedReturn(dirList);\n                }\n                return makeSortedReturn(dirList.filter(removeHiddenFilesFilter));\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/mkdir.js\": /*!*******************************!*\\\n  !*** ./src/commands/mkdir.js ***!\n  \\*******************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_378380__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_378380__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var DirOp = _interopRequireWildcard(__nested_webpack_require_378380__(/*! fs/operations-with-permissions/directory-operations */ \"./src/fs/operations-with-permissions/directory-operations.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_378380__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var FileUtil = _interopRequireWildcard(__nested_webpack_require_378380__(/*! fs/util/file-util */ \"./src/fs/util/file-util.js\"));\n            var _util = __nested_webpack_require_378380__(/*! emulator-state/util */ \"./src/emulator-state/util.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Creates an empty directory\n * Usage: mkdir /newDir\n */ var EMPTY_DIR = FileUtil.makeDirectory();\n            var optDef = {};\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), argv = _parseOptions.argv;\n                if (argv.length === 0) {\n                    return {}; // do nothing if no arguments are given\n                }\n                var newFolderPath = (0, _util.resolvePath)(state, argv[0]);\n                var _DirOp$addDirectory = DirOp.addDirectory(state.getFileSystem(), newFolderPath, EMPTY_DIR, false), fs = _DirOp$addDirectory.fs, err = _DirOp$addDirectory.err;\n                if (err) {\n                    return {\n                        output: OutputFactory.makeErrorOutput(err)\n                    };\n                }\n                return {\n                    state: state.setFileSystem(fs)\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/printenv.js\": /*!**********************************!*\\\n  !*** ./src/commands/printenv.js ***!\n  \\**********************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_383082__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_383082__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_383082__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _environmentVariables = __nested_webpack_require_383082__(/*! emulator-state/environment-variables */ \"./src/emulator-state/environment-variables.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(n);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            // Converts all key-value pairs of the environment variables to a printable format\n            var stringifyEnvVariables = function stringifyEnvVariables(envVariables) {\n                var outputs = envVariables.reduce(function(outputs, varVal, varKey) {\n                    return [].concat(_toConsumableArray(outputs), [\n                        \"\".concat(varKey, \"=\").concat(varVal)\n                    ]);\n                }, []);\n                return outputs.join(\"\\n\");\n            };\n            var optDef = {};\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), argv = _parseOptions.argv;\n                var envVariables = state.getEnvVariables();\n                if (argv.length === 0) {\n                    return {\n                        output: OutputFactory.makeTextOutput(stringifyEnvVariables(envVariables))\n                    };\n                } // An argument has been passed to printenv; printenv will only print the first\n                // argument provided\n                var varValue = (0, _environmentVariables.getEnvironmentVariable)(envVariables, argv[0]);\n                if (varValue) {\n                    return {\n                        output: OutputFactory.makeTextOutput(varValue)\n                    };\n                }\n                return {};\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/pwd.js\": /*!*****************************!*\\\n  !*** ./src/commands/pwd.js ***!\n  \\*****************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_389483__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_389483__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _environmentVariables = __nested_webpack_require_389483__(/*! emulator-state/environment-variables */ \"./src/emulator-state/environment-variables.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            /**\n * Prints out the current working directory (cwd).\n * Usage: pwd\n */ var optDef = {};\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                return {\n                    output: OutputFactory.makeTextOutput((0, _environmentVariables.getEnvironmentVariable)(state.getEnvVariables(), \"cwd\"))\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/rm.js\": /*!****************************!*\\\n  !*** ./src/commands/rm.js ***!\n  \\****************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_392958__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_392958__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var FileOp = _interopRequireWildcard(__nested_webpack_require_392958__(/*! fs/operations-with-permissions/file-operations */ \"./src/fs/operations-with-permissions/file-operations.js\"));\n            var DirOp = _interopRequireWildcard(__nested_webpack_require_392958__(/*! fs/operations-with-permissions/directory-operations */ \"./src/fs/operations-with-permissions/directory-operations.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_392958__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _util = __nested_webpack_require_392958__(/*! emulator-state/util */ \"./src/emulator-state/util.js\");\n            var _fsError = __nested_webpack_require_392958__(/*! fs/fs-error */ \"./src/fs/fs-error.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Removes a directory or a file\n * Usage: rm /existingDir\n */ var optDef = {\n                \"--no-preserve-root, --noPreserveRoot\": \"\",\n                \"-r, --recursive\": \"\"\n            };\n            exports1.optDef = optDef;\n            var makeNoPathErrorOutput = function makeNoPathErrorOutput() {\n                var noSuchFileOrDirError = (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_FILE_OR_DIRECTORY);\n                return {\n                    output: OutputFactory.makeErrorOutput(noSuchFileOrDirError)\n                };\n            };\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), argv = _parseOptions.argv, options = _parseOptions.options;\n                if (argv.length === 0) {\n                    return {}; // do nothing if no arguments are given\n                }\n                var deletionPath = (0, _util.resolvePath)(state, argv[0]);\n                var fs = state.getFileSystem();\n                if (deletionPath === \"/\" && options.noPreserveRoot !== true) {\n                    return {}; // do nothing as cannot safely delete the root\n                }\n                if (!fs.has(deletionPath)) {\n                    return makeNoPathErrorOutput();\n                }\n                var _ref = options.recursive === true ? DirOp.deleteDirectory(fs, deletionPath, true) : FileOp.deleteFile(fs, deletionPath), deletedPathFS = _ref.fs, err = _ref.err;\n                if (err) {\n                    return {\n                        output: OutputFactory.makeErrorOutput(err)\n                    };\n                }\n                return {\n                    state: state.setFileSystem(deletedPathFS)\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/rmdir.js\": /*!*******************************!*\\\n  !*** ./src/commands/rmdir.js ***!\n  \\*******************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_398572__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_398572__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var DirOp = _interopRequireWildcard(__nested_webpack_require_398572__(/*! fs/operations-with-permissions/directory-operations */ \"./src/fs/operations-with-permissions/directory-operations.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_398572__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _util = __nested_webpack_require_398572__(/*! emulator-state/util */ \"./src/emulator-state/util.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Removes an empty directory\n * Usage: rmdir /emptyDir\n */ var optDef = {};\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), argv = _parseOptions.argv;\n                if (argv.length === 0) {\n                    return {}; // do nothing if no arguments are given\n                }\n                var pathToDelete = (0, _util.resolvePath)(state, argv[0]);\n                var _DirOp$deleteDirector = DirOp.deleteDirectory(state.getFileSystem(), pathToDelete, false), fs = _DirOp$deleteDirector.fs, err = _DirOp$deleteDirector.err;\n                if (err) {\n                    return {\n                        output: OutputFactory.makeErrorOutput(err)\n                    };\n                }\n                return {\n                    state: state.setFileSystem(fs)\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/tail.js\": /*!******************************!*\\\n  !*** ./src/commands/tail.js ***!\n  \\******************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_403074__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_403074__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_403074__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _head_tail_util = __nested_webpack_require_403074__(/*! commands/util/_head_tail_util.js */ \"./src/commands/util/_head_tail_util.js\");\n            var _util = __nested_webpack_require_403074__(/*! emulator-state/util */ \"./src/emulator-state/util.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Prints the last n lines of a file\n * Usage: tail -n 5 file.txt\n */ var optDef = {\n                \"-n, --lines\": \"<count>\"\n            };\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), argv = _parseOptions.argv, options = _parseOptions.options;\n                if (argv.length === 0) {\n                    return {};\n                }\n                var filePath = (0, _util.resolvePath)(state, argv[0]);\n                var tailTrimmingFn = function tailTrimmingFn(lines, lineCount) {\n                    return lines.slice(-1 * lineCount);\n                };\n                var _trimFileContent = (0, _head_tail_util.trimFileContent)(state.getFileSystem(), filePath, options, tailTrimmingFn), content = _trimFileContent.content, err = _trimFileContent.err;\n                if (err) {\n                    return {\n                        output: OutputFactory.makeErrorOutput(err)\n                    };\n                }\n                return {\n                    output: OutputFactory.makeTextOutput(content)\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/touch.js\": /*!*******************************!*\\\n  !*** ./src/commands/touch.js ***!\n  \\*******************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_407772__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var _optionParser = _interopRequireDefault(__nested_webpack_require_407772__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            var FileOp = _interopRequireWildcard(__nested_webpack_require_407772__(/*! fs/operations-with-permissions/file-operations */ \"./src/fs/operations-with-permissions/file-operations.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_407772__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var FileUtil = _interopRequireWildcard(__nested_webpack_require_407772__(/*! fs/util/file-util */ \"./src/fs/util/file-util.js\"));\n            var _util = __nested_webpack_require_407772__(/*! emulator-state/util */ \"./src/emulator-state/util.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Creates an empty file.\n * Usage: touch new_file.txt\n */ var EMPTY_FILE = FileUtil.makeFile();\n            var optDef = {};\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                var _parseOptions = (0, _optionParser[\"default\"])(commandOptions, optDef), argv = _parseOptions.argv;\n                if (argv.length === 0) {\n                    return {}; // do nothing if no arguments are given\n                }\n                var filePath = (0, _util.resolvePath)(state, argv[0]);\n                if (state.getFileSystem().has(filePath)) {\n                    return {}; // do nothing if already has a file at the provided path\n                }\n                var _FileOp$writeFile = FileOp.writeFile(state.getFileSystem(), filePath, EMPTY_FILE), fs = _FileOp$writeFile.fs, err = _FileOp$writeFile.err;\n                if (err) {\n                    return {\n                        output: OutputFactory.makeErrorOutput(err)\n                    };\n                }\n                return {\n                    state: state.setFileSystem(fs)\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/commands/util/_head_tail_util.js\": /*!**********************************************!*\\\n  !*** ./src/commands/util/_head_tail_util.js ***!\n  \\**********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_412651__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.trimFileContent = void 0;\n            var FileOp = _interopRequireWildcard(__nested_webpack_require_412651__(/*! fs/operations-with-permissions/file-operations */ \"./src/fs/operations-with-permissions/file-operations.js\"));\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_412651__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            var DEFAULT_LINE_COUNT = 10;\n            var trimFileContent = function trimFileContent(fs, filePath, options, trimmingFn) {\n                var _FileOp$readFile = FileOp.readFile(fs, filePath), file = _FileOp$readFile.file, err = _FileOp$readFile.err;\n                if (err) {\n                    return {\n                        err: OutputFactory.makeErrorOutput(err)\n                    };\n                }\n                ;\n                var linesCount = options.lines ? Number(options.lines) : DEFAULT_LINE_COUNT;\n                var trimmedLines = trimmingFn(file.get(\"content\").split(\"\\n\"), linesCount);\n                return {\n                    content: trimmedLines.join(\"\\n\")\n                };\n            };\n            exports1.trimFileContent = trimFileContent;\n        /***/ },\n        /***/ \"./src/commands/whoami.js\": /*!********************************!*\\\n  !*** ./src/commands/whoami.js ***!\n  \\********************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_416503__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.optDef = void 0;\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_416503__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var _environmentVariables = __nested_webpack_require_416503__(/*! emulator-state/environment-variables */ \"./src/emulator-state/environment-variables.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            /**\n * Prints the username of the logged in user\n * Usage: whoami\n */ var FALLBACK_USERNAME = \"root\";\n            var optDef = {};\n            exports1.optDef = optDef;\n            var _default = function _default(state, commandOptions) {\n                return {\n                    output: OutputFactory.makeTextOutput((0, _environmentVariables.getEnvironmentVariable)(state.getEnvVariables(), \"user\") || FALLBACK_USERNAME)\n                };\n            };\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/emulator-output/index.js\": /*!**************************************!*\\\n  !*** ./src/emulator-output/index.js ***!\n  \\**************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_420081__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = void 0;\n            var OutputFactory = _interopRequireWildcard(__nested_webpack_require_420081__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\"));\n            var OutputType = _interopRequireWildcard(__nested_webpack_require_420081__(/*! emulator-output/output-type */ \"./src/emulator-output/output-type.js\"));\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            var _default = {\n                OutputFactory: OutputFactory,\n                OutputType: OutputType\n            };\n            exports1[\"default\"] = _default;\n            module1.exports = exports1.default;\n        /***/ },\n        /***/ \"./src/emulator-output/output-factory.js\": /*!***********************************************!*\\\n  !*** ./src/emulator-output/output-factory.js ***!\n  \\***********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_423378__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.makeErrorOutput = exports1.makeTextOutput = exports1.makeHeaderOutput = exports1.OutputRecord = void 0;\n            var _immutable = __nested_webpack_require_423378__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            var _outputType = __nested_webpack_require_423378__(/*! emulator-output/output-type */ \"./src/emulator-output/output-type.js\");\n            /**\n * Output from a command or emulator used for display to the user\n * @type {OutputRecord}\n */ var OutputRecord = (0, _immutable.Record)({\n                type: undefined,\n                content: undefined\n            });\n            /**\n * A terminal header containing metadata\n * @param  {string} cwd   the current working directory path\n * @return {OutputRecord} output record\n */ exports1.OutputRecord = OutputRecord;\n            var makeHeaderOutput = function makeHeaderOutput(cwd, command) {\n                return new OutputRecord({\n                    type: _outputType.HEADER_OUTPUT_TYPE,\n                    content: {\n                        cwd: cwd,\n                        command: command\n                    }\n                });\n            };\n            /**\n * Unstyled text output\n * @param  {string} content plain string output from a command or the emulator\n * @return {OutputRecord}   output record\n */ exports1.makeHeaderOutput = makeHeaderOutput;\n            var makeTextOutput = function makeTextOutput(content) {\n                return new OutputRecord({\n                    type: _outputType.TEXT_OUTPUT_TYPE,\n                    content: content\n                });\n            };\n            /**\n * Error text output\n * @param  {object} err internal error object\n * @return {OutputRecord}   output record\n */ exports1.makeTextOutput = makeTextOutput;\n            var makeErrorOutput = function makeErrorOutput(err) {\n                return new OutputRecord({\n                    type: _outputType.TEXT_ERROR_OUTPUT_TYPE,\n                    content: \"\".concat(err.source, \": \").concat(err.type)\n                });\n            };\n            exports1.makeErrorOutput = makeErrorOutput;\n        /***/ },\n        /***/ \"./src/emulator-output/output-type.js\": /*!********************************************!*\\\n  !*** ./src/emulator-output/output-type.js ***!\n  \\********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.HEADER_OUTPUT_TYPE = exports1.TEXT_ERROR_OUTPUT_TYPE = exports1.TEXT_OUTPUT_TYPE = void 0;\n            /**\n * Types of output which can be used to display content to the user\n * @type {String}\n */ var TEXT_OUTPUT_TYPE = \"TEXT_OUTPUT\";\n            exports1.TEXT_OUTPUT_TYPE = TEXT_OUTPUT_TYPE;\n            var TEXT_ERROR_OUTPUT_TYPE = \"TEXT_ERROR_OUTPUT\";\n            exports1.TEXT_ERROR_OUTPUT_TYPE = TEXT_ERROR_OUTPUT_TYPE;\n            var HEADER_OUTPUT_TYPE = \"HEADER_OUTPUT_TYPE\";\n            exports1.HEADER_OUTPUT_TYPE = HEADER_OUTPUT_TYPE;\n        /***/ },\n        /***/ \"./src/emulator-state/EmulatorState.js\": /*!*********************************************!*\\\n  !*** ./src/emulator-state/EmulatorState.js ***!\n  \\*********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_426925__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = void 0;\n            var _immutable = __nested_webpack_require_426925__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            var _commandMapping = __nested_webpack_require_426925__(/*! emulator-state/command-mapping */ \"./src/emulator-state/command-mapping.js\");\n            var _environmentVariables = __nested_webpack_require_426925__(/*! emulator-state/environment-variables */ \"./src/emulator-state/environment-variables.js\");\n            var _fileSystem = __nested_webpack_require_426925__(/*! emulator-state/file-system */ \"./src/emulator-state/file-system.js\");\n            var _history = __nested_webpack_require_426925__(/*! emulator-state/history */ \"./src/emulator-state/history.js\");\n            var _outputs = __nested_webpack_require_426925__(/*! emulator-state/outputs */ \"./src/emulator-state/outputs.js\");\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                return Constructor;\n            }\n            var FS_KEY = \"fs\";\n            var ENVIRONMENT_VARIABLES_KEY = \"environmentVariables\";\n            var HISTORY_KEY = \"history\";\n            var OUTPUTS_KEY = \"outputs\";\n            var COMMAND_MAPPING_KEY = \"commandMapping\";\n            var EmulatorState = /*#__PURE__*/ function() {\n                function EmulatorState(immutable) {\n                    _classCallCheck(this, EmulatorState);\n                    if (!immutable || !(immutable instanceof _immutable.Map)) {\n                        throw new Error(\"Do not use the constructor directly. Use the static create method.\");\n                    }\n                    this._immutable = immutable;\n                }\n                /**\n   * Creates emulator state with defaults\n   * @return {EmulatorState} default emulator state\n   */ _createClass(EmulatorState, [\n                    {\n                        key: \"getFileSystem\",\n                        value: function getFileSystem() {\n                            return this.getImmutable().get(FS_KEY);\n                        }\n                    },\n                    {\n                        key: \"setFileSystem\",\n                        value: function setFileSystem(newFileSystem) {\n                            return new EmulatorState(this.getImmutable().set(FS_KEY, newFileSystem));\n                        }\n                    },\n                    {\n                        key: \"getEnvVariables\",\n                        value: function getEnvVariables() {\n                            return this.getImmutable().get(ENVIRONMENT_VARIABLES_KEY);\n                        }\n                    },\n                    {\n                        key: \"setEnvVariables\",\n                        value: function setEnvVariables(newEnvVariables) {\n                            return new EmulatorState(this.getImmutable().set(ENVIRONMENT_VARIABLES_KEY, newEnvVariables));\n                        }\n                    },\n                    {\n                        key: \"getHistory\",\n                        value: function getHistory() {\n                            return this.getImmutable().get(HISTORY_KEY);\n                        }\n                    },\n                    {\n                        key: \"setHistory\",\n                        value: function setHistory(newHistory) {\n                            return new EmulatorState(this.getImmutable().set(HISTORY_KEY, newHistory));\n                        }\n                    },\n                    {\n                        key: \"getOutputs\",\n                        value: function getOutputs() {\n                            return this.getImmutable().get(OUTPUTS_KEY);\n                        }\n                    },\n                    {\n                        key: \"setOutputs\",\n                        value: function setOutputs(newOutputs) {\n                            return new EmulatorState(this.getImmutable().set(OUTPUTS_KEY, newOutputs));\n                        }\n                    },\n                    {\n                        key: \"getCommandMapping\",\n                        value: function getCommandMapping() {\n                            return this.getImmutable().get(COMMAND_MAPPING_KEY);\n                        }\n                    },\n                    {\n                        key: \"setCommandMapping\",\n                        value: function setCommandMapping(newCommandMapping) {\n                            return new EmulatorState(this.getImmutable().set(COMMAND_MAPPING_KEY, newCommandMapping));\n                        }\n                    },\n                    {\n                        key: \"getImmutable\",\n                        value: function getImmutable() {\n                            return this._immutable;\n                        }\n                    },\n                    {\n                        key: \"toJS\",\n                        value: function toJS() {\n                            return this._immutable.toJS();\n                        }\n                    }\n                ], [\n                    {\n                        key: \"createEmpty\",\n                        value: function createEmpty() {\n                            return EmulatorState.create({});\n                        }\n                    },\n                    {\n                        key: \"create\",\n                        value: function create(_ref) {\n                            var _Map;\n                            var _ref$fs = _ref.fs, fs = _ref$fs === void 0 ? (0, _fileSystem.create)() : _ref$fs, _ref$environmentVaria = _ref.environmentVariables, environmentVariables = _ref$environmentVaria === void 0 ? (0, _environmentVariables.create)() : _ref$environmentVaria, _ref$history = _ref.history, history = _ref$history === void 0 ? (0, _history.create)() : _ref$history, _ref$outputs = _ref.outputs, outputs = _ref$outputs === void 0 ? (0, _outputs.create)() : _ref$outputs, _ref$commandMapping = _ref.commandMapping, commandMapping = _ref$commandMapping === void 0 ? (0, _commandMapping.create)() : _ref$commandMapping;\n                            var stateMap = new _immutable.Map((_Map = {}, _defineProperty(_Map, FS_KEY, fs), _defineProperty(_Map, ENVIRONMENT_VARIABLES_KEY, environmentVariables), _defineProperty(_Map, HISTORY_KEY, history), _defineProperty(_Map, OUTPUTS_KEY, outputs), _defineProperty(_Map, COMMAND_MAPPING_KEY, commandMapping), _Map));\n                            return new EmulatorState(stateMap);\n                        }\n                    }\n                ]);\n                return EmulatorState;\n            }();\n            exports1[\"default\"] = EmulatorState;\n            module1.exports = exports1.default;\n        /***/ },\n        /***/ \"./src/emulator-state/command-mapping.js\": /*!***********************************************!*\\\n  !*** ./src/emulator-state/command-mapping.js ***!\n  \\***********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_435310__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.getCommandNames = exports1.getCommandOptDef = exports1.getCommandFn = exports1.unsetCommand = exports1.setCommand = exports1.isCommandSet = exports1.create = void 0;\n            var _immutable = __nested_webpack_require_435310__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            var _commands = _interopRequireDefault(__nested_webpack_require_435310__(/*! commands */ \"./src/commands/index.js\"));\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Links a command name to a function\n * @param  {Object} [commandMapping={}] default command map\n * @return {Map}                        command mapping\n */ var create = function create() {\n                var commandMapping = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _commands[\"default\"];\n                for(var _i = 0, _Object$keys = Object.keys(commandMapping); _i < _Object$keys.length; _i++){\n                    var commandName = _Object$keys[_i];\n                    var command = commandMapping[commandName];\n                    if (!command.hasOwnProperty(\"function\")) {\n                        throw new Error(\"Failed to create command mapping: missing command function for \".concat(commandName));\n                    }\n                    if (!command.hasOwnProperty(\"optDef\")) {\n                        throw new Error(\"Failed to create command mapping: missing option definition (optDef) for \".concat(commandName));\n                    }\n                }\n                return (0, _immutable.fromJS)(commandMapping);\n            };\n            /**\n * Checks if a comand has been defined with a function in the command mapping\n * @param  {Map}     commandMapping command mapping\n * @param  {string}  commandName    command name to check if available\n * @return {Boolean}                true, if the command is available\n */ exports1.create = create;\n            var isCommandSet = function isCommandSet(commandMapping, commandName) {\n                return commandMapping.has(commandName);\n            };\n            /**\n * Set a command function with a key of the command name into the command mapping\n * @param  {Map}      commandMapping command mapping\n * @param  {string}   commandName    name of the function\n * @param  {function} commandFn      command function\n * @param  {object}   optDef         option definition (optional)\n * @return {Map}                     command mapping\n */ exports1.isCommandSet = isCommandSet;\n            var setCommand = function setCommand(commandMapping, commandName, commandFn, optDef) {\n                if (commandFn === undefined) {\n                    throw new Error(\"Cannot set \".concat(commandName, \" command without function\"));\n                }\n                if (optDef === undefined) {\n                    throw new Error(\"Cannot set \".concat(commandName, \" command without optDef (pass in {} if the command takes no options)\"));\n                }\n                return commandMapping.set(commandName, (0, _immutable.fromJS)({\n                    \"function\": commandFn,\n                    \"optDef\": optDef\n                }));\n            };\n            /**\n * Removes a command name and its function from a command mapping\n * @param  {Map}    commandMapping command mapping\n * @param  {string} commandName    name of command to remove\n * @return {Map}                   command mapping\n */ exports1.setCommand = setCommand;\n            var unsetCommand = function unsetCommand(commandMapping, commandName) {\n                return commandMapping[\"delete\"](commandName);\n            };\n            /**\n * Gets the function of a command based on its command name (the key) from the\n * command mapping\n * @param  {Map}      commandMapping command mapping\n * @param  {string}   commandName    name of command\n * @return {function}                command function\n */ exports1.unsetCommand = unsetCommand;\n            var getCommandFn = function getCommandFn(commandMapping, commandName) {\n                if (commandMapping.has(commandName)) {\n                    return commandMapping.get(commandName).get(\"function\");\n                }\n                return undefined;\n            };\n            /**\n * Gets the option definition of a command based on its command name\n * @param  {Map}      commandMapping command mapping\n * @param  {string}   commandName    name of command\n * @return {Map}                     option definition\n */ exports1.getCommandFn = getCommandFn;\n            var getCommandOptDef = function getCommandOptDef(commandMapping, commandName) {\n                if (commandMapping.has(commandName)) {\n                    return commandMapping.get(commandName).get(\"optDef\");\n                }\n                return undefined;\n            };\n            /**\n * Gets command names\n * @param  {Map}      commandMapping command mapping\n * @return {Seq}                     sequence of command names\n */ exports1.getCommandOptDef = getCommandOptDef;\n            var getCommandNames = function getCommandNames(commandMapping) {\n                return commandMapping.keySeq();\n            };\n            exports1.getCommandNames = getCommandNames;\n        /***/ },\n        /***/ \"./src/emulator-state/environment-variables.js\": /*!*****************************************************!*\\\n  !*** ./src/emulator-state/environment-variables.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_441050__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.unsetEnvironmentVariable = exports1.setEnvironmentVariable = exports1.getEnvironmentVariable = exports1.create = void 0;\n            var _immutable = __nested_webpack_require_441050__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            function ownKeys(object, enumerableOnly) {\n                var keys = Object.keys(object);\n                if (Object.getOwnPropertySymbols) {\n                    var symbols = Object.getOwnPropertySymbols(object);\n                    if (enumerableOnly) symbols = symbols.filter(function(sym) {\n                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n                    });\n                    keys.push.apply(keys, symbols);\n                }\n                return keys;\n            }\n            function _objectSpread(target) {\n                for(var i = 1; i < arguments.length; i++){\n                    var source = arguments[i] != null ? arguments[i] : {};\n                    if (i % 2) {\n                        ownKeys(Object(source), true).forEach(function(key) {\n                            _defineProperty(target, key, source[key]);\n                        });\n                    } else if (Object.getOwnPropertyDescriptors) {\n                        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n                    } else {\n                        ownKeys(Object(source)).forEach(function(key) {\n                            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n                        });\n                    }\n                }\n                return target;\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            /**\n * Environment variable mapping containing arbitary data accessed by any\n * command or the emulator as a key-value pair\n * @param  {Object} [defaultVariables={}] default environment variables\n * @return {Map}                          environment variables\n */ var create = function create() {\n                var defaultVariables = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                var cwd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"/\";\n                if (!cwd && !defaultVariables.hasOwnProperty(\"cwd\")) {\n                    throw new Error(\"Failed to create environment variables. Missing 'cwd' (current working directory).\");\n                }\n                return (0, _immutable.Map)(_objectSpread({\n                    \"cwd\": cwd\n                }, defaultVariables));\n            };\n            /**\n * Gets the value of an environment variable\n * @param  {Map} environmentVariables environment variables\n * @param  {string} key               name of the environment variable\n * @return {T}                        the value stored in the environment variable\n */ exports1.create = create;\n            var getEnvironmentVariable = function getEnvironmentVariable(environmentVariables, key) {\n                return environmentVariables.get(key);\n            };\n            /**\n * Sets the value of an environment variable\n * @param {Map} environmentVariables environment variables\n * @param {string} key               name of the environment variable\n * @param {T} val                    value to store in the environment variable\n * @return {Map}                     environment variables\n */ exports1.getEnvironmentVariable = getEnvironmentVariable;\n            var setEnvironmentVariable = function setEnvironmentVariable(environmentVariables, key, val) {\n                return environmentVariables.set(key, val);\n            };\n            /**\n * Removes an environment variable\n * @param {Map} environmentVariables environment variables\n * @param {string} key               name of the environment variable\n * @return {Map}                     environment variables\n */ exports1.setEnvironmentVariable = setEnvironmentVariable;\n            var unsetEnvironmentVariable = function unsetEnvironmentVariable(environmentVariables, key) {\n                return environmentVariables[\"delete\"](key);\n            };\n            exports1.unsetEnvironmentVariable = unsetEnvironmentVariable;\n        /***/ },\n        /***/ \"./src/emulator-state/file-system.js\": /*!*******************************************!*\\\n  !*** ./src/emulator-state/file-system.js ***!\n  \\*******************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_446087__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.create = void 0;\n            var FileUtil = _interopRequireWildcard(__nested_webpack_require_446087__(/*! fs/util/file-util */ \"./src/fs/util/file-util.js\"));\n            var DirOp = _interopRequireWildcard(__nested_webpack_require_446087__(/*! fs/operations/directory-operations */ \"./src/fs/operations/directory-operations.js\"));\n            var _immutable = __nested_webpack_require_446087__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            var DEFAULT_FILE_SYSTEM = {\n                \"/\": FileUtil.makeDirectory()\n            };\n            /**\n * Creates an immutable data structure for a file system\n * @param  {object} jsFs a file system in a simple JavaScript object\n * @return {Map}         an immutable file system\n */ var create = function create() {\n                var jsFs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_FILE_SYSTEM;\n                return DirOp.fillGaps((0, _immutable.fromJS)(jsFs));\n            };\n            exports1.create = create;\n        /***/ },\n        /***/ \"./src/emulator-state/history.js\": /*!***************************************!*\\\n  !*** ./src/emulator-state/history.js ***!\n  \\***************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_449789__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.recordCommand = exports1.create = void 0;\n            var _immutable = __nested_webpack_require_449789__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(n);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            /**\n * Creates a new history stack of previous commands that have been run in the\n * emulator\n * @param  {array}  [entries=[]] commands which have already been run (if any)\n * @return {Stack}               history list\n */ var create = function create() {\n                var entries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n                return _immutable.Stack.of.apply(_immutable.Stack, _toConsumableArray(entries));\n            };\n            /**\n * Stores a command in history in a stack (i.e., the latest command is on top of\n * the history stack)\n * @param  {Stack} history     history\n * @param  {string} commandRun the command to store\n * @return {Stack}             history\n */ exports1.create = create;\n            var recordCommand = function recordCommand(history, commandRun) {\n                return history.push(commandRun);\n            };\n            exports1.recordCommand = recordCommand;\n        /***/ },\n        /***/ \"./src/emulator-state/index.js\": /*!*************************************!*\\\n  !*** ./src/emulator-state/index.js ***!\n  \\*************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_452888__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = void 0;\n            var CommandMapping = _interopRequireWildcard(__nested_webpack_require_452888__(/*! emulator-state/command-mapping */ \"./src/emulator-state/command-mapping.js\"));\n            var EnvironmentVariables = _interopRequireWildcard(__nested_webpack_require_452888__(/*! emulator-state/environment-variables */ \"./src/emulator-state/environment-variables.js\"));\n            var FileSystem = _interopRequireWildcard(__nested_webpack_require_452888__(/*! emulator-state/file-system */ \"./src/emulator-state/file-system.js\"));\n            var History = _interopRequireWildcard(__nested_webpack_require_452888__(/*! emulator-state/history */ \"./src/emulator-state/history.js\"));\n            var Outputs = _interopRequireWildcard(__nested_webpack_require_452888__(/*! emulator-state/outputs */ \"./src/emulator-state/outputs.js\"));\n            var _EmulatorState = _interopRequireDefault(__nested_webpack_require_452888__(/*! emulator-state/EmulatorState */ \"./src/emulator-state/EmulatorState.js\"));\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            var _default = {\n                EmulatorState: _EmulatorState[\"default\"],\n                CommandMapping: CommandMapping,\n                EnvironmentVariables: EnvironmentVariables,\n                FileSystem: FileSystem,\n                History: History,\n                Outputs: Outputs\n            };\n            exports1[\"default\"] = _default;\n            module1.exports = exports1.default;\n        /***/ },\n        /***/ \"./src/emulator-state/outputs.js\": /*!***************************************!*\\\n  !*** ./src/emulator-state/outputs.js ***!\n  \\***************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_457121__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.addRecord = exports1.create = void 0;\n            var _immutable = __nested_webpack_require_457121__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            /**\n * Stores outputs from the emulator (e.g. text to display after running a command)\n * @param  {Array}  [outputs=[]] Previous outputs\n * @return {List}               List of outputs objects\n */ var create = function create() {\n                var outputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n                return (0, _immutable.List)(outputs);\n            };\n            /**\n * Adds a new output record\n * @param {List}         outputs      outputs list\n * @param {OutputRecord} outputRecord record conforming to output schema\n */ exports1.create = create;\n            var addRecord = function addRecord(outputs, outputRecord) {\n                if (!_immutable.Record.isRecord(outputRecord)) {\n                    throw new Error(\"Only records of type OutputRecord can be added to outputs\");\n                }\n                if (!outputRecord.has(\"type\")) {\n                    throw new Error(\"Output record must include a type\");\n                }\n                if (!outputRecord.has(\"content\")) {\n                    throw new Error(\"Output record must include content\");\n                }\n                return outputs.push(outputRecord);\n            };\n            exports1.addRecord = addRecord;\n        /***/ },\n        /***/ \"./src/emulator-state/util.js\": /*!************************************!*\\\n  !*** ./src/emulator-state/util.js ***!\n  \\************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_458962__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.resolvePath = void 0;\n            var EnvVariableUtil = _interopRequireWildcard(__nested_webpack_require_458962__(/*! emulator-state/environment-variables */ \"./src/emulator-state/environment-variables.js\"));\n            var PathUtil = _interopRequireWildcard(__nested_webpack_require_458962__(/*! fs/util/path-util */ \"./src/fs/util/path-util.js\"));\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            /**\n * Converts a given path to an absolute path using the\n * current working directory\n * @param  {EmulatorState} state emulator state\n * @param  {string} path         path (relative or absolute)\n * @return {string}              absolute path\n */ var resolvePath = function resolvePath(state, path) {\n                var cwd = EnvVariableUtil.getEnvironmentVariable(state.getEnvVariables(), \"cwd\");\n                return PathUtil.toAbsolutePath(path, cwd);\n            };\n            exports1.resolvePath = resolvePath;\n        /***/ },\n        /***/ \"./src/emulator/auto-complete.js\": /*!***************************************!*\\\n  !*** ./src/emulator/auto-complete.js ***!\n  \\***************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_462533__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.suggestFileSystemNames = exports1.suggestCommandOptions = exports1.suggestCommands = void 0;\n            var PathUtil = _interopRequireWildcard(__nested_webpack_require_462533__(/*! fs/util/path-util */ \"./src/fs/util/path-util.js\"));\n            var GlobUtil = _interopRequireWildcard(__nested_webpack_require_462533__(/*! fs/util/glob-util */ \"./src/fs/util/glob-util.js\"));\n            var _commandMapping = __nested_webpack_require_462533__(/*! emulator-state/command-mapping */ \"./src/emulator-state/command-mapping.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(n);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            /**\n * Suggest command names\n * @param  {Map}    cmdMapping     command mapping\n * @param  {string} partialStr     partial user input of a command\n * @return {array}                 list of possible text suggestions\n */ var suggestCommands = function suggestCommands(cmdMapping, partialStr) {\n                var commandNameSeq = (0, _commandMapping.getCommandNames)(cmdMapping);\n                return _toConsumableArray(GlobUtil.globSeq(commandNameSeq, \"\".concat(partialStr, \"*\")));\n            };\n            /**\n * Suggest command options\n * @param  {Map}    cmdMapping     command mapping\n * @param  {string} commandName    name of the command user is running\n * @param  {string} partialStr     partial user input of a command (excluding the command name)\n * @return {array}                 list of possible text suggestions\n */ exports1.suggestCommands = suggestCommands;\n            var suggestCommandOptions = function suggestCommandOptions(cmdMapping, commandName, partialStr) {\n                if (!(0, _commandMapping.isCommandSet)(cmdMapping, commandName)) {\n                    return [];\n                }\n                var optDefSeq = (0, _commandMapping.getCommandOptDef)(cmdMapping, commandName).keySeq().flatMap(function(opts) {\n                    return opts.split(\",\").map(function(opt) {\n                        return opt.trim();\n                    });\n                });\n                return _toConsumableArray(GlobUtil.globSeq(optDefSeq, \"\".concat(partialStr, \"*\")));\n            };\n            /**\n * Suggest file and folder names from partially completed user input\n * @param  {Map}    fileSystem file system\n * @param  {string} cwd        current working directory\n * @param  {string} partialStr partial string to base suggestions on (excluding the command name)\n * @return {array}             list of possible text suggestions\n */ exports1.suggestCommandOptions = suggestCommandOptions;\n            var suggestFileSystemNames = function suggestFileSystemNames(fileSystem, cwd, partialStr) {\n                var path = PathUtil.toAbsolutePath(partialStr, cwd); // complete name of a folder or file\n                var completeNamePattern = \"\".concat(path, \"*\"); // complete child folder name\n                var completeSubfolderPattern = path === \"/\" ? \"/*\" : \"\".concat(path, \"*/*\"); // only complete child folders when the path ends with / (which marks a directory path)\n                var globPattern = partialStr.endsWith(\"/\") ? completeSubfolderPattern : completeNamePattern;\n                var childPaths = GlobUtil.globPaths(fileSystem, globPattern);\n                if (PathUtil.isAbsPath(partialStr)) {\n                    return _toConsumableArray(childPaths); // absolute paths\n                }\n                return _toConsumableArray(childPaths.map(function(path) {\n                    var pathPartsWithoutTail = PathUtil.toPathParts(partialStr).slice(0, -1);\n                    var newTail = PathUtil.getLastPathPart(path);\n                    return PathUtil.toPath(pathPartsWithoutTail.concat(newTail));\n                })); // relative paths\n            };\n            exports1.suggestFileSystemNames = suggestFileSystemNames;\n        /***/ },\n        /***/ \"./src/emulator/command-runner.js\": /*!****************************************!*\\\n  !*** ./src/emulator/command-runner.js ***!\n  \\****************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_470486__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.run = exports1.makeRunnerErrorOutput = void 0;\n            var _emulatorError = __nested_webpack_require_470486__(/*! emulator/emulator-error */ \"./src/emulator/emulator-error.js\");\n            var _outputFactory = __nested_webpack_require_470486__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\");\n            var CommandMappingUtil = _interopRequireWildcard(__nested_webpack_require_470486__(/*! emulator-state/command-mapping */ \"./src/emulator-state/command-mapping.js\"));\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(n);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            /**\n * Makes an internal emulator error for emulator output. Error output may be\n * visible to the user.\n * @param  {string} errorType type of emulator error\n * @return {object}           error output object\n */ var makeRunnerErrorOutput = function makeRunnerErrorOutput(errorType) {\n                return (0, _outputFactory.makeErrorOutput)((0, _emulatorError.makeError)(errorType));\n            };\n            /**\n * Runs a command and returns an object containing either:\n * - outputs from running the command, or\n * - new emulator state after running the command, or\n * - new emulator state and output after running the command\n *\n * The form of the object from this function is as follows:\n * {\n *   outputs: [optional array of output records]\n *   output: [optional single output record]\n *   state: [optional Map]\n * }\n * @param  {Map}    commandMapping command mapping from emulator state\n * @param  {string} commandName    name of command to run\n * @param  {array}  commandArgs    commands to provide to the command function\n * @param  {string}  errorStr      a default string to be displayed if no command is found\n * @return {object}                outputs and/or new state of the emulator\n */ exports1.makeRunnerErrorOutput = makeRunnerErrorOutput;\n            var run = function run(commandMapping, commandName, commandArgs) {\n                var errorStr = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _emulatorError.emulatorErrorType.COMMAND_NOT_FOUND;\n                var notFoundCallback = function notFoundCallback() {\n                    return {\n                        output: makeRunnerErrorOutput(errorStr)\n                    };\n                };\n                if (!CommandMappingUtil.isCommandSet(commandMapping, commandName)) {\n                    return notFoundCallback.apply(void 0, _toConsumableArray(commandArgs));\n                }\n                var command = CommandMappingUtil.getCommandFn(commandMapping, commandName);\n                try {\n                    return command.apply(void 0, _toConsumableArray(commandArgs)); // run extracted command from the mapping\n                } catch (fatalCommandError) {\n                    return {\n                        output: makeRunnerErrorOutput(_emulatorError.emulatorErrorType.UNEXPECTED_COMMAND_FAILURE)\n                    };\n                }\n            };\n            exports1.run = run;\n        /***/ },\n        /***/ \"./src/emulator/emulator-error.js\": /*!****************************************!*\\\n  !*** ./src/emulator/emulator-error.js ***!\n  \\****************************************/ /*! no static exports found */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.makeError = exports1.emulatorErrorType = void 0;\n            /**\n * Emulator error type\n * @type {Object}\n */ var emulatorErrorType = {\n                COMMAND_NOT_FOUND: \"Command not found\",\n                UNEXPECTED_COMMAND_FAILURE: \"Unhandled command error\"\n            };\n            /**\n * Creates an error to display to the user originating from the emulator\n * @param  {string} emulatorErrorType  file system error type\n * @param  {string} [message='']       optional metadata for developers about the error\n * @return {object}                    internal error object\n */ exports1.emulatorErrorType = emulatorErrorType;\n            var makeError = function makeError(emulatorErrorType) {\n                var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n                return {\n                    source: \"emulator\",\n                    type: emulatorErrorType,\n                    message: message\n                };\n            };\n            exports1.makeError = makeError;\n        /***/ },\n        /***/ \"./src/emulator/index.js\": /*!*******************************!*\\\n  !*** ./src/emulator/index.js ***!\n  \\*******************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_479077__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = void 0;\n            var CommandRunner = _interopRequireWildcard(__nested_webpack_require_479077__(/*! emulator/command-runner */ \"./src/emulator/command-runner.js\"));\n            var _commandParser = _interopRequireDefault(__nested_webpack_require_479077__(/*! parser/command-parser */ \"./src/parser/command-parser.js\"));\n            var _outputFactory = __nested_webpack_require_479077__(/*! emulator-output/output-factory */ \"./src/emulator-output/output-factory.js\");\n            var _history = __nested_webpack_require_479077__(/*! emulator-state/history */ \"./src/emulator-state/history.js\");\n            var _environmentVariables = __nested_webpack_require_479077__(/*! emulator-state/environment-variables */ \"./src/emulator-state/environment-variables.js\");\n            var _autoComplete = __nested_webpack_require_479077__(/*! emulator/auto-complete */ \"./src/emulator/auto-complete.js\");\n            var _immutable = __nested_webpack_require_479077__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _createForOfIteratorHelper(o) {\n                if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n                    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n                        var i = 0;\n                        var F = function F() {};\n                        return {\n                            s: F,\n                            n: function n() {\n                                if (i >= o.length) return {\n                                    done: true\n                                };\n                                return {\n                                    done: false,\n                                    value: o[i++]\n                                };\n                            },\n                            e: function e(_e) {\n                                throw _e;\n                            },\n                            f: F\n                        };\n                    }\n                    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                }\n                var it, normalCompletion = true, didErr = false, err;\n                return {\n                    s: function s() {\n                        it = o[Symbol.iterator]();\n                    },\n                    n: function n() {\n                        var step = it.next();\n                        normalCompletion = step.done;\n                        return step;\n                    },\n                    e: function e(_e2) {\n                        didErr = true;\n                        err = _e2;\n                    },\n                    f: function f() {\n                        try {\n                            if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n                        } finally{\n                            if (didErr) throw err;\n                        }\n                    }\n                };\n            }\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(n);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                return Constructor;\n            }\n            var Emulator = /*#__PURE__*/ function() {\n                function Emulator() {\n                    _classCallCheck(this, Emulator);\n                }\n                _createClass(Emulator, [\n                    {\n                        key: \"autocomplete\",\n                        /**\n     * Completes user input if there is one, and only one, suggestion.\n     *\n     * If there are no suggestions or more than one suggestion, the original\n     * user input will be returned.\n     * @param  {EmulatorState} state      emulator state\n     * @param  {string}        partialStr partial user input to the emulator\n     * @return {string}                   completed user input when one suggest (or, otherwsie, the original input)\n     */ value: function autocomplete(state, partialStr) {\n                            var suggestions = this.suggest(state, partialStr);\n                            if (suggestions.length !== 1) {\n                                return partialStr;\n                            }\n                            var strParts = new _immutable.List(partialStr.split(\" \"));\n                            var autocompletedText = suggestions[0];\n                            return strParts.update(-1, function(lastVal) {\n                                return autocompletedText;\n                            }).join(\" \");\n                        }\n                    },\n                    {\n                        key: \"suggest\",\n                        /**\n     * Suggest what the user will type next\n     * @param  {EmulatorState} state      emulator state\n     * @param  {string}        partialStr partial user input of a command\n     * @return {array}                    list of possible text suggestions\n     */ value: function suggest(state, partialStr) {\n                            partialStr = this._trimLeadingSpace(partialStr);\n                            var lastPartialChar = partialStr.slice(-1);\n                            var isTypingNewPart = lastPartialChar === \" \";\n                            var strParts = partialStr.trim().split(\" \");\n                            var _this$_getBoundaryWor = this._getBoundaryWords(strParts), cmdName = _this$_getBoundaryWor.start, lastTextEntered = _this$_getBoundaryWor.end;\n                            if (!isTypingNewPart && strParts.length === 1) {\n                                return (0, _autoComplete.suggestCommands)(state.getCommandMapping(), cmdName);\n                            }\n                            var strToComplete = isTypingNewPart ? \"\" : lastTextEntered;\n                            var cwd = (0, _environmentVariables.getEnvironmentVariable)(state.getEnvVariables(), \"cwd\");\n                            return [].concat(_toConsumableArray((0, _autoComplete.suggestCommandOptions)(state.getCommandMapping(), cmdName, strToComplete)), _toConsumableArray((0, _autoComplete.suggestFileSystemNames)(state.getFileSystem(), cwd, strToComplete)));\n                        }\n                    },\n                    {\n                        key: \"_trimLeadingSpace\",\n                        value: function _trimLeadingSpace(str) {\n                            return str.replace(/^\\s+/g, \"\");\n                        }\n                    },\n                    {\n                        key: \"_getBoundaryWords\",\n                        value: function _getBoundaryWords(strParts) {\n                            return {\n                                start: strParts[0],\n                                end: strParts[strParts.length - 1]\n                            };\n                        }\n                    },\n                    {\n                        key: \"execute\",\n                        /**\n     * Runs emulator command\n     * @param  {EmulatorState}  state                   emulator state before running command\n     * @param  {string}         str                     command string to execute\n     * @param  {Array}          [executionListeners=[]] list of plugins to notify while running the command\n     * @param  {string}         errorStr                string to display on unrecognized command\n     * @return {EmulatorState}                          updated emulator state after running command\n     */ value: function execute(state, str) {\n                            var executionListeners = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n                            var errorStr = arguments.length > 3 ? arguments[3] : undefined;\n                            var _iterator = _createForOfIteratorHelper(executionListeners), _step;\n                            try {\n                                for(_iterator.s(); !(_step = _iterator.n()).done;){\n                                    var executionListener = _step.value;\n                                    executionListener.onExecuteStarted(state, str);\n                                }\n                            } catch (err) {\n                                _iterator.e(err);\n                            } finally{\n                                _iterator.f();\n                            }\n                            state = this._addHeaderOutput(state, str);\n                            if (str.trim() === \"\") {\n                                // empty command string\n                                state = this._addCommandOutputs(state, [\n                                    (0, _outputFactory.makeTextOutput)(\"\")\n                                ]);\n                            } else {\n                                state = this._addCommandToHistory(state, str);\n                                state = this._updateStateByExecution(state, str, errorStr);\n                            }\n                            var _iterator2 = _createForOfIteratorHelper(executionListeners), _step2;\n                            try {\n                                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                                    var _executionListener = _step2.value;\n                                    _executionListener.onExecuteCompleted(state);\n                                }\n                            } catch (err) {\n                                _iterator2.e(err);\n                            } finally{\n                                _iterator2.f();\n                            }\n                            return state;\n                        }\n                    },\n                    {\n                        key: \"_updateStateByExecution\",\n                        value: function _updateStateByExecution(state, commandStrToExecute, errorStr) {\n                            var _iterator3 = _createForOfIteratorHelper((0, _commandParser[\"default\"])(commandStrToExecute)), _step3;\n                            try {\n                                for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                                    var _step3$value = _step3.value, commandName = _step3$value.commandName, commandOptions = _step3$value.commandOptions;\n                                    var commandMapping = state.getCommandMapping();\n                                    var commandArgs = [\n                                        state,\n                                        commandOptions\n                                    ];\n                                    var _CommandRunner$run = CommandRunner.run(commandMapping, commandName, commandArgs, errorStr), nextState = _CommandRunner$run.state, output = _CommandRunner$run.output, outputs = _CommandRunner$run.outputs;\n                                    if (nextState) {\n                                        state = nextState;\n                                    }\n                                    if (output) {\n                                        state = this._addCommandOutputs(state, [\n                                            output\n                                        ]);\n                                    } else if (outputs) {\n                                        state = this._addCommandOutputs(state, outputs);\n                                    }\n                                }\n                            } catch (err) {\n                                _iterator3.e(err);\n                            } finally{\n                                _iterator3.f();\n                            }\n                            return state;\n                        }\n                    },\n                    {\n                        key: \"_addCommandToHistory\",\n                        value: function _addCommandToHistory(state, command) {\n                            var history = state.getHistory();\n                            return state.setHistory((0, _history.recordCommand)(history, command));\n                        }\n                    },\n                    {\n                        key: \"_addHeaderOutput\",\n                        value: function _addHeaderOutput(state, commandStr) {\n                            var envVariables = state.getEnvVariables();\n                            var cwd = (0, _environmentVariables.getEnvironmentVariable)(envVariables, \"cwd\");\n                            return this._addCommandOutputs(state, [\n                                (0, _outputFactory.makeHeaderOutput)(cwd, commandStr)\n                            ]);\n                        }\n                    },\n                    {\n                        key: \"_addCommandOutputs\",\n                        value: function _addCommandOutputs(state, outputs) {\n                            var _iterator4 = _createForOfIteratorHelper(outputs), _step4;\n                            try {\n                                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                                    var output = _step4.value;\n                                    var _outputs = state.getOutputs();\n                                    state = state.setOutputs(_outputs.push(output));\n                                }\n                            } catch (err) {\n                                _iterator4.e(err);\n                            } finally{\n                                _iterator4.f();\n                            }\n                            return state;\n                        }\n                    }\n                ]);\n                return Emulator;\n            }();\n            exports1[\"default\"] = Emulator;\n            module1.exports = exports1.default;\n        /***/ },\n        /***/ \"./src/emulator/plugins/BoundedHistoryIterator.js\": /*!********************************************************!*\\\n  !*** ./src/emulator/plugins/BoundedHistoryIterator.js ***!\n  \\********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = void 0;\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                return Constructor;\n            }\n            /**\n * Makes a stack iterator for a point in history.\n *\n * Can go backwards and forwards through the history and is bounded by\n * the size of the stack.\n */ var BoundedHistoryIterator = /*#__PURE__*/ function() {\n                function BoundedHistoryIterator(historyStack) {\n                    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                    _classCallCheck(this, BoundedHistoryIterator);\n                    this.historyStack = historyStack.push(\"\");\n                    this.index = index;\n                }\n                _createClass(BoundedHistoryIterator, [\n                    {\n                        key: \"hasUp\",\n                        value: function hasUp() {\n                            return this.index + 1 < this.historyStack.size;\n                        }\n                    },\n                    {\n                        key: \"up\",\n                        value: function up() {\n                            if (this.hasUp()) {\n                                this.index++;\n                            }\n                            return this.historyStack.get(this.index);\n                        }\n                    },\n                    {\n                        key: \"hasDown\",\n                        value: function hasDown() {\n                            return this.index - 1 >= 0;\n                        }\n                    },\n                    {\n                        key: \"down\",\n                        value: function down() {\n                            if (this.hasDown()) {\n                                this.index--;\n                            }\n                            return this.historyStack.get(this.index);\n                        }\n                    }\n                ]);\n                return BoundedHistoryIterator;\n            }();\n            exports1[\"default\"] = BoundedHistoryIterator;\n            ;\n            module1.exports = exports1.default;\n        /***/ },\n        /***/ \"./src/emulator/plugins/HistoryKeyboardPlugin.js\": /*!*******************************************************!*\\\n  !*** ./src/emulator/plugins/HistoryKeyboardPlugin.js ***!\n  \\*******************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_501514__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = void 0;\n            var _BoundedHistoryIterator = _interopRequireDefault(__nested_webpack_require_501514__(/*! emulator/plugins/BoundedHistoryIterator */ \"./src/emulator/plugins/BoundedHistoryIterator.js\"));\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                return Constructor;\n            }\n            var HistoryKeyboardPlugin = /*#__PURE__*/ function() {\n                function HistoryKeyboardPlugin(state) {\n                    _classCallCheck(this, HistoryKeyboardPlugin);\n                    this._nullableHistoryIterator = null;\n                    this.historyStack = state.getHistory();\n                } // Plugin contract\n                _createClass(HistoryKeyboardPlugin, [\n                    {\n                        key: \"onExecuteStarted\",\n                        value: function onExecuteStarted(state, str) {} // no-op\n                    },\n                    {\n                        key: \"onExecuteCompleted\",\n                        value: function onExecuteCompleted(state) {\n                            this._nullableHistoryIterator = null;\n                            this.historyStack = state.getHistory();\n                        } // Plugin API\n                    },\n                    {\n                        key: \"completeUp\",\n                        value: function completeUp() {\n                            this.createHistoryIteratorIfNull();\n                            return this._nullableHistoryIterator.up();\n                        }\n                    },\n                    {\n                        key: \"completeDown\",\n                        value: function completeDown() {\n                            this.createHistoryIteratorIfNull();\n                            return this._nullableHistoryIterator.down();\n                        } // Private methods\n                    },\n                    {\n                        key: \"createHistoryIteratorIfNull\",\n                        value: function createHistoryIteratorIfNull() {\n                            if (!this._nullableHistoryIterator) {\n                                this._nullableHistoryIterator = new _BoundedHistoryIterator[\"default\"](this.historyStack);\n                            }\n                        }\n                    }\n                ]);\n                return HistoryKeyboardPlugin;\n            }();\n            exports1[\"default\"] = HistoryKeyboardPlugin;\n            module1.exports = exports1.default;\n        /***/ },\n        /***/ \"./src/fs/fs-error.js\": /*!****************************!*\\\n  !*** ./src/fs/fs-error.js ***!\n  \\****************************/ /*! no static exports found */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.makeError = exports1.fsErrorType = void 0;\n            /**\n * File system error types\n * @type {Object}\n */ var fsErrorType = {\n                FILE_EXISTS: \"File exists\",\n                DIRECTORY_EXISTS: \"Directory exists\",\n                DIRECTORY_NOT_EMPTY: \"Directory not empty\",\n                NO_SUCH_FILE_OR_DIRECTORY: \"No such file or directory\",\n                NO_SUCH_FILE: \"No such file\",\n                NO_SUCH_DIRECTORY: \"No such directory\",\n                FILE_OR_DIRECTORY_EXISTS: \"File or directory exists\",\n                IS_A_DIRECTORY: \"Is a directory\",\n                NOT_A_DIRECTORY: \"Not a directory\",\n                PERMISSION_DENIED: \"Permission denied\",\n                OTHER: \"Other\"\n            };\n            /**\n * Create a non-fatal file system error object\n *\n * For fatal errors do not use this. Throw an error instead.\n * @param  {string} fsErrorType  file system error type\n * @param  {string} [message=''] optional metadata for developers about the error\n * @return {object}              internal error object\n */ exports1.fsErrorType = fsErrorType;\n            var makeError = function makeError(fsErrorType) {\n                var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n                return {\n                    source: \"fs\",\n                    type: fsErrorType,\n                    message: message\n                };\n            };\n            exports1.makeError = makeError;\n        /***/ },\n        /***/ \"./src/fs/index.js\": /*!*************************!*\\\n  !*** ./src/fs/index.js ***!\n  \\*************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_507287__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = void 0;\n            var DirOp = _interopRequireWildcard(__nested_webpack_require_507287__(/*! ./operations-with-permissions/directory-operations */ \"./src/fs/operations-with-permissions/directory-operations.js\"));\n            var FileOp = _interopRequireWildcard(__nested_webpack_require_507287__(/*! ./operations-with-permissions/file-operations */ \"./src/fs/operations-with-permissions/file-operations.js\"));\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            var _default = {\n                DirOp: DirOp,\n                FileOp: FileOp\n            };\n            exports1[\"default\"] = _default;\n            module1.exports = exports1.default;\n        /***/ },\n        /***/ \"./src/fs/operations-with-permissions/directory-operations.js\": /*!********************************************************************!*\\\n  !*** ./src/fs/operations-with-permissions/directory-operations.js ***!\n  \\********************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_510710__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.renameDirectory = exports1.deleteDirectory = exports1.copyDirectory = exports1.addDirectory = exports1.listDirectoryFolders = exports1.listDirectoryFiles = exports1.listDirectory = exports1.hasDirectory = void 0;\n            var DirectoryOperations = _interopRequireWildcard(__nested_webpack_require_510710__(/*! fs/operations/directory-operations */ \"./src/fs/operations/directory-operations.js\"));\n            var PermissionUtil = _interopRequireWildcard(__nested_webpack_require_510710__(/*! fs/util/permission-util */ \"./src/fs/util/permission-util.js\"));\n            var _fsError = __nested_webpack_require_510710__(/*! fs/fs-error */ \"./src/fs/fs-error.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            /**\n * Adds modification permissions to directory operations by wrapping\n * directory operations\n */ var makeDirectoryOperationPermissionError = function makeDirectoryOperationPermissionError() {\n                var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Cannot modify directory\";\n                return {\n                    err: (0, _fsError.makeError)(_fsError.fsErrorType.PERMISSION_DENIED, message)\n                };\n            };\n            var hasDirectory = function hasDirectory() {\n                return DirectoryOperations.hasDirectory.apply(DirectoryOperations, arguments);\n            };\n            exports1.hasDirectory = hasDirectory;\n            var listDirectory = function listDirectory() {\n                return DirectoryOperations.listDirectory.apply(DirectoryOperations, arguments);\n            };\n            exports1.listDirectory = listDirectory;\n            var listDirectoryFiles = function listDirectoryFiles() {\n                return DirectoryOperations.listDirectoryFiles.apply(DirectoryOperations, arguments);\n            };\n            exports1.listDirectoryFiles = listDirectoryFiles;\n            var listDirectoryFolders = function listDirectoryFolders() {\n                return DirectoryOperations.listDirectoryFolders.apply(DirectoryOperations, arguments);\n            };\n            exports1.listDirectoryFolders = listDirectoryFolders;\n            var addDirectory = function addDirectory(fs, path) {\n                if (!PermissionUtil.canModifyPath(fs, path)) {\n                    return makeDirectoryOperationPermissionError();\n                }\n                for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n                    args[_key - 2] = arguments[_key];\n                }\n                return DirectoryOperations.addDirectory.apply(DirectoryOperations, [\n                    fs,\n                    path\n                ].concat(args));\n            };\n            exports1.addDirectory = addDirectory;\n            var copyDirectory = function copyDirectory(fs, srcPath, destPath) {\n                if (!PermissionUtil.canModifyPath(fs, srcPath)) {\n                    return makeDirectoryOperationPermissionError(\"Cannot modify source directory\");\n                }\n                if (!PermissionUtil.canModifyPath(fs, destPath)) {\n                    return makeDirectoryOperationPermissionError(\"Cannot modify dest directory\");\n                }\n                for(var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++){\n                    args[_key2 - 3] = arguments[_key2];\n                }\n                return DirectoryOperations.copyDirectory.apply(DirectoryOperations, [\n                    fs,\n                    srcPath,\n                    destPath\n                ].concat(args));\n            };\n            exports1.copyDirectory = copyDirectory;\n            var deleteDirectory = function deleteDirectory(fs, path) {\n                if (!PermissionUtil.canModifyPath(fs, path)) {\n                    return makeDirectoryOperationPermissionError();\n                }\n                for(var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){\n                    args[_key3 - 2] = arguments[_key3];\n                }\n                return DirectoryOperations.deleteDirectory.apply(DirectoryOperations, [\n                    fs,\n                    path\n                ].concat(args));\n            };\n            exports1.deleteDirectory = deleteDirectory;\n            var renameDirectory = function renameDirectory(fs, currentPath, newPath) {\n                if (!PermissionUtil.canModifyPath(fs, currentPath)) {\n                    return makeDirectoryOperationPermissionError(\"Cannot modify current path\");\n                }\n                if (!PermissionUtil.canModifyPath(fs, newPath)) {\n                    return makeDirectoryOperationPermissionError(\"Cannot modify renamed path\");\n                }\n                return DirectoryOperations.renameDirectory(fs, currentPath, newPath);\n            };\n            exports1.renameDirectory = renameDirectory;\n        /***/ },\n        /***/ \"./src/fs/operations-with-permissions/file-operations.js\": /*!***************************************************************!*\\\n  !*** ./src/fs/operations-with-permissions/file-operations.js ***!\n  \\***************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_518412__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.deleteFile = exports1.copyFile = exports1.writeFile = exports1.readFile = exports1.hasFile = void 0;\n            var PermissionUtil = _interopRequireWildcard(__nested_webpack_require_518412__(/*! fs/util/permission-util */ \"./src/fs/util/permission-util.js\"));\n            var FileOperations = _interopRequireWildcard(__nested_webpack_require_518412__(/*! fs/operations/file-operations */ \"./src/fs/operations/file-operations.js\"));\n            var _fsError = __nested_webpack_require_518412__(/*! fs/fs-error */ \"./src/fs/fs-error.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            /**\n * Adds modification permissions to file operations by wrapping\n * file operations\n */ var makeFileOperationPermissionError = function makeFileOperationPermissionError() {\n                var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Cannot modify file\";\n                return {\n                    err: (0, _fsError.makeError)(_fsError.fsErrorType.PERMISSION_DENIED, message)\n                };\n            };\n            var hasFile = function hasFile() {\n                return FileOperations.hasFile.apply(FileOperations, arguments);\n            };\n            exports1.hasFile = hasFile;\n            var readFile = function readFile() {\n                return FileOperations.readFile.apply(FileOperations, arguments);\n            };\n            exports1.readFile = readFile;\n            var writeFile = function writeFile(fs, filePath) {\n                if (!PermissionUtil.canModifyPath(fs, filePath)) {\n                    return makeFileOperationPermissionError();\n                }\n                for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n                    args[_key - 2] = arguments[_key];\n                }\n                return FileOperations.writeFile.apply(FileOperations, [\n                    fs,\n                    filePath\n                ].concat(args));\n            };\n            exports1.writeFile = writeFile;\n            var copyFile = function copyFile(fs, sourcePath, destPath) {\n                if (!PermissionUtil.canModifyPath(fs, sourcePath)) {\n                    return makeFileOperationPermissionError(\"Cannot modify source file\");\n                }\n                if (!PermissionUtil.canModifyPath(fs, destPath)) {\n                    return makeFileOperationPermissionError(\"Cannot modify destination file\");\n                }\n                return FileOperations.copyFile(fs, sourcePath, destPath);\n            };\n            exports1.copyFile = copyFile;\n            var deleteFile = function deleteFile(fs, filePath) {\n                if (!PermissionUtil.canModifyPath(fs, filePath)) {\n                    return makeFileOperationPermissionError();\n                }\n                return FileOperations.deleteFile(fs, filePath);\n            };\n            exports1.deleteFile = deleteFile;\n        /***/ },\n        /***/ \"./src/fs/operations/base-operations.js\": /*!**********************************************!*\\\n  !*** ./src/fs/operations/base-operations.js ***!\n  \\**********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_524007__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.remove = exports1.add = void 0;\n            var GlobUtil = _interopRequireWildcard(__nested_webpack_require_524007__(/*! fs/util/glob-util */ \"./src/fs/util/glob-util.js\"));\n            var DirOp = _interopRequireWildcard(__nested_webpack_require_524007__(/*! fs/operations/directory-operations */ \"./src/fs/operations/directory-operations.js\"));\n            var FileOp = _interopRequireWildcard(__nested_webpack_require_524007__(/*! fs/operations/file-operations */ \"./src/fs/operations/file-operations.js\"));\n            var PathUtil = _interopRequireWildcard(__nested_webpack_require_524007__(/*! fs/util/path-util */ \"./src/fs/util/path-util.js\"));\n            var _fsError = __nested_webpack_require_524007__(/*! fs/fs-error */ \"./src/fs/fs-error.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _createForOfIteratorHelper(o) {\n                if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n                    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n                        var i = 0;\n                        var F = function F() {};\n                        return {\n                            s: F,\n                            n: function n() {\n                                if (i >= o.length) return {\n                                    done: true\n                                };\n                                return {\n                                    done: false,\n                                    value: o[i++]\n                                };\n                            },\n                            e: function e(_e) {\n                                throw _e;\n                            },\n                            f: F\n                        };\n                    }\n                    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                }\n                var it, normalCompletion = true, didErr = false, err;\n                return {\n                    s: function s() {\n                        it = o[Symbol.iterator]();\n                    },\n                    n: function n() {\n                        var step = it.next();\n                        normalCompletion = step.done;\n                        return step;\n                    },\n                    e: function e(_e2) {\n                        didErr = true;\n                        err = _e2;\n                    },\n                    f: function f() {\n                        try {\n                            if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n                        } finally{\n                            if (didErr) throw err;\n                        }\n                    }\n                };\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(n);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            /**\n * Adds a file or directory to a path\n * @param {Map}     fs                     file system\n * @param {string}  pathToAdd              path to add the file or directory to\n * @param {string}  fsElementToAdd         file or directory map\n * @param {Boolean} [addParentPaths=false] true, if path parent directories should\n *                                         be made (if they don't exist)\n * @return {object}                        file system or error\n */ var add = function add(fs, pathToAdd, fsElementToAdd) {\n                var addParentPaths = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n                if (fs.has(pathToAdd)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.FILE_OR_DIRECTORY_EXISTS)\n                    };\n                }\n                var parentPaths = PathUtil.getPathBreadCrumbs(pathToAdd).slice(0, -1);\n                var _iterator = _createForOfIteratorHelper(parentPaths), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var parentPath = _step.value;\n                        if (FileOp.hasFile(fs, parentPath)) {\n                            return {\n                                err: (0, _fsError.makeError)(_fsError.fsErrorType.NOT_A_DIRECTORY, \"Cannot add path to a file: \".concat(parentPath))\n                            };\n                        }\n                        if (!fs.has(parentPath) && !addParentPaths) {\n                            return {\n                                err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_DIRECTORY, \"Parent directory does not exist: \".concat(parentPath))\n                            };\n                        }\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                var addedDirectoryFs = fs.set(pathToAdd, fsElementToAdd);\n                return {\n                    fs: addParentPaths ? DirOp.fillGaps(addedDirectoryFs) : addedDirectoryFs\n                };\n            };\n            /**\n * Removes a file or directory from a path\n * @param  {Map}     fs                                  file system\n * @param  {string}  pathToRemove                        removes the path\n * @param  {Boolean} [isNonEmptyDirectoryRemovable=true] true if non-empty paths can be removed\n * @return {object}                                      file system or error\n */ exports1.add = add;\n            var remove = function remove(fs, pathToRemove) {\n                var isNonEmptyDirectoryRemovable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n                if (!fs.has(pathToRemove)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_FILE_OR_DIRECTORY)\n                    };\n                }\n                var childPathPattern = pathToRemove === \"/\" ? \"/**\" : \"\".concat(pathToRemove, \"/**\");\n                var childPaths = GlobUtil.globPaths(fs, childPathPattern);\n                if (!isNonEmptyDirectoryRemovable && !childPaths.isEmpty()) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.DIRECTORY_NOT_EMPTY)\n                    };\n                }\n                return {\n                    fs: fs.removeAll(childPaths.concat(pathToRemove))\n                };\n            };\n            exports1.remove = remove;\n        /***/ },\n        /***/ \"./src/fs/operations/directory-operations.js\": /*!***************************************************!*\\\n  !*** ./src/fs/operations/directory-operations.js ***!\n  \\***************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_533902__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.renameDirectory = exports1.deleteDirectory = exports1.copyDirectory = exports1.addDirectory = exports1.listDirectory = exports1.listDirectoryFolders = exports1.listDirectoryFiles = exports1.hasDirectory = exports1.fillGaps = void 0;\n            var FileUtil = _interopRequireWildcard(__nested_webpack_require_533902__(/*! fs/util/file-util */ \"./src/fs/util/file-util.js\"));\n            var GlobUtil = _interopRequireWildcard(__nested_webpack_require_533902__(/*! fs/util/glob-util */ \"./src/fs/util/glob-util.js\"));\n            var PathUtil = _interopRequireWildcard(__nested_webpack_require_533902__(/*! fs/util/path-util */ \"./src/fs/util/path-util.js\"));\n            var BaseOp = _interopRequireWildcard(__nested_webpack_require_533902__(/*! fs/operations/base-operations */ \"./src/fs/operations/base-operations.js\"));\n            var _fsError = __nested_webpack_require_533902__(/*! fs/fs-error */ \"./src/fs/fs-error.js\");\n            var _fileOperations = __nested_webpack_require_533902__(/*! fs/operations/file-operations */ \"./src/fs/operations/file-operations.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _slicedToArray(arr, i) {\n                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _iterableToArrayLimit(arr, i) {\n                if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _e = undefined;\n                try {\n                    for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function _arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function _createForOfIteratorHelper(o) {\n                if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n                    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n                        var i = 0;\n                        var F = function F() {};\n                        return {\n                            s: F,\n                            n: function n() {\n                                if (i >= o.length) return {\n                                    done: true\n                                };\n                                return {\n                                    done: false,\n                                    value: o[i++]\n                                };\n                            },\n                            e: function e(_e2) {\n                                throw _e2;\n                            },\n                            f: F\n                        };\n                    }\n                    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                }\n                var it, normalCompletion = true, didErr = false, err;\n                return {\n                    s: function s() {\n                        it = o[Symbol.iterator]();\n                    },\n                    n: function n() {\n                        var step = it.next();\n                        normalCompletion = step.done;\n                        return step;\n                    },\n                    e: function e(_e3) {\n                        didErr = true;\n                        err = _e3;\n                    },\n                    f: function f() {\n                        try {\n                            if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n                        } finally{\n                            if (didErr) throw err;\n                        }\n                    }\n                };\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(n);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            var onlyFilesFilter = function onlyFilesFilter(fs) {\n                return function(path) {\n                    return FileUtil.isFile(fs.get(path));\n                };\n            };\n            var onlyDirectoriesFilter = function onlyDirectoriesFilter(fs) {\n                return function(path) {\n                    return FileUtil.isDirectory(fs.get(path));\n                };\n            };\n            /**\n * Fill file system gaps with empty directories.\n *\n * EXPLANATION:\n * A file system can be left in a state where there the directory structure\n * is incomplete and there may be illogical gaps in the structure after\n * manually creating or editing the file system.\n *\n * For example, we might have a file system that looks like this after manually\n * adding a directory of '/a/b/c':\n *\n * {\n *  '/': {..}\n *  '/a/b/c': {..}\n * }\n *\n * As a result of the operation, we're missing directories of '/a' and '/a/b'.\n * We can fill these missing directory gaps to get a properly formed directory\n * structure:\n *\n * {\n *  '/': {..}\n *  '/a': {..}\n *  '/a/b': {..}\n *  '/a/b/c': {..}\n * }\n * @param  {Map}    fs   file system with gaps in directory structure\n * @return {Map}         file system without directory gaps\n */ var fillGaps = function fillGaps(fs) {\n                var emptyDirectory = FileUtil.makeDirectory();\n                var directoryGapPaths = fs.keySeq() // sequence of paths\n                .flatMap(function(path) {\n                    return PathUtil.getPathBreadCrumbs(path);\n                }).filter(function(path) {\n                    return !fs.has(path);\n                });\n                return fs.withMutations(function(fs) {\n                    var _iterator = _createForOfIteratorHelper(directoryGapPaths), _step;\n                    try {\n                        for(_iterator.s(); !(_step = _iterator.n()).done;){\n                            var directoryGapPath = _step.value;\n                            fs.set(directoryGapPath, emptyDirectory);\n                        }\n                    } catch (err) {\n                        _iterator.e(err);\n                    } finally{\n                        _iterator.f();\n                    }\n                });\n            };\n            /**\n * Check if a directory exists in the file system\n * @param  {Map}     fs   file system\n * @param  {string}  path path to check if is a directory\n * @return {boolean}      true, if the directory exists\n */ exports1.fillGaps = fillGaps;\n            var hasDirectory = function hasDirectory(fs, path) {\n                return fs.has(path) && FileUtil.isDirectory(fs.get(path));\n            };\n            /**\n * Creates a list of file names\n * @param  {Map}    fs   file system\n * @param  {string} path directory path to list files in\n * @return {object}      list of file names or an error\n */ exports1.hasDirectory = hasDirectory;\n            var listDirectoryFiles = function listDirectoryFiles(fs, path) {\n                if ((0, _fileOperations.hasFile)(fs, path)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.FILE_EXISTS, \"File exists at path\")\n                    };\n                }\n                if (!hasDirectory(fs, path)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_DIRECTORY, \"Cannot list files in non-existent directory\")\n                    };\n                }\n                ;\n                var filesPattern = path === \"/\" ? \"/*\" : \"\".concat(path, \"/*\");\n                return {\n                    list: GlobUtil.captureGlobPaths(fs, filesPattern, onlyFilesFilter(fs))\n                };\n            };\n            /**\n * Creates a list of folder names inside the current directory.\n * @param  {Map}    fs   file system\n * @param  {string} path path to list directories in\n * @return {object}      list of directories or an error\n */ exports1.listDirectoryFiles = listDirectoryFiles;\n            var listDirectoryFolders = function listDirectoryFolders(fs, path) {\n                var isTrailingSlashAppended = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n                if ((0, _fileOperations.hasFile)(fs, path)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.FILE_EXISTS, \"File exists at path\")\n                    };\n                }\n                if (!hasDirectory(fs, path)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_DIRECTORY, \"Cannot list folders in non-existent directory\")\n                    };\n                }\n                ;\n                var foldersPattern = path === \"/\" ? \"/*\" : \"\".concat(path, \"/*\");\n                var folderNames = GlobUtil.captureGlobPaths(fs, foldersPattern, onlyDirectoriesFilter(fs));\n                if (isTrailingSlashAppended) {\n                    return {\n                        list: folderNames.map(function(folderName) {\n                            return \"\".concat(folderName, \"/\");\n                        })\n                    };\n                }\n                return {\n                    list: folderNames\n                };\n            };\n            /**\n * Lists files and folders in a directory\n * @param  {Map}     fs                                      file system\n * @param  {string}  path                                    directory path to list files and folders in\n * @param  {boolean} [addTrailingSlash=true]                 add a / to the end of folder names\n * @return {object}                                          file system or an error\n */ exports1.listDirectoryFolders = listDirectoryFolders;\n            var listDirectory = function listDirectory(fs, path) {\n                var addTrailingSlash = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n                var _listDirectoryFiles = listDirectoryFiles(fs, path), listFileErr = _listDirectoryFiles.err, fileList = _listDirectoryFiles.list;\n                var _listDirectoryFolders = listDirectoryFolders(fs, path, addTrailingSlash), listFolderErr = _listDirectoryFolders.err, folderList = _listDirectoryFolders.list;\n                if (listFileErr || listFolderErr) {\n                    return {\n                        err: listFileErr ? listFileErr : listFolderErr\n                    };\n                }\n                ;\n                return {\n                    list: fileList.concat(folderList)\n                };\n            };\n            /**\n * Adds a directory to the file system\n * @param {Map}     fs                           file system\n * @param {string}  path                         path to add a directory to\n * @param {Map}     dir                          directory\n * @param {boolean} [isReplaceExistingDir=false] whether a directory can be overwritten if it already exists\n * @return {object}                              file system or an error\n */ exports1.listDirectory = listDirectory;\n            var addDirectory = function addDirectory(fs, path, dir) {\n                var addParentPaths = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n                if ((0, _fileOperations.hasFile)(fs, PathUtil.getPathParent(path))) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.FILE_EXISTS, \"File exists at path\")\n                    };\n                }\n                return BaseOp.add(fs, path, dir, addParentPaths);\n            };\n            /**\n * Private helper function implementing rules for replacing a source path (the path\n * we're copying from) with a destination path (the path we're copying to). Note\n * that in our file system:\n * - A file cannot overwrite a directory,\n * - a directory cannot overwrite a file, and\n * - a file/directory can overwrite a file/directory.\n * @param  {Map}       fs      file system\n * @param  {Sequence}  pathSeq sequence of source and destination paths\n * @return {Boolean}           true, if a source path can replace a destination path\n */ exports1.addDirectory = addDirectory;\n            var isPathTypeMatching = function isPathTypeMatching(fs, pathSeq) {\n                var _iterator2 = _createForOfIteratorHelper(pathSeq), _step2;\n                try {\n                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                        var _step2$value = _slicedToArray(_step2.value, 2), srcPath = _step2$value[0], destPath = _step2$value[1];\n                        if (fs.has(destPath)) {\n                            if ((0, _fileOperations.hasFile)(fs, srcPath) && hasDirectory(fs, destPath)) {\n                                // Cannot overwrite a file with a directory\n                                return false;\n                            } else if (hasDirectory(fs, srcPath) && (0, _fileOperations.hasFile)(fs, destPath)) {\n                                // Cannot overwrite a directory with a file\n                                return false;\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _iterator2.e(err);\n                } finally{\n                    _iterator2.f();\n                }\n                return true;\n            };\n            /**\n * Copies a directory (and all directories included inside that directory)\n * from a source directory to a destination directory\n *\n * If the destination doesn't exist, it can be created.\n *\n * The source and destination must be a directory and not a file.\n * @param  {Map}     fs                             file system\n * @param  {string}  srcPath                        directory path to copy from\n * @param  {string}  destPath                       directory path to copy to\n * @return {object}                                 file system or an error\n */ var copyDirectory = function copyDirectory(fs, srcPath, destPath) {\n                var overwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n                if (!hasDirectory(fs, srcPath)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_DIRECTORY, \"Source directory does not exist\")\n                    };\n                }\n                ;\n                if (!hasDirectory(fs, destPath)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_DIRECTORY, \"Destination directory does not exist\")\n                    };\n                }\n                ;\n                var srcChildPattern = srcPath === \"/\" ? \"/**\" : \"\".concat(srcPath, \"/**\");\n                var srcPaths = GlobUtil.globPaths(fs, srcChildPattern);\n                var srcSubPaths = GlobUtil.captureGlobPaths(fs, srcChildPattern);\n                var destPaths = srcSubPaths.map(function(path) {\n                    return path === \"/\" ? destPath : \"\".concat(destPath, \"/\").concat(path);\n                });\n                if (!isPathTypeMatching(fs, srcPaths.zip(destPaths))) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.OTHER, \"Cannot overwrite a directory with file OR a file with directory\")\n                    };\n                }\n                return {\n                    fs: fs.withMutations(function(newFs) {\n                        var _iterator3 = _createForOfIteratorHelper(srcPaths.zip(destPaths)), _step3;\n                        try {\n                            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                                var _step3$value = _slicedToArray(_step3.value, 2), _srcPath = _step3$value[0], _destPath = _step3$value[1];\n                                if (!fs.has(_destPath) || overwrite) {\n                                    newFs.set(_destPath, fs.get(_srcPath));\n                                }\n                            }\n                        } catch (err) {\n                            _iterator3.e(err);\n                        } finally{\n                            _iterator3.f();\n                        }\n                    })\n                };\n            };\n            /**\n * Remove a directory from a file system\n * @param  {Map}     fs                                   file system\n * @param  {string}  pathToDelete                         directory path to delete\n * @param  {Boolean} [isNonEmptyDirectoryRemovable=false] whether directories with files in them can be removed\n * @return {object}                                       file system or an error\n */ exports1.copyDirectory = copyDirectory;\n            var deleteDirectory = function deleteDirectory(fs, pathToDelete) {\n                var isNonEmptyDirectoryRemovable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                if ((0, _fileOperations.hasFile)(fs, pathToDelete)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.FILE_EXISTS, \"File exists at path\")\n                    };\n                }\n                if (!hasDirectory(fs, pathToDelete)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_DIRECTORY, \"No such directory: \".concat(pathToDelete))\n                    };\n                }\n                ;\n                return BaseOp.remove(fs, pathToDelete, isNonEmptyDirectoryRemovable);\n            };\n            /**\n * Rename a directory\n * @param  {Map}    fs          file system\n * @param  {string} currentPath directory path to rename (and hence remove)\n * @param  {string} newPath     path to place the renamed directory\n * @return {object}             file system or an error\n */ exports1.deleteDirectory = deleteDirectory;\n            var renameDirectory = function renameDirectory(fs, currentPath, newPath) {\n                var _copyDirectory = copyDirectory(fs, currentPath, newPath, true), err = _copyDirectory.err, copiedFS = _copyDirectory.fs;\n                if (err) {\n                    return {\n                        err: err\n                    };\n                }\n                return deleteDirectory(copiedFS, currentPath, true);\n            };\n            exports1.renameDirectory = renameDirectory;\n        /***/ },\n        /***/ \"./src/fs/operations/file-operations.js\": /*!**********************************************!*\\\n  !*** ./src/fs/operations/file-operations.js ***!\n  \\**********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_556307__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.deleteFile = exports1.copyFile = exports1.writeFile = exports1.readFile = exports1.hasFile = void 0;\n            var PathUtil = _interopRequireWildcard(__nested_webpack_require_556307__(/*! fs/util/path-util */ \"./src/fs/util/path-util.js\"));\n            var BaseOp = _interopRequireWildcard(__nested_webpack_require_556307__(/*! fs/operations/base-operations */ \"./src/fs/operations/base-operations.js\"));\n            var _fileUtil = __nested_webpack_require_556307__(/*! fs/util/file-util */ \"./src/fs/util/file-util.js\");\n            var _directoryOperations = __nested_webpack_require_556307__(/*! fs/operations/directory-operations */ \"./src/fs/operations/directory-operations.js\");\n            var _fsError = __nested_webpack_require_556307__(/*! fs/fs-error */ \"./src/fs/fs-error.js\");\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            /**\n * Checks whether a file exists\n * @param  {Map}     fs       file system\n * @param  {string}  dirPath  directory of the file to check for existence\n * @param  {string}  fileName file name to check for existence\n * @return {Boolean}          true, if the file exists\n */ var hasFile = function hasFile(fs, filePath) {\n                if (fs.has(filePath)) {\n                    var possibleFile = fs.get(filePath);\n                    return (0, _fileUtil.isFile)(possibleFile);\n                }\n                return false;\n            };\n            /**\n * Get a file from the file system\n * @param  {Map}    fs       file system\n * @param  {string} filePath path to file to read\n * @return {object}          file system or an error\n */ exports1.hasFile = hasFile;\n            var readFile = function readFile(fs, filePath) {\n                if ((0, _directoryOperations.hasDirectory)(fs, filePath)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.IS_A_DIRECTORY)\n                    };\n                }\n                if (!hasFile(fs, filePath)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_FILE)\n                    };\n                }\n                return {\n                    file: fs.get(filePath)\n                };\n            };\n            /**\n * Write a new file to the file system\n * @param  {Map}     fs                            file system\n * @param  {string}  filePath                      path to new file\n * @param  {Map}     file                          the new file\n * @return {object}                                file system or an error\n */ exports1.readFile = readFile;\n            var writeFile = function writeFile(fs, filePath, file) {\n                return BaseOp.add(fs, filePath, file);\n            };\n            /**\n * Copies a file from a source directory to a destination directory\n * @param  {Map}    fs           file system\n * @param  {string} sourcePath   path to source file (to copy from)\n * @param  {string} destPath     path to destination file (to copy to)\n * @return {object}              file system or an error\n */ exports1.writeFile = writeFile;\n            var copyFile = function copyFile(fs, sourcePath, destPath) {\n                if (!hasFile(fs, sourcePath)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_FILE, \"Source file does not exist\")\n                    };\n                }\n                var pathParent = PathUtil.getPathParent(destPath);\n                if (!(0, _directoryOperations.hasDirectory)(fs, pathParent)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_DIRECTORY, \"Destination directory does not exist\")\n                    };\n                }\n                if ((0, _directoryOperations.hasDirectory)(fs, destPath)) {\n                    // Copying file to directory without specifying the filename explicitly\n                    var sourceFileName = PathUtil.getLastPathPart(sourcePath);\n                    destPath = destPath === \"/\" ? \"/\".concat(sourceFileName) : \"\".concat(destPath, \"/\").concat(sourceFileName);\n                }\n                return {\n                    fs: fs.set(destPath, fs.get(sourcePath))\n                };\n            };\n            /**\n * Removes a file from the file system\n * @param  {Map}    fs       file system\n * @param  {string} filePath path to the file to delete\n * @return {object}          file system or an error\n */ exports1.copyFile = copyFile;\n            var deleteFile = function deleteFile(fs, filePath) {\n                if ((0, _directoryOperations.hasDirectory)(fs, filePath)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.IS_A_DIRECTORY)\n                    };\n                }\n                if (!hasFile(fs, filePath)) {\n                    return {\n                        err: (0, _fsError.makeError)(_fsError.fsErrorType.NO_SUCH_FILE)\n                    };\n                }\n                return BaseOp.remove(fs, filePath);\n            };\n            exports1.deleteFile = deleteFile;\n        /***/ },\n        /***/ \"./src/fs/util/file-util.js\": /*!**********************************!*\\\n  !*** ./src/fs/util/file-util.js ***!\n  \\**********************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_563999__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.makeDirectory = exports1.makeFile = exports1.isDirectory = exports1.isFile = void 0;\n            var _immutable = __nested_webpack_require_563999__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            function ownKeys(object, enumerableOnly) {\n                var keys = Object.keys(object);\n                if (Object.getOwnPropertySymbols) {\n                    var symbols = Object.getOwnPropertySymbols(object);\n                    if (enumerableOnly) symbols = symbols.filter(function(sym) {\n                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n                    });\n                    keys.push.apply(keys, symbols);\n                }\n                return keys;\n            }\n            function _objectSpread(target) {\n                for(var i = 1; i < arguments.length; i++){\n                    var source = arguments[i] != null ? arguments[i] : {};\n                    if (i % 2) {\n                        ownKeys(Object(source), true).forEach(function(key) {\n                            _defineProperty(target, key, source[key]);\n                        });\n                    } else if (Object.getOwnPropertyDescriptors) {\n                        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n                    } else {\n                        ownKeys(Object(source)).forEach(function(key) {\n                            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n                        });\n                    }\n                }\n                return target;\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            /**\n * Checks if a JavaScript object is a file object\n * @param  {object}  json potential file\n * @return {boolean}      whether the object conforms to the file schema\n */ var isFile = function isFile(map) {\n                return map.has(\"content\");\n            };\n            /**\n * Checks if a JavaScript object is a directory object\n * @param  {object}  json potential directory\n * @return {boolean}      whether the object conforms to the directory schema\n */ exports1.isFile = isFile;\n            var isDirectory = function isDirectory(map) {\n                return !map.has(\"content\");\n            };\n            /**\n * Makes an file conforming to the file schema\n * @param  {object} content  content of the file\n * @return {object}          new file\n */ exports1.isDirectory = isDirectory;\n            var makeFile = function makeFile() {\n                var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n                var metadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                return (0, _immutable.fromJS)(_objectSpread({\n                    content: content\n                }, metadata));\n            };\n            /**\n * Makes an directory conforming to the directory schema\n * @param  {object} children child directories or files\n * @return {object}          new directory\n */ exports1.makeFile = makeFile;\n            var makeDirectory = function makeDirectory() {\n                var metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                return (0, _immutable.fromJS)(_objectSpread({}, metadata));\n            };\n            exports1.makeDirectory = makeDirectory;\n        /***/ },\n        /***/ \"./src/fs/util/glob-util.js\": /*!**********************************!*\\\n  !*** ./src/fs/util/glob-util.js ***!\n  \\**********************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_568205__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.captureGlobPaths = exports1.globPaths = exports1.globSeq = exports1.glob = void 0;\n            var _minimatch = _interopRequireDefault(__nested_webpack_require_568205__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\"));\n            var _minimatchCapture = _interopRequireDefault(__nested_webpack_require_568205__(/*! minimatch-capture */ \"./node_modules/minimatch-capture/index.js\"));\n            var _immutable = __nested_webpack_require_568205__(/*! immutable */ \"./node_modules/immutable/dist/immutable.es.js\");\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            var GLOB_OPTIONS = {\n                dot: true\n            };\n            var glob = function glob(str, globPattern) {\n                return (0, _minimatch[\"default\"])(str, globPattern, GLOB_OPTIONS);\n            };\n            exports1.glob = glob;\n            var globSeq = function globSeq(seq, globPattern) {\n                return seq.filter(function(path) {\n                    return (0, _minimatch[\"default\"])(path, globPattern, GLOB_OPTIONS);\n                });\n            };\n            exports1.globSeq = globSeq;\n            var globPaths = function globPaths(fs, globPattern) {\n                return globSeq(fs.keySeq(), globPattern);\n            };\n            exports1.globPaths = globPaths;\n            var captureGlobPaths = function captureGlobPaths(fs, globPattern) {\n                var filterCondition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function(path) {\n                    return true;\n                };\n                return fs.keySeq().reduce(function(captures, path) {\n                    if (filterCondition(path)) {\n                        var pathCaptures = (0, _minimatchCapture[\"default\"])(path, globPattern, GLOB_OPTIONS);\n                        if (pathCaptures) {\n                            return captures.concat(pathCaptures);\n                        }\n                    }\n                    return captures;\n                }, (0, _immutable.List)());\n            };\n            exports1.captureGlobPaths = captureGlobPaths;\n        /***/ },\n        /***/ \"./src/fs/util/path-util.js\": /*!**********************************!*\\\n  !*** ./src/fs/util/path-util.js ***!\n  \\**********************************/ /*! no static exports found */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.toAbsolutePath = exports1.splitFilePath = exports1.getLastPathPart = exports1.getPathParent = exports1.getPathBreadCrumbs = exports1.toPath = exports1.toPathParts = exports1.isAbsPath = exports1.removeTrailingSeparator = exports1.isTrailingPath = void 0;\n            function _createForOfIteratorHelper(o) {\n                if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n                    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n                        var i = 0;\n                        var F = function F() {};\n                        return {\n                            s: F,\n                            n: function n() {\n                                if (i >= o.length) return {\n                                    done: true\n                                };\n                                return {\n                                    done: false,\n                                    value: o[i++]\n                                };\n                            },\n                            e: function e(_e) {\n                                throw _e;\n                            },\n                            f: F\n                        };\n                    }\n                    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                }\n                var it, normalCompletion = true, didErr = false, err;\n                return {\n                    s: function s() {\n                        it = o[Symbol.iterator]();\n                    },\n                    n: function n() {\n                        var step = it.next();\n                        normalCompletion = step.done;\n                        return step;\n                    },\n                    e: function e(_e2) {\n                        didErr = true;\n                        err = _e2;\n                    },\n                    f: function f() {\n                        try {\n                            if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n                        } finally{\n                            if (didErr) throw err;\n                        }\n                    }\n                };\n            }\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _toArray(arr) {\n                return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(n);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n            }\n            function _arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            /**\n * Tests if a path is a trailing path.\n *\n * A trailing path ends with a trailing slash (/) and excludes the root\n * directory (/).\n * @param  {string}  path path with or without a trailing slash\n * @return {Boolean}      true, if the path is a trailing path\n */ var isTrailingPath = function isTrailingPath(path) {\n                return path.endsWith(\"/\") && path !== \"/\";\n            };\n            /**\n * Removes a trailing slash (/) from a path\n * @param  {string} path path with or without a trailing /\n * @return {string}      path without trailing /\n */ exports1.isTrailingPath = isTrailingPath;\n            var removeTrailingSeparator = function removeTrailingSeparator(path) {\n                if (path.endsWith(\"/\") && path !== \"/\") {\n                    return path.slice(0, -1);\n                }\n                return path;\n            };\n            /**\n * Tests if a path is absolute\n * @param  {string}  path\n * @return {boolean}\n */ exports1.removeTrailingSeparator = removeTrailingSeparator;\n            var isAbsPath = function isAbsPath(path) {\n                return path.startsWith(\"/\");\n            };\n            /**\n * Converts a path to an ordered array of folders and files.\n *\n * Example: Parts of '/a/b/c/e.txt' has parts of ['/', 'a', 'b', 'c', 'e.txt']\n *\n * A relative path splits parts at /. An absolute path splits at / and also\n * considers the root directory (/) as a part of the path.\n * @param  {string} path [description]\n * @return {array}       list of path parts\n */ exports1.isAbsPath = isAbsPath;\n            var toPathParts = function toPathParts(path) {\n                if (path === \"/\") {\n                    return [\n                        \"/\"\n                    ];\n                }\n                ;\n                path = removeTrailingSeparator(path);\n                var pathParts = path.split(\"/\");\n                if (isAbsPath(path)) {\n                    var _pathParts = _toArray(pathParts), nonRootPathParts = _pathParts.slice(1);\n                    return [\n                        \"/\"\n                    ].concat(_toConsumableArray(nonRootPathParts));\n                }\n                return pathParts;\n            };\n            /**\n * Converts path parts back to a path\n * @param  {array} pathParts path parts\n * @return {string}          path\n */ exports1.toPathParts = toPathParts;\n            var toPath = function toPath(pathParts) {\n                if (pathParts[0] === \"/\") {\n                    // absolute path\n                    var _pathParts2 = _toArray(pathParts), nonRootPathParts = _pathParts2.slice(1);\n                    return \"/\".concat(nonRootPathParts.join(\"/\"));\n                }\n                return pathParts.join(\"/\");\n            };\n            /**\n * Find breadcrumb paths, i.e. all paths that need to be walked to get to\n * the specified path\n * Example: /a/b/c will have breadcrumb paths of '/', '/a', '/a/b', '/a/b/c'\n * @param  {string} path path to a directory\n * @return {array}       list of paths that lead up to a path\n */ exports1.toPath = toPath;\n            var getPathBreadCrumbs = function getPathBreadCrumbs(path) {\n                var pathParts = toPathParts(path);\n                if (pathParts.length <= 1) {\n                    return [\n                        \"/\"\n                    ];\n                }\n                var _pathParts3 = _toArray(pathParts), secondPathPart = _pathParts3[1], pathPartsWithoutRoot = _pathParts3.slice(2);\n                return pathPartsWithoutRoot.reduce(function(breadCrumbs, pathPart) {\n                    var previousBreadCrumb = breadCrumbs[breadCrumbs.length - 1];\n                    return [].concat(_toConsumableArray(breadCrumbs), [\n                        \"\".concat(previousBreadCrumb, \"/\").concat(pathPart)\n                    ]);\n                }, [\n                    \"/\",\n                    \"/\".concat(secondPathPart)\n                ]);\n            };\n            /**\n * Removes the file name from the end of a file path, returning the path to the\n * directory of the file\n * @param  {string} filePath path which ends with a file name\n * @return {string}          directory path\n */ exports1.getPathBreadCrumbs = getPathBreadCrumbs;\n            var getPathParent = function getPathParent(filePath) {\n                if (filePath === \"/\") {\n                    return \"/\";\n                }\n                var pathParts = toPathParts(filePath); // converts path string to array\n                var pathPartsWithoutFileName = pathParts.slice(0, -1); // removes last element of array\n                return toPath(pathPartsWithoutFileName);\n            };\n            /**\n * Extracts the file name from the end of the file path\n * @param  {string} filePath path which ends with a file name\n * @return {string}          file name from the path\n */ exports1.getPathParent = getPathParent;\n            var getLastPathPart = function getLastPathPart(filePath) {\n                var pathParts = toPathParts(filePath); // converts path string to array\n                return pathParts[pathParts.length - 1];\n            };\n            /**\n * Extracts the file name and directory path from a file path\n * @param  {string} filePath path which ends with a file name\n * @return {object}          object with directory and file name\n */ exports1.getLastPathPart = getLastPathPart;\n            var splitFilePath = function splitFilePath(filePath) {\n                return {\n                    \"dirPath\": getPathParent(filePath),\n                    \"fileName\": getLastPathPart(filePath)\n                };\n            };\n            /**\n * Converts a relative path to an absolute path\n * @param  {string} relativePath\n * @param  {string} cwd          current working directory\n * @return {string}              absolute path\n */ exports1.splitFilePath = splitFilePath;\n            var GO_UP = \"..\";\n            var CURRENT_DIR = \".\";\n            var isStackAtRootDirectory = function isStackAtRootDirectory(stack) {\n                return stack.length === 1 && stack[0] === \"/\";\n            };\n            var toAbsolutePath = function toAbsolutePath(relativePath, cwd) {\n                relativePath = removeTrailingSeparator(relativePath);\n                var pathStack = isAbsPath(relativePath) ? [] : toPathParts(cwd);\n                var _iterator = _createForOfIteratorHelper(toPathParts(relativePath)), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var pathPart = _step.value;\n                        if (pathPart === GO_UP) {\n                            if (!isStackAtRootDirectory(pathStack)) {\n                                pathStack.pop();\n                            }\n                        } else if (pathPart !== CURRENT_DIR) {\n                            pathStack.push(pathPart);\n                        }\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                return toPath(pathStack);\n            };\n            exports1.toAbsolutePath = toAbsolutePath;\n        /***/ },\n        /***/ \"./src/fs/util/permission-util.js\": /*!****************************************!*\\\n  !*** ./src/fs/util/permission-util.js ***!\n  \\****************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_582771__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.canModifyPath = void 0;\n            var PathUtil = _interopRequireWildcard(__nested_webpack_require_582771__(/*! fs/util/path-util */ \"./src/fs/util/path-util.js\"));\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            function _createForOfIteratorHelper(o) {\n                if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n                    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n                        var i = 0;\n                        var F = function F() {};\n                        return {\n                            s: F,\n                            n: function n() {\n                                if (i >= o.length) return {\n                                    done: true\n                                };\n                                return {\n                                    done: false,\n                                    value: o[i++]\n                                };\n                            },\n                            e: function e(_e) {\n                                throw _e;\n                            },\n                            f: F\n                        };\n                    }\n                    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                }\n                var it, normalCompletion = true, didErr = false, err;\n                return {\n                    s: function s() {\n                        it = o[Symbol.iterator]();\n                    },\n                    n: function n() {\n                        var step = it.next();\n                        normalCompletion = step.done;\n                        return step;\n                    },\n                    e: function e(_e2) {\n                        didErr = true;\n                        err = _e2;\n                    },\n                    f: function f() {\n                        try {\n                            if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n                        } finally{\n                            if (didErr) throw err;\n                        }\n                    }\n                };\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(n);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            var DEFAULT_PERMISSION = true;\n            /**\n * Checks if a single path can be modified by checking the 'canModify' key held\n * in the path.\n *\n * This does NOT check parents of the path.\n * @param  {Map}     fs   file system\n * @param  {string}  path path to check for modification permission\n * @return {Boolean}      true, if a single path can be modified\n */ var isModificationAllowed = function isModificationAllowed(fs, path) {\n                var directory = fs.get(path, null);\n                if (directory) {\n                    var canModify = directory.get(\"canModify\", DEFAULT_PERMISSION);\n                    if (!canModify) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            /**\n * Checks if a path and its parents can be modified.\n * @param  {Map}     fs   file systems\n * @param  {String}  path path to a directory or file\n * @return {Boolean}      true, if the path and its parents can be modified\n */ var canModifyPath = function canModifyPath(fs, path) {\n                var breadCrumbPaths = PathUtil.getPathBreadCrumbs(path);\n                var _iterator = _createForOfIteratorHelper(breadCrumbPaths), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var breadCrumbPath = _step.value;\n                        if (!isModificationAllowed(fs, breadCrumbPath)) {\n                            return false;\n                        }\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                return true;\n            };\n            exports1.canModifyPath = canModifyPath;\n        /***/ },\n        /***/ \"./src/index.js\": /*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_590222__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            Object.defineProperty(exports1, \"Emulator\", {\n                enumerable: true,\n                get: function get() {\n                    return _emulator[\"default\"];\n                }\n            });\n            Object.defineProperty(exports1, \"HistoryKeyboardPlugin\", {\n                enumerable: true,\n                get: function get() {\n                    return _HistoryKeyboardPlugin[\"default\"];\n                }\n            });\n            Object.defineProperty(exports1, \"EmulatorState\", {\n                enumerable: true,\n                get: function get() {\n                    return _emulatorState.EmulatorState;\n                }\n            });\n            Object.defineProperty(exports1, \"CommandMapping\", {\n                enumerable: true,\n                get: function get() {\n                    return _emulatorState.CommandMapping;\n                }\n            });\n            Object.defineProperty(exports1, \"EnvironmentVariables\", {\n                enumerable: true,\n                get: function get() {\n                    return _emulatorState.EnvironmentVariables;\n                }\n            });\n            Object.defineProperty(exports1, \"FileSystem\", {\n                enumerable: true,\n                get: function get() {\n                    return _emulatorState.FileSystem;\n                }\n            });\n            Object.defineProperty(exports1, \"History\", {\n                enumerable: true,\n                get: function get() {\n                    return _emulatorState.History;\n                }\n            });\n            Object.defineProperty(exports1, \"Outputs\", {\n                enumerable: true,\n                get: function get() {\n                    return _emulatorState.Outputs;\n                }\n            });\n            Object.defineProperty(exports1, \"OutputFactory\", {\n                enumerable: true,\n                get: function get() {\n                    return _emulatorOutput.OutputFactory;\n                }\n            });\n            Object.defineProperty(exports1, \"OutputType\", {\n                enumerable: true,\n                get: function get() {\n                    return _emulatorOutput.OutputType;\n                }\n            });\n            Object.defineProperty(exports1, \"DirOp\", {\n                enumerable: true,\n                get: function get() {\n                    return _fs.DirOp;\n                }\n            });\n            Object.defineProperty(exports1, \"FileOp\", {\n                enumerable: true,\n                get: function get() {\n                    return _fs.FileOp;\n                }\n            });\n            Object.defineProperty(exports1, \"OptionParser\", {\n                enumerable: true,\n                get: function get() {\n                    return _parser.OptionParser;\n                }\n            });\n            Object.defineProperty(exports1, \"defaultCommandMapping\", {\n                enumerable: true,\n                get: function get() {\n                    return _commands[\"default\"];\n                }\n            });\n            var _emulator = _interopRequireDefault(__nested_webpack_require_590222__(/*! emulator */ \"./src/emulator/index.js\"));\n            var _HistoryKeyboardPlugin = _interopRequireDefault(__nested_webpack_require_590222__(/*! emulator/plugins/HistoryKeyboardPlugin */ \"./src/emulator/plugins/HistoryKeyboardPlugin.js\"));\n            var _emulatorState = __nested_webpack_require_590222__(/*! emulator-state */ \"./src/emulator-state/index.js\");\n            var _emulatorOutput = __nested_webpack_require_590222__(/*! emulator-output */ \"./src/emulator-output/index.js\");\n            var _fs = __nested_webpack_require_590222__(/*! fs */ \"./src/fs/index.js\");\n            var _parser = __nested_webpack_require_590222__(/*! parser */ \"./src/parser/index.js\");\n            var _commands = _interopRequireDefault(__nested_webpack_require_590222__(/*! commands */ \"./src/commands/index.js\"));\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n        /***/ },\n        /***/ \"./src/parser/command-parser.js\": /*!**************************************!*\\\n  !*** ./src/parser/command-parser.js ***!\n  \\**************************************/ /*! no static exports found */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.parseCommands = void 0;\n            function _toArray(arr) {\n                return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(n);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n            }\n            function _arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            /**\n * Removes excess whitespace (> 1 space) from edges of string and inside string.\n * @param  {string} str string\n * @return {string}     string without > 1 space of whitespace\n */ var removeExcessWhiteSpace = function removeExcessWhiteSpace(str) {\n                return str.trim().replace(/\\s\\s+/g, \" \");\n            };\n            /**\n * Places the command name and each following argument into a list\n * @param  {string} command sh command\n * @return {array}          command name and arguments (if any)\n */ var toCommandParts = function toCommandParts(command) {\n                return removeExcessWhiteSpace(command).split(/\\s/);\n            };\n            /**\n * Creates a list of commands split into the command name and arguments\n * @param  {string} commands command input\n * @return {array}           list of parsed command\n */ var parseCommands = function parseCommands(commands) {\n                return commands.split(/&&|;/) // split command delimiters: `&&` and `;`\n                .map(function(command) {\n                    return toCommandParts(command);\n                }).map(function(_ref) {\n                    var _ref2 = _toArray(_ref), commandName = _ref2[0], commandOptions = _ref2.slice(1);\n                    return {\n                        commandName: commandName,\n                        commandOptions: commandOptions\n                    };\n                });\n            };\n            exports1.parseCommands = parseCommands;\n            var _default = parseCommands;\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ \"./src/parser/index.js\": /*!*****************************!*\\\n  !*** ./src/parser/index.js ***!\n  \\*****************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_598220__) {\n            \"use strict\";\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = void 0;\n            var OptionParser = _interopRequireWildcard(__nested_webpack_require_598220__(/*! parser/option-parser */ \"./src/parser/option-parser.js\"));\n            function _getRequireWildcardCache() {\n                if (typeof WeakMap !== \"function\") return null;\n                var cache = new WeakMap();\n                _getRequireWildcardCache = function _getRequireWildcardCache() {\n                    return cache;\n                };\n                return cache;\n            }\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                }\n                if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n                    return {\n                        \"default\": obj\n                    };\n                }\n                var cache = _getRequireWildcardCache();\n                if (cache && cache.has(obj)) {\n                    return cache.get(obj);\n                }\n                var newObj = {};\n                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n                for(var key in obj){\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                        if (desc && (desc.get || desc.set)) {\n                            Object.defineProperty(newObj, key, desc);\n                        } else {\n                            newObj[key] = obj[key];\n                        }\n                    }\n                }\n                newObj[\"default\"] = obj;\n                if (cache) {\n                    cache.set(obj, newObj);\n                }\n                return newObj;\n            }\n            var _default = {\n                OptionParser: OptionParser\n            };\n            exports1[\"default\"] = _default;\n            module1.exports = exports1.default;\n        /***/ },\n        /***/ \"./src/parser/option-parser.js\": /*!*************************************!*\\\n  !*** ./src/parser/option-parser.js ***!\n  \\*************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_601264__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1[\"default\"] = exports1.parseOptions = void 0;\n            var _getOptions = _interopRequireDefault(__nested_webpack_require_601264__(/*! get-options */ \"./node_modules/get-options/index.js\"));\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    \"default\": obj\n                };\n            }\n            /**\n * Creates an options object with bindings based on optDefs\n * @param  {string} commandOptions string representation of command arguments\n * @param  {object} optDef         see get-options documentation for schema details\n * @return {object}                options object\n */ var parseOptions = function parseOptions(commandOptions, optDef) {\n                return (0, _getOptions[\"default\"])(commandOptions, optDef, {\n                    noAliasPropagation: \"first-only\"\n                });\n            };\n            exports1.parseOptions = parseOptions;\n            var _default = parseOptions;\n            exports1[\"default\"] = _default;\n        /***/ },\n        /***/ 0: /*!****************************!*\\\n  !*** multi ./src/index.js ***!\n  \\****************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_602649__) {\n            module1.exports = __nested_webpack_require_602649__(/*! /Users/turtle/Documents/Github/javascript-terminal/src/index.js */ \"./src/index.js\");\n        /***/ }\n    });\n}); //# sourceMappingURL=terminal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamF2YXNjcmlwdC10ZXJtaW5hbC10dXJ0bGUvbGliL3Rlcm1pbmFsLmpzIiwibWFwcGluZ3MiOiI7QUFBQyxVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdEO1NBQ2IsRUFLeUJBO0FBQy9CLEdBQUcsUUFBTTtJQUNULE9BQWdCLE1BQUgsR0FBSSxTQUFTSyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQyw4QkFBbUJBLENBQUNDLFFBQVE7WUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQUU7Z0JBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDUCxPQUFPO1lBQ3JELE1BQU0sR0FBSztZQUNYLE1BQU0sR0FBSyxrREFBa0Q7WUFDN0QsTUFBTSxHQUFLLElBQUlDLFVBQVNJLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7Z0JBQ3JELE1BQU0sR0FBTUMsR0FBR0Q7Z0JBQ2YsTUFBTSxHQUFNRSxHQUFHO2dCQUNmLE1BQU0sR0FBTVQsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtJLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNULFFBQU9ELE9BQU8sRUFBRUMsU0FBUUEsUUFBT0QsT0FBTyxFQUFFTSw4QkFBbUJBO1lBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1lBQ3ZDLE1BQU0sR0FBS0wsUUFBT1EsQ0FBQyxHQUFHO1lBQ3RCLE1BQU0sR0FDTixNQUFNLEdBQUssbUNBQW1DO1lBQzlDLE1B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LXRlcm1pbmFsLXR1cnRsZS9saWIvdGVybWluYWwuanM/YjAzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIlRlcm1pbmFsXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlRlcm1pbmFsXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlRlcm1pbmFsXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9iYWxhbmNlZC1tYXRjaC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9iYWxhbmNlZC1tYXRjaC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBiYWxhbmNlZDtcbmZ1bmN0aW9uIGJhbGFuY2VkKGEsIGIsIHN0cikge1xuICBpZiAoYSBpbnN0YW5jZW9mIFJlZ0V4cCkgYSA9IG1heWJlTWF0Y2goYSwgc3RyKTtcbiAgaWYgKGIgaW5zdGFuY2VvZiBSZWdFeHApIGIgPSBtYXliZU1hdGNoKGIsIHN0cik7XG5cbiAgdmFyIHIgPSByYW5nZShhLCBiLCBzdHIpO1xuXG4gIHJldHVybiByICYmIHtcbiAgICBzdGFydDogclswXSxcbiAgICBlbmQ6IHJbMV0sXG4gICAgcHJlOiBzdHIuc2xpY2UoMCwgclswXSksXG4gICAgYm9keTogc3RyLnNsaWNlKHJbMF0gKyBhLmxlbmd0aCwgclsxXSksXG4gICAgcG9zdDogc3RyLnNsaWNlKHJbMV0gKyBiLmxlbmd0aClcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWF5YmVNYXRjaChyZWcsIHN0cikge1xuICB2YXIgbSA9IHN0ci5tYXRjaChyZWcpO1xuICByZXR1cm4gbSA/IG1bMF0gOiBudWxsO1xufVxuXG5iYWxhbmNlZC5yYW5nZSA9IHJhbmdlO1xuZnVuY3Rpb24gcmFuZ2UoYSwgYiwgc3RyKSB7XG4gIHZhciBiZWdzLCBiZWcsIGxlZnQsIHJpZ2h0LCByZXN1bHQ7XG4gIHZhciBhaSA9IHN0ci5pbmRleE9mKGEpO1xuICB2YXIgYmkgPSBzdHIuaW5kZXhPZihiLCBhaSArIDEpO1xuICB2YXIgaSA9IGFpO1xuXG4gIGlmIChhaSA+PSAwICYmIGJpID4gMCkge1xuICAgIGJlZ3MgPSBbXTtcbiAgICBsZWZ0ID0gc3RyLmxlbmd0aDtcblxuICAgIHdoaWxlIChpID49IDAgJiYgIXJlc3VsdCkge1xuICAgICAgaWYgKGkgPT0gYWkpIHtcbiAgICAgICAgYmVncy5wdXNoKGkpO1xuICAgICAgICBhaSA9IHN0ci5pbmRleE9mKGEsIGkgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoYmVncy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXN1bHQgPSBbIGJlZ3MucG9wKCksIGJpIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZWcgPSBiZWdzLnBvcCgpO1xuICAgICAgICBpZiAoYmVnIDwgbGVmdCkge1xuICAgICAgICAgIGxlZnQgPSBiZWc7XG4gICAgICAgICAgcmlnaHQgPSBiaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpID0gc3RyLmluZGV4T2YoYiwgaSArIDEpO1xuICAgICAgfVxuXG4gICAgICBpID0gYWkgPCBiaSAmJiBhaSA+PSAwID8gYWkgOiBiaTtcbiAgICB9XG5cbiAgICBpZiAoYmVncy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IFsgbGVmdCwgcmlnaHQgXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2JyYWNlLWV4cGFuc2lvbi9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYnJhY2UtZXhwYW5zaW9uL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29uY2F0TWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29uY2F0LW1hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvbmNhdC1tYXAvaW5kZXguanNcIik7XG52YXIgYmFsYW5jZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBiYWxhbmNlZC1tYXRjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL2JhbGFuY2VkLW1hdGNoL2luZGV4LmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cGFuZFRvcDtcblxudmFyIGVzY1NsYXNoID0gJ1xcMFNMQVNIJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY09wZW4gPSAnXFwwT1BFTicrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NDbG9zZSA9ICdcXDBDTE9TRScrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NDb21tYSA9ICdcXDBDT01NQScrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NQZXJpb2QgPSAnXFwwUEVSSU9EJytNYXRoLnJhbmRvbSgpKydcXDAnO1xuXG5mdW5jdGlvbiBudW1lcmljKHN0cikge1xuICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCkgPT0gc3RyXG4gICAgPyBwYXJzZUludChzdHIsIDEwKVxuICAgIDogc3RyLmNoYXJDb2RlQXQoMCk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnXFxcXFxcXFwnKS5qb2luKGVzY1NsYXNoKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxceycpLmpvaW4oZXNjT3BlbilcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXH0nKS5qb2luKGVzY0Nsb3NlKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcLCcpLmpvaW4oZXNjQ29tbWEpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFwuJykuam9pbihlc2NQZXJpb2QpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdChlc2NTbGFzaCkuam9pbignXFxcXCcpXG4gICAgICAgICAgICAuc3BsaXQoZXNjT3Blbikuam9pbigneycpXG4gICAgICAgICAgICAuc3BsaXQoZXNjQ2xvc2UpLmpvaW4oJ30nKVxuICAgICAgICAgICAgLnNwbGl0KGVzY0NvbW1hKS5qb2luKCcsJylcbiAgICAgICAgICAgIC5zcGxpdChlc2NQZXJpb2QpLmpvaW4oJy4nKTtcbn1cblxuXG4vLyBCYXNpY2FsbHkganVzdCBzdHIuc3BsaXQoXCIsXCIpLCBidXQgaGFuZGxpbmcgY2FzZXNcbi8vIHdoZXJlIHdlIGhhdmUgbmVzdGVkIGJyYWNlZCBzZWN0aW9ucywgd2hpY2ggc2hvdWxkIGJlXG4vLyB0cmVhdGVkIGFzIGluZGl2aWR1YWwgbWVtYmVycywgbGlrZSB7YSx7YixjfSxkfVxuZnVuY3Rpb24gcGFyc2VDb21tYVBhcnRzKHN0cikge1xuICBpZiAoIXN0cilcbiAgICByZXR1cm4gWycnXTtcblxuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcblxuICBpZiAoIW0pXG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnLCcpO1xuXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIGJvZHkgPSBtLmJvZHk7XG4gIHZhciBwb3N0ID0gbS5wb3N0O1xuICB2YXIgcCA9IHByZS5zcGxpdCgnLCcpO1xuXG4gIHBbcC5sZW5ndGgtMV0gKz0gJ3snICsgYm9keSArICd9JztcbiAgdmFyIHBvc3RQYXJ0cyA9IHBhcnNlQ29tbWFQYXJ0cyhwb3N0KTtcbiAgaWYgKHBvc3QubGVuZ3RoKSB7XG4gICAgcFtwLmxlbmd0aC0xXSArPSBwb3N0UGFydHMuc2hpZnQoKTtcbiAgICBwLnB1c2guYXBwbHkocCwgcG9zdFBhcnRzKTtcbiAgfVxuXG4gIHBhcnRzLnB1c2guYXBwbHkocGFydHMsIHApO1xuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuZnVuY3Rpb24gZXhwYW5kVG9wKHN0cikge1xuICBpZiAoIXN0cilcbiAgICByZXR1cm4gW107XG5cbiAgLy8gSSBkb24ndCBrbm93IHdoeSBCYXNoIDQuMyBkb2VzIHRoaXMsIGJ1dCBpdCBkb2VzLlxuICAvLyBBbnl0aGluZyBzdGFydGluZyB3aXRoIHt9IHdpbGwgaGF2ZSB0aGUgZmlyc3QgdHdvIGJ5dGVzIHByZXNlcnZlZFxuICAvLyBidXQgKm9ubHkqIGF0IHRoZSB0b3AgbGV2ZWwsIHNvIHt9LGF9YiB3aWxsIG5vdCBleHBhbmQgdG8gYW55dGhpbmcsXG4gIC8vIGJ1dCBhe30sYn1jIHdpbGwgYmUgZXhwYW5kZWQgdG8gW2F9YyxhYmNdLlxuICAvLyBPbmUgY291bGQgYXJndWUgdGhhdCB0aGlzIGlzIGEgYnVnIGluIEJhc2gsIGJ1dCBzaW5jZSB0aGUgZ29hbCBvZlxuICAvLyB0aGlzIG1vZHVsZSBpcyB0byBtYXRjaCBCYXNoJ3MgcnVsZXMsIHdlIGVzY2FwZSBhIGxlYWRpbmcge31cbiAgaWYgKHN0ci5zdWJzdHIoMCwgMikgPT09ICd7fScpIHtcbiAgICBzdHIgPSAnXFxcXHtcXFxcfScgKyBzdHIuc3Vic3RyKDIpO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZChlc2NhcGVCcmFjZXMoc3RyKSwgdHJ1ZSkubWFwKHVuZXNjYXBlQnJhY2VzKTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoZSkge1xuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gZW1icmFjZShzdHIpIHtcbiAgcmV0dXJuICd7JyArIHN0ciArICd9Jztcbn1cbmZ1bmN0aW9uIGlzUGFkZGVkKGVsKSB7XG4gIHJldHVybiAvXi0/MFxcZC8udGVzdChlbCk7XG59XG5cbmZ1bmN0aW9uIGx0ZShpLCB5KSB7XG4gIHJldHVybiBpIDw9IHk7XG59XG5mdW5jdGlvbiBndGUoaSwgeSkge1xuICByZXR1cm4gaSA+PSB5O1xufVxuXG5mdW5jdGlvbiBleHBhbmQoc3RyLCBpc1RvcCkge1xuICB2YXIgZXhwYW5zaW9ucyA9IFtdO1xuXG4gIHZhciBtID0gYmFsYW5jZWQoJ3snLCAnfScsIHN0cik7XG4gIGlmICghbSB8fCAvXFwkJC8udGVzdChtLnByZSkpIHJldHVybiBbc3RyXTtcblxuICB2YXIgaXNOdW1lcmljU2VxdWVuY2UgPSAvXi0/XFxkK1xcLlxcLi0/XFxkKyg/OlxcLlxcLi0/XFxkKyk/JC8udGVzdChtLmJvZHkpO1xuICB2YXIgaXNBbHBoYVNlcXVlbmNlID0gL15bYS16QS1aXVxcLlxcLlthLXpBLVpdKD86XFwuXFwuLT9cXGQrKT8kLy50ZXN0KG0uYm9keSk7XG4gIHZhciBpc1NlcXVlbmNlID0gaXNOdW1lcmljU2VxdWVuY2UgfHwgaXNBbHBoYVNlcXVlbmNlO1xuICB2YXIgaXNPcHRpb25zID0gbS5ib2R5LmluZGV4T2YoJywnKSA+PSAwO1xuICBpZiAoIWlzU2VxdWVuY2UgJiYgIWlzT3B0aW9ucykge1xuICAgIC8vIHthfSxifVxuICAgIGlmIChtLnBvc3QubWF0Y2goLywuKlxcfS8pKSB7XG4gICAgICBzdHIgPSBtLnByZSArICd7JyArIG0uYm9keSArIGVzY0Nsb3NlICsgbS5wb3N0O1xuICAgICAgcmV0dXJuIGV4cGFuZChzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gW3N0cl07XG4gIH1cblxuICB2YXIgbjtcbiAgaWYgKGlzU2VxdWVuY2UpIHtcbiAgICBuID0gbS5ib2R5LnNwbGl0KC9cXC5cXC4vKTtcbiAgfSBlbHNlIHtcbiAgICBuID0gcGFyc2VDb21tYVBhcnRzKG0uYm9keSk7XG4gICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyB4e3thLGJ9fXkgPT0+IHh7YX15IHh7Yn15XG4gICAgICBuID0gZXhwYW5kKG5bMF0sIGZhbHNlKS5tYXAoZW1icmFjZSk7XG4gICAgICBpZiAobi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIHBvc3QgPSBtLnBvc3QubGVuZ3RoXG4gICAgICAgICAgPyBleHBhbmQobS5wb3N0LCBmYWxzZSlcbiAgICAgICAgICA6IFsnJ107XG4gICAgICAgIHJldHVybiBwb3N0Lm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIG0ucHJlICsgblswXSArIHA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG4gaXMgdGhlIHBhcnRzLCBhbmQgd2Uga25vdyBpdCdzIG5vdCBhIGNvbW1hIHNldFxuICAvLyB3aXRoIGEgc2luZ2xlIGVudHJ5LlxuXG4gIC8vIG5vIG5lZWQgdG8gZXhwYW5kIHByZSwgc2luY2UgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSBmcmVlIG9mIGJyYWNlLXNldHNcbiAgdmFyIHByZSA9IG0ucHJlO1xuICB2YXIgcG9zdCA9IG0ucG9zdC5sZW5ndGhcbiAgICA/IGV4cGFuZChtLnBvc3QsIGZhbHNlKVxuICAgIDogWycnXTtcblxuICB2YXIgTjtcblxuICBpZiAoaXNTZXF1ZW5jZSkge1xuICAgIHZhciB4ID0gbnVtZXJpYyhuWzBdKTtcbiAgICB2YXIgeSA9IG51bWVyaWMoblsxXSk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoblswXS5sZW5ndGgsIG5bMV0ubGVuZ3RoKVxuICAgIHZhciBpbmNyID0gbi5sZW5ndGggPT0gM1xuICAgICAgPyBNYXRoLmFicyhudW1lcmljKG5bMl0pKVxuICAgICAgOiAxO1xuICAgIHZhciB0ZXN0ID0gbHRlO1xuICAgIHZhciByZXZlcnNlID0geSA8IHg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGluY3IgKj0gLTE7XG4gICAgICB0ZXN0ID0gZ3RlO1xuICAgIH1cbiAgICB2YXIgcGFkID0gbi5zb21lKGlzUGFkZGVkKTtcblxuICAgIE4gPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSB4OyB0ZXN0KGksIHkpOyBpICs9IGluY3IpIHtcbiAgICAgIHZhciBjO1xuICAgICAgaWYgKGlzQWxwaGFTZXF1ZW5jZSkge1xuICAgICAgICBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICAgICAgaWYgKGMgPT09ICdcXFxcJylcbiAgICAgICAgICBjID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjID0gU3RyaW5nKGkpO1xuICAgICAgICBpZiAocGFkKSB7XG4gICAgICAgICAgdmFyIG5lZWQgPSB3aWR0aCAtIGMubGVuZ3RoO1xuICAgICAgICAgIGlmIChuZWVkID4gMCkge1xuICAgICAgICAgICAgdmFyIHogPSBuZXcgQXJyYXkobmVlZCArIDEpLmpvaW4oJzAnKTtcbiAgICAgICAgICAgIGlmIChpIDwgMClcbiAgICAgICAgICAgICAgYyA9ICctJyArIHogKyBjLnNsaWNlKDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBjID0geiArIGM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBOLnB1c2goYyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIE4gPSBjb25jYXRNYXAobiwgZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGV4cGFuZChlbCwgZmFsc2UpIH0pO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBOLmxlbmd0aDsgaisrKSB7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb3N0Lmxlbmd0aDsgaysrKSB7XG4gICAgICB2YXIgZXhwYW5zaW9uID0gcHJlICsgTltqXSArIHBvc3Rba107XG4gICAgICBpZiAoIWlzVG9wIHx8IGlzU2VxdWVuY2UgfHwgZXhwYW5zaW9uKVxuICAgICAgICBleHBhbnNpb25zLnB1c2goZXhwYW5zaW9uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwYW5zaW9ucztcbn1cblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvbmNhdC1tYXAvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb25jYXQtbWFwL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeHMsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSBmbih4c1tpXSwgaSk7XG4gICAgICAgIGlmIChpc0FycmF5KHgpKSByZXMucHVzaC5hcHBseShyZXMsIHgpO1xuICAgICAgICBlbHNlIHJlcy5wdXNoKHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9nZXQtb3B0aW9ucy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9nZXQtb3B0aW9ucy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIENsYXNzIHVzZWQgaW50ZXJuYWxseSB0byByZXByZXNlbnQgaW5kaXZpZHVhbCBvcHRpb25zLlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIE9wdGlvbntcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgT3B0aW9uIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gbmFtZXMgLSBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBuYW1lcy5cblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhcmFtcyAtIEFyZ3VtZW50cyB3aGljaCB0aGUgb3B0aW9uIGV4cGVjdHMuXG5cdCAqIEBleGFtcGxlIG5ldyBPcHRpb24oXCItbCwgLS1sb25nLWxpc3QsIC0tbGVuZ3RoXCIsIFwiPG51bT4gPHR5cGU+XCIpXG5cdCAqIEBleGFtcGxlIG5ldyBPcHRpb24oXCItZSwgLS1leGVjXCIsIFwiW251bV0gW3R5cGVdXCIpXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IobmFtZXMsIHBhcmFtcyA9IFwiXCIpe1xuXHRcdHRoaXMuc2hvcnROYW1lcyA9IFtdO1xuXHRcdHRoaXMubG9uZ05hbWVzICA9IFtdO1xuXHRcdHRoaXMucGFyYW1zICAgICA9IFtdO1xuXHRcdHRoaXMudmFsdWVzICAgICA9IFtdO1xuXHRcdFxuXHRcdHRoaXMuZGVmaW5lTmFtZXMobmFtZXMpO1xuXHRcdHRoaXMuZGVmaW5lUGFyYW1zKHBhcmFtcyk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRGVzY3JpYmUgdGhlIG5hbWVzIHVzZWQgdG8gcmVmZXIgdG8gdGhpcyBvcHRpb24uXG5cdCAqIFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gaW5wdXRcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRkZWZpbmVOYW1lcyhpbnB1dCl7XG5cdFx0aWYoIUFycmF5LmlzQXJyYXkoaW5wdXQpKVxuXHRcdFx0aW5wdXQgPSBTdHJpbmcoaW5wdXQpLnNwbGl0KC8sL2cpO1xuXHRcdFxuXHRcdGZvcihsZXQgbmFtZSBvZiBpbnB1dCl7XG5cdFx0XHRuYW1lID0gbmFtZS50cmltKCk7XG5cdFx0XHQvXi0oW15cXHMtXSkkLy50ZXN0KG5hbWUpXG5cdFx0XHRcdD8gdGhpcy5zaG9ydE5hbWVzLnB1c2goUmVnRXhwLmxhc3RQYXJlbilcblx0XHRcdFx0OiB0aGlzLmxvbmdOYW1lcy5wdXNoKG5hbWUucmVwbGFjZSgvXi0rLywgXCJcIikpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBEZXNjcmliZSB0aGUgcGFyYW1ldGVycyB0aGlzIG9wdGlvbiBhY2NlcHRzL2V4cGVjdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBpbnB1dFxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGRlZmluZVBhcmFtcyhpbnB1dCl7XG5cdFx0aW5wdXQgPSBBcnJheS5pc0FycmF5KGlucHV0KVxuXHRcdFx0PyBpbnB1dC5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIilcblx0XHRcdDogU3RyaW5nKGlucHV0KS50cmltKCkuc3BsaXQoL1xccysvZyk7XG5cdFx0XG5cdFx0Ly8gU3RyaXAgYW55IGVuY2xvc2luZyBicmFja2V0cyBhZGRlZCBmb3IgcmVhZGFiaWxpdHlcblx0XHRpbnB1dCA9IGlucHV0Lm1hcChwYXJhbSA9PiBwYXJhbS5yZXBsYWNlKC9ePCguKz8pPiR8XlxcWyguKz8pXFxdJHxeXFwoKC4rPylcXCkkL2dtLCAoLi4uYXJncykgPT5cblx0XHRcdGFyZ3Muc2xpY2UoMSwgNCkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcIikpKTtcblx0XHRcblx0XHRmb3IoY29uc3QgcGFyYW0gb2YgaW5wdXQpe1xuXHRcdFx0aWYoIXBhcmFtKSBjb250aW51ZTtcblx0XHRcdGNvbnN0IFssIG5hbWUsIHBhdHRlcm49XCIuK1wiXSA9IHBhcmFtLm1hdGNoKC9eKFtePV0rKSg/Oj0oLispPyk/JC8pO1xuXHRcdFx0dGhpcy5wYXJhbXMucHVzaCh7bmFtZSwgcGF0dGVybn0pO1xuXHRcdFx0aWYoL1xcLnszfSQvLnRlc3QobmFtZSkpXG5cdFx0XHRcdHRoaXMudmFyaWFkaWMgPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBQYXR0ZXJuIHRvIG1hdGNoIG9wdGlvbiB3aGVuIGV4cHJlc3NlZCBpbiBidW5kbGVkIHNob3J0LWZvcm0uXG5cdCAqXG5cdCAqIEByZWFkb25seVxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXQgYnVuZGxlUGF0dGVybigpe1xuXHRcdFxuXHRcdC8vIFVzZSBhIGNhY2hlZCByZXN1bHQgaWYgcG9zc2libGVcblx0XHRpZih0aGlzLl9idW5kbGVQYXR0ZXJuKVxuXHRcdFx0cmV0dXJuIHRoaXMuX2J1bmRsZVBhdHRlcm47XG5cdFx0XG5cdFx0Y29uc3QgcGFyYW0gPSB0aGlzLnBhcmFtcy5tYXAocGFyYW0gPT4gYCgke3BhcmFtLnBhdHRlcm59KT9gKS5qb2luKFwiXCIpO1xuXHRcdGNvbnN0IG5hbWVzID0gMSA9PT0gdGhpcy5zaG9ydE5hbWVzLmxlbmd0aFxuXHRcdFx0PyB0aGlzLnNob3J0TmFtZXNbMF1cblx0XHRcdDogYFske3RoaXMuc2hvcnROYW1lcy5qb2luKFwiXCIpfV1gO1xuXHRcdHJldHVybiAodGhpcy5fYnVuZGxlUGF0dGVybiA9IG5hbWVzICsgcGFyYW0pO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIE51bWJlciBvZiBwYXJhbWV0ZXJzIHRoaXMgb3B0aW9uIGV4cGVjdHMvYWNjZXB0cy5cblx0ICpcblx0ICogQHJlYWRvbmx5XG5cdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IGFyaXR5KCl7XG5cdFx0cmV0dXJuIHRoaXMucGFyYW1zID8gdGhpcy5wYXJhbXMubGVuZ3RoIDogMDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBcnJheSBvZiBuYW1lcyByZWNvZ25pc2VkIGJ5IHRoZSBvcHRpb24sIGJvdGggbG9uZyBhbmQgc2hvcnQuXG5cdCAqXG5cdCAqIEByZWFkb25seVxuXHQgKiBAcHJvcGVydHkge0FycmF5fVxuXHQgKi9cblx0Z2V0IG5hbWVzKCl7XG5cdFx0cmV0dXJuIHRoaXMuc2hvcnROYW1lcy5jb25jYXQodGhpcy5sb25nTmFtZXMpO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhlIG9wdGlvbiBjYW4gYWNjZXB0IGFub3RoZXIgcGFyYW1ldGVyLlxuXHQgKlxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHByb3BlcnR5IHtCb29sZWFufVxuXHQgKi9cblx0Z2V0IGNhbkNvbGxlY3QoKXtcblx0XHRyZXR1cm4gISEodGhpcy52YXJpYWRpYyB8fCB0aGlzLnZhbHVlcy5sZW5ndGggPCB0aGlzLnBhcmFtcy5sZW5ndGgpO1xuXHR9XG59XG5cblxuXG4vKipcbiAqIEJveCBhIHZhbHVlIGluc2lkZSBhbiB7QGxpbmsgQXJyYXl9LCB1bmxlc3MgaXQgYWxyZWFkeSBpcyBvbmUuXG4gKlxuICogQGV4YW1wbGUgYXJyYXlpZnkoMSkgICA9PiBbMV1cbiAqIEBleGFtcGxlIGFycmF5aWZ5KFsxXSkgPT4gWzFdXG4gKiBAcGFyYW0geyp9IGlucHV0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBhcnJheWlmeShpbnB1dCl7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbn1cblxuXG4vKipcbiAqIFN0cmlwIGxlYWRpbmcgZGFzaGVzIGZyb20gYW4gb3B0aW9uIG5hbWUgYW5kIGNvbnZlcnQgaXQgdG8gY2FtZWxDYXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCAtIEFuIG9wdGlvbidzIG5hbWUsIHN1Y2ggYXMgXCItLXdyaXRlLXRvXCJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9DYW1lbENhc2UgLSBTdHJpcCBsZWFkaW5nIGRhc2hlcyBvbmx5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZm9ybWF0TmFtZShpbnB1dCwgbm9DYW1lbENhc2Upe1xuXHRpbnB1dCA9IGlucHV0LnJlcGxhY2UoL14tKy8sIFwiXCIpO1xuXHRcblx0Ly8gQ29udmVydCBrZWJhYi1jYXNlIHRvIGNhbWVsQ2FzZVxuXHRpZighbm9DYW1lbENhc2UgJiYgLy0vLnRlc3QoaW5wdXQpKVxuXHRcdGlucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oW2Etel0pLSsoW2Etel0pL2csIChfLCBhLCBiKSA9PiBhICsgYi50b1VwcGVyQ2FzZSgpKTtcblx0XG5cdHJldHVybiBpbnB1dDtcbn1cblxuXG4vKipcbiAqIFRlc3QgYSBzdHJpbmcgYWdhaW5zdCBhIGxpc3Qgb2YgcGF0dGVybnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge1N0cmluZ1tdfFJlZ0V4cFtdfSBwYXR0ZXJuc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBtYXRjaChpbnB1dCwgcGF0dGVybnMgPSBbXSl7XG5cdGlmKCFwYXR0ZXJucyB8fCAwID09PSBwYXR0ZXJucy5sZW5ndGgpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHRcblx0aW5wdXQgICAgPSBTdHJpbmcoaW5wdXQpO1xuXHRwYXR0ZXJucyA9IGFycmF5aWZ5KHBhdHRlcm5zKS5maWx0ZXIoQm9vbGVhbik7XG5cdGZvcihjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKVxuXHRcdGlmKChwYXR0ZXJuID09PSBpbnB1dCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2YgcGF0dGVybilcblx0XHR8fCAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgcGF0dGVybi50ZXN0KGlucHV0KSlcblx0XHRcdHJldHVybiB0cnVlO1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBGaWx0ZXIgZHVwbGljYXRlIHN0cmluZ3MgZnJvbSBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBpbnB1dFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdW5pcXVlU3RyaW5ncyhpbnB1dCl7XG5cdGNvbnN0IG91dHB1dCA9IHt9O1xuXHRmb3IobGV0IGkgPSAwLCBsID0gaW5wdXQubGVuZ3RoOyBpIDwgbDsgKytpKVxuXHRcdG91dHB1dFtpbnB1dFtpXV0gPSB0cnVlO1xuXHRyZXR1cm4gT2JqZWN0LmtleXMob3V0cHV0KTtcbn1cblxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGFzIGEgd2hpdGVzcGFjZS1kZWxpbWl0ZWQgbGlzdCBvZiBvcHRpb25zLFxuICogcHJlc2VydmluZyBxdW90ZWQgYW5kIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAqXG4gKiBAZXhhbXBsZSB1bnN0cmluZ2lmeShcIi0tZm9vIC0tYmFyXCIpICAgICA9PiBbXCItLWZvb1wiLCBcIi0tYmFyXCJdO1xuICogQGV4YW1wbGUgdW5zdHJpbmdpZnkoJy0tZm9vIFwiYmFyIGJhelwiJykgPT4gW1wiLS1mb29cIiwgJ1wiYmFyIGJhelwiJ107XG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1bnN0cmluZ2lmeShpbnB1dCl7XG5cdGlucHV0ID0gU3RyaW5nKGlucHV0IHx8IFwiXCIpO1xuXHRjb25zdCB0b2tlbnMgICA9IFtdO1xuXHRjb25zdCB7bGVuZ3RofSA9IGlucHV0O1xuXHRcblx0bGV0IHF1b3RlQ2hhciAgPSBcIlwiOyAgICAvLyBRdW90ZS10eXBlIGVuY2xvc2luZyBjdXJyZW50IHJlZ2lvblxuXHRsZXQgdG9rZW5EYXRhICA9IFwiXCI7ICAgIC8vIENoYXJhY3RlcnMgY3VycmVudGx5IGJlaW5nIGNvbGxlY3RlZFxuXHRsZXQgaXNFc2NhcGVkICA9IGZhbHNlOyAvLyBGbGFnIGlkZW50aWZ5aW5nIGFuIGVzY2FwZSBzZXF1ZW5jZVxuXHRcblx0Zm9yKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKXtcblx0XHRjb25zdCBjaGFyID0gaW5wdXRbaV07XG5cdFx0XG5cdFx0Ly8gUHJldmlvdXMgY2hhcmFjdGVyIHdhcyBhIGJhY2tzbGFzaFxuXHRcdGlmKGlzRXNjYXBlZCl7XG5cdFx0XHR0b2tlbkRhdGEgKz0gY2hhcjtcblx0XHRcdGlzRXNjYXBlZCA9IGZhbHNlO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFdoaXRlc3BhY2U6IHRlcm1pbmF0ZSB0b2tlbiB1bmxlc3MgcXVvdGVkXG5cdFx0aWYoIXF1b3RlQ2hhciAmJiAvWyBcXHRcXG5dLy50ZXN0KGNoYXIpKXtcblx0XHRcdHRva2VuRGF0YSAmJiB0b2tlbnMucHVzaCh0b2tlbkRhdGEpO1xuXHRcdFx0dG9rZW5EYXRhID0gXCJcIjtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRcblx0XHQvLyBCYWNrc2xhc2g6IGVzY2FwZSBuZXh0IGNoYXJhY3RlclxuXHRcdGlmKFwiXFxcXFwiID09PSBjaGFyKXtcblx0XHRcdGlzRXNjYXBlZCA9IHRydWU7XG5cdFx0XHRcblx0XHRcdC8vIFN3YWxsb3cgYmFja3NsYXNoIGlmIGl0IGVzY2FwZXMgYSBtZXRhY2hhcmFjdGVyXG5cdFx0XHRjb25zdCBuZXh0ID0gaW5wdXRbaSArIDFdO1xuXHRcdFx0aWYocXVvdGVDaGFyICYmIChxdW90ZUNoYXIgPT09IG5leHQgfHwgXCJcXFxcXCIgPT09IG5leHQpXG5cdFx0XHR8fCAhcXVvdGVDaGFyICYmIC9bLSBcXHRcXG5cXFxcJ1wiYF0vLnRlc3QobmV4dCkpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRcblx0XHQvLyBRdW90ZSBtYXJrc1xuXHRcdGVsc2UgaWYoKCFxdW90ZUNoYXIgfHwgY2hhciA9PT0gcXVvdGVDaGFyKSAmJiAvWydcImBdLy50ZXN0KGNoYXIpKXtcblx0XHRcdHF1b3RlQ2hhciA9IHF1b3RlQ2hhciA9PT0gY2hhciA/IFwiXCIgOiBjaGFyO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdFxuXHRcdHRva2VuRGF0YSArPSBjaGFyO1xuXHR9XG5cdGlmKHRva2VuRGF0YSlcblx0XHR0b2tlbnMucHVzaCh0b2tlbkRhdGEpO1xuXHRyZXR1cm4gdG9rZW5zO1xufVxuXG5cbi8qKlxuICogUGFyc2UgaW5wdXQgdXNpbmcgXCJiZXN0IGd1ZXNzXCIgbG9naWMuIENhbGxlZCB3aGVuIG5vIG9wdGRlZiBpcyBwYXNzZWQuXG4gKlxuICogRXNzZW50aWFsbHksIHRoZSBmb2xsb3dpbmcgYXNzdW1wdGlvbnMgYXJlIG1hZGUgYWJvdXQgaW5wdXQ6XG4gKlxuICogLSBBbnl0aGluZyBiZWdpbm5pbmcgd2l0aCBhdCBsZWFzdCBvbmUgZGFzaCBpcyBhbiBvcHRpb24gbmFtZVxuICogLSBPcHRpb25zIHdpdGhvdXQgYXJndW1lbnRzIG1lYW4gYSBib29sZWFuIFwidHJ1ZVwiXG4gKiAtIE9wdGlvbi1yZWFkaW5nIHN0b3BzIGF0IFwiLS1cIlxuICogLSBBbnl0aGluZyBjYXVnaHQgYmV0d2VlbiB0d28gb3B0aW9ucyBiZWNvbWVzIHRoZSBmaXJzdCBvcHRpb24ncyB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGlucHV0XG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZz17fV1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBhdXRvT3B0cyhpbnB1dCwgY29uZmlnID0ge30pe1xuXHRjb25zdCBvcHRzID0gbmV3IE9iamVjdChudWxsKTtcblx0Y29uc3QgYXJndiA9IFtdO1xuXHRsZXQgYXJndkVuZDtcblx0XG5cdC8vIEJhaWwgZWFybHkgaWYgcGFzc2VkIGEgYmxhbmsgc3RyaW5nXG5cdGlmKCFpbnB1dCkgcmV0dXJuIG9wdHM7XG5cdFxuXHQvLyBTdG9wIHBhcnNpbmcgb3B0aW9ucyBhZnRlciBhIGRvdWJsZS1kYXNoXG5cdGNvbnN0IHN0b3BBdCA9IGlucHV0LmluZGV4T2YoXCItLVwiKTtcblx0aWYoc3RvcEF0ICE9PSAtMSl7XG5cdFx0YXJndkVuZCA9IGlucHV0LnNsaWNlKHN0b3BBdCArIDEpO1xuXHRcdGlucHV0ID0gaW5wdXQuc2xpY2UoMCwgc3RvcEF0KTtcblx0fVxuXHRcblx0Zm9yKGxldCBpID0gMCwgbCA9IGlucHV0Lmxlbmd0aDsgaSA8IGw7ICsraSl7XG5cdFx0bGV0IG5hbWUgPSBpbnB1dFtpXTtcblx0XHRcblx0XHQvLyBBcHBlYXJzIHRvIGJlIGFuIG9wdGlvblxuXHRcdGlmKC9eLS8udGVzdChuYW1lKSl7XG5cdFx0XHRcblx0XHRcdC8vIEVxdWFscyBzaWduIGlzIHVzZWQsIHNob3VsZCBpdCBiZWNvbWUgdGhlIG9wdGlvbidzIHZhbHVlP1xuXHRcdFx0aWYoIWNvbmZpZy5pZ25vcmVFcXVhbHMgJiYgLz0vLnRlc3QobmFtZSkpe1xuXHRcdFx0XHRjb25zdCBzcGxpdCA9IG5hbWUuc3BsaXQoLz0vKTtcblx0XHRcdFx0bmFtZSAgICAgICAgPSBmb3JtYXROYW1lKHNwbGl0WzBdLCBjb25maWcubm9DYW1lbENhc2UpO1xuXHRcdFx0XHRvcHRzW25hbWVdICA9IHNwbGl0LnNsaWNlKDEpLmpvaW4oXCI9XCIpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRlbHNle1xuXHRcdFx0XHRuYW1lID0gZm9ybWF0TmFtZShuYW1lLCBjb25maWcubm9DYW1lbENhc2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVHJlYXQgYSBmb2xsb3dpbmcgbm9uLW9wdGlvbiBhcyB0aGlzIG9wdGlvbidzIHZhbHVlXG5cdFx0XHRcdGNvbnN0IG5leHQgPSBpbnB1dFtpICsgMV07XG5cdFx0XHRcdGlmKG5leHQgIT0gbnVsbCAmJiAhL14tLy50ZXN0KG5leHQpKXtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBUaGVyZSdzIGFub3RoZXIgb3B0aW9uIGFmdGVyIHRoaXMgb25lLiBDb2xsZWN0IG11bHRpcGxlIG5vbi1vcHRpb25zIGludG8gYW4gYXJyYXkuXG5cdFx0XHRcdFx0Y29uc3QgbmV4dE9wdCA9IGlucHV0LmZpbmRJbmRleCgocywgSSkgPT4gSSA+IGkgJiYgL14tLy50ZXN0KHMpKTtcblx0XHRcdFx0XHRpZihuZXh0T3B0ICE9PSAtMSl7XG5cdFx0XHRcdFx0XHRvcHRzW25hbWVdID0gaW5wdXQuc2xpY2UoaSArIDEsIG5leHRPcHQpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBUaGVyZSdzIG9ubHkgb25lIHZhbHVlIHRvIHN0b3JlOyBkb24ndCB3cmFwIGl0IGluIGFuIGFycmF5XG5cdFx0XHRcdFx0XHRpZihuZXh0T3B0IC0gaSA8IDMpXG5cdFx0XHRcdFx0XHRcdG9wdHNbbmFtZV0gPSBvcHRzW25hbWVdWzBdO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpID0gbmV4dE9wdCAtIDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFdlJ3JlIGF0IHRoZSBsYXN0IG9wdGlvbi4gRG9uJ3QgdG91Y2ggYXJndjsgYXNzdW1lIGl0J3MgYSBib29sZWFuLXR5cGUgb3B0aW9uXG5cdFx0XHRcdFx0ZWxzZSBvcHRzW25hbWVdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gTm8gYXJndW1lbnRzIGRlZmluZWQuIEFzc3VtZSBpdCdzIGEgYm9vbGVhbi10eXBlIG9wdGlvbi5cblx0XHRcdFx0ZWxzZSBvcHRzW25hbWVdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gTm9uLW9wdGlvbjogYWRkIHRvIGFyZ3Zcblx0XHRlbHNlIGFyZ3YucHVzaChuYW1lKTtcblx0fVxuXHRcblx0XG5cdC8vIEFkZCBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCB3ZXJlIGZvdW5kIGFmdGVyIGEgXCItLVwiIGRlbGltaXRlclxuXHRpZihhcmd2RW5kKVxuXHRcdGFyZ3YucHVzaCguLi5hcmd2RW5kKTtcblx0XG5cdHJldHVybiB7XG5cdFx0b3B0aW9uczogb3B0cyxcblx0XHRhcmd2OiAgICBhcmd2LFxuXHR9O1xufVxuXG5cblxuLyoqXG4gKiBFeHRyYWN0IGNvbW1hbmQtbGluZSBvcHRpb25zIGZyb20gYSBsaXN0IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGlucHV0XG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IFtvcHRkZWY9bnVsbF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnPXt9XVxuICovXG5mdW5jdGlvbiBnZXRPcHRzKGlucHV0LCBvcHRkZWYgPSBudWxsLCBjb25maWcgPSB7fSl7XG5cdFxuXHQvLyBEbyBub3RoaW5nIGlmIGdpdmVuIG5vdGhpbmdcblx0aWYoIWlucHV0IHx8IDAgPT09IGlucHV0Lmxlbmd0aClcblx0XHRyZXR1cm4ge29wdGlvbnM6IHt9LCBhcmd2OiBbXX07XG5cdFxuXHQvLyBBdm9pZCBtb2RpZnlpbmcgb3JpZ2luYWwgYXJyYXlcblx0aWYoQXJyYXkuaXNBcnJheShpbnB1dCkpXG5cdFx0aW5wdXQgPSBbLi4uaW5wdXRdLm1hcChTdHJpbmcpO1xuXHRcblx0Ly8gSWYgY2FsbGVkIHdpdGggYSBzdHJpbmcsIGJyZWFrIGl0IGFwYXJ0IGludG8gYW4gYXJyYXlcblx0ZWxzZSBpZihcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXQpXG5cdFx0aW5wdXQgPSB1bnN0cmluZ2lmeShpbnB1dCk7XG5cdFxuXHRcblx0Ly8gVGFrZSBhIGRpZmZlcmVudCBhcHByb2FjaCBpZiBvcHRkZWZzIGFyZW4ndCBzcGVjaWZpZWRcblx0aWYobnVsbCA9PT0gb3B0ZGVmIHx8IFwiXCIgPT09IG9wdGRlZiB8fCBmYWxzZSA9PT0gb3B0ZGVmKVxuXHRcdHJldHVybiBhdXRvT3B0cyhpbnB1dCwgY29uZmlnKTtcblx0XG5cdFxuXHQvLyBBbGxvdyBcInQ6aDppOnNcIiBzdHlsZSBvZiBnZXRvcHQgdXNhZ2Vcblx0aWYoXCJbb2JqZWN0IFN0cmluZ11cIiA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdGRlZikpe1xuXHRcdGNvbnN0IG5hbWVzID0gb3B0ZGVmLm1hdGNoKC9bXlxcczpdOj8vZyk7XG5cdFx0b3B0ZGVmID0ge307XG5cdFx0bmFtZXMuZm9yRWFjaChuYW1lID0+IHtcblx0XHRcdG9wdGRlZltgLSR7bmFtZS5yZXBsYWNlKC86LywgXCJcIil9YF0gPSBuYW1lLmxlbmd0aCA+IDEgPyBcIjxhcmc+XCIgOiBcIlwiO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gUGFyc2Ugc2V0dGluZ3MgdGhhdCBhZmZlY3QgcnVudGltZSBvcHRpb24taGFuZGxpbmdcblx0Y29uc3Qge1xuXHRcdG5vQWxpYXNQcm9wYWdhdGlvbixcblx0XHRub0NhbWVsQ2FzZSxcblx0XHRub0J1bmRsaW5nLFxuXHRcdG5vTWl4ZWRPcmRlcixcblx0XHRub1VuZGVmaW5lZCxcblx0XHR0ZXJtaW5hdG9yLFxuXHRcdGlnbm9yZUVxdWFscyxcblx0XHRkdXBsaWNhdGVzID0gXCJ1c2UtbGFzdFwiLFxuXHR9ID0gY29uZmlnO1xuXHRcblx0Y29uc3Qgc2hvcnROYW1lcyA9IHt9O1xuXHRjb25zdCBsb25nTmFtZXMgPSB7fTtcblx0Y29uc3QgcmVzdWx0ID0ge2FyZ3Y6IFtdLCBvcHRpb25zOiBuZXcgT2JqZWN0KG51bGwpfTtcblxuXHQvLyBEZWZpbmUgZWFjaCBuYW1lZCBvcHRpb24uIFRocm93IGFuIGVycm9yIGlmIGEgZHVwbGljYXRlIGlzIGZvdW5kLlxuXHRmb3IoY29uc3QgbmFtZSBpbiBvcHRkZWYpe1xuXHRcdGNvbnN0IG9wdGlvbiA9IG5ldyBPcHRpb24obmFtZSwgb3B0ZGVmW25hbWVdKTtcblx0XHRcblx0XHRmb3IoY29uc3QgbmFtZSBvZiBvcHRpb24uc2hvcnROYW1lcyl7XG5cdFx0XHRpZih1bmRlZmluZWQgIT09IHNob3J0TmFtZXNbbmFtZV0pXG5cdFx0XHRcdHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihgU2hvcnQgb3B0aW9uIFwiLSR7bmFtZX1cIiBhbHJlYWR5IGRlZmluZWRgKTtcblx0XHRcdHNob3J0TmFtZXNbYC0ke25hbWV9YF0gPSBvcHRpb247XG5cdFx0fVxuXHRcdFxuXHRcdGZvcihjb25zdCBuYW1lIG9mIG9wdGlvbi5sb25nTmFtZXMpe1xuXHRcdFx0aWYodW5kZWZpbmVkICE9PSBsb25nTmFtZXNbbmFtZV0pXG5cdFx0XHRcdHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihgTG9uZyBvcHRpb24gXCItLSR7bmFtZX1cIiBhbHJlYWR5IGRlZmluZWRgKTtcblx0XHRcdGxvbmdOYW1lc1tgLS0ke25hbWV9YF0gPSBvcHRpb247XG5cdFx0fVxuXHR9XG5cdFxuXHQvLyBQb2ludGVyIHRvIHRoZSBvcHRpb24gdGhhdCdzIGN1cnJlbnRseSBwaWNraW5nIHVwIGFyZ3VtZW50c1xuXHRsZXQgY3VycmVudE9wdGlvbjtcblx0XG5cdFxuXHQvLyBNYW5hZ2UgZHVwbGljYXRlZCBvcHRpb24gdmFsdWVzXG5cdGZ1bmN0aW9uIHJlc29sdmVEdXBsaWNhdGUob3B0aW9uLCBuYW1lLCB2YWx1ZSl7XG5cdFx0c3dpdGNoKGR1cGxpY2F0ZXMpe1xuXHRcdFx0XG5cdFx0XHQvLyBVc2UgdGhlIGZpcnN0IHZhbHVlIChvciBzZXQgb2YgdmFsdWVzKTsgZGlzY2FyZCBhbnkgZm9sbG93aW5nIGR1cGxpY2F0ZXNcblx0XHRcdGNhc2UgXCJ1c2UtZmlyc3RcIjpcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5vcHRpb25zW25hbWVdO1xuXHRcdFx0XG5cdFx0XHQvLyBVc2UgdGhlIGxhc3QgdmFsdWUgKG9yIHNldCBvZiB2YWx1ZXMpOyBkaXNjYXJkIGFueSBwcmVjZWRpbmcgZHVwbGljYXRlcy4gRGVmYXVsdC5cblx0XHRcdGNhc2UgXCJ1c2UtbGFzdFwiOlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5vcHRpb25zW25hbWVdID0gdmFsdWU7XG5cdFx0XHRcblx0XHRcdC8vIFVzZSB0aGUgZmlyc3QvbGFzdCBvcHRpb25zOyB0cmVhdCBhbnkgZm9sbG93aW5nL3ByZWNlZGluZyBkdXBsaWNhdGVzIGFzIGFyZ3YgaXRlbXMgcmVzcGVjdGl2ZWx5XG5cdFx0XHRjYXNlIFwibGltaXQtZmlyc3RcIjpcblx0XHRcdGNhc2UgXCJsaW1pdC1sYXN0XCI6XG5cdFx0XHRcdHJlc3VsdC5hcmd2LnB1c2gob3B0aW9uLnByZXZNYXRjaGVkTmFtZSwgLi4uYXJyYXlpZnkodmFsdWUpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdC8vIFRocm93IGFuIGV4Y2VwdGlvblxuXHRcdFx0Y2FzZSBcImVycm9yXCI6XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcihgQXR0ZW1wdGluZyB0byByZWFzc2lnbiBvcHRpb24gXCIke25hbWV9XCIgd2l0aCB2YWx1ZShzKSAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcblx0XHRcdFx0ZXJyb3IuYWZmZWN0ZWRPcHRpb24gPSBvcHRpb247XG5cdFx0XHRcdGVycm9yLmFmZmVjdGVkVmFsdWUgID0gdmFsdWU7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0XG5cdFx0XHQvLyBBZGQgcGFyYW1ldGVycyBvZiBkdXBsaWNhdGUgb3B0aW9ucyB0byB0aGUgYXJndW1lbnQgbGlzdCBvZiB0aGUgZmlyc3Rcblx0XHRcdGNhc2UgXCJhcHBlbmRcIjpcblx0XHRcdFx0Y29uc3Qgb2xkVmFsdWVzID0gYXJyYXlpZnkocmVzdWx0Lm9wdGlvbnNbbmFtZV0pO1xuXHRcdFx0XHRjb25zdCBuZXdWYWx1ZXMgPSBhcnJheWlmeSh2YWx1ZSk7XG5cdFx0XHRcdHJlc3VsdC5vcHRpb25zW25hbWVdID0gb2xkVmFsdWVzLmNvbmNhdChuZXdWYWx1ZXMpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0Ly8gU3RvcmUgcGFyYW1ldGVycyBvZiBkdXBsaWNhdGVkIG9wdGlvbnMgaW4gYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5XG5cdFx0XHRjYXNlIFwic3RhY2tcIjoge1xuXHRcdFx0XHRsZXQgb2xkVmFsdWVzICAgPSByZXN1bHQub3B0aW9uc1tuYW1lXTtcblx0XHRcdFx0Y29uc3QgbmV3VmFsdWVzID0gYXJyYXlpZnkodmFsdWUpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVGhpcyBvcHRpb24gaGFzbid0IGJlZW4gXCJzdGFja2VkXCIgeWV0XG5cdFx0XHRcdGlmKCFvcHRpb24uc3RhY2tlZCl7XG5cdFx0XHRcdFx0b2xkVmFsdWVzICAgICAgICAgICAgPSBhcnJheWlmeShvbGRWYWx1ZXMpO1xuXHRcdFx0XHRcdHJlc3VsdC5vcHRpb25zW25hbWVdID0gW29sZFZhbHVlcywgbmV3VmFsdWVzXTtcblx0XHRcdFx0XHRvcHRpb24uc3RhY2tlZCAgICAgICA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFscmVhZHkgXCJzdGFja2VkXCIsIHNvIGp1c3Qgc2hvdmUgdGhlIHZhbHVlcyBvbnRvIHRoZSBlbmQgb2YgdGhlIGFycmF5XG5cdFx0XHRcdGVsc2UgcmVzdWx0Lm9wdGlvbnNbbmFtZV0ucHVzaChhcnJheWlmeShuZXdWYWx1ZXMpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBTdG9yZSBlYWNoIGR1cGxpY2F0ZWQgdmFsdWUgaW4gYW4gYXJyYXkgdXNpbmcgdGhlIG9yZGVyIHRoZXkgYXBwZWFyXG5cdFx0XHRjYXNlIFwic3RhY2stdmFsdWVzXCI6IHtcblx0XHRcdFx0bGV0IHZhbHVlcyA9IHJlc3VsdC5vcHRpb25zW25hbWVdO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRmlyc3QgdGltZSBcInN0YWNraW5nXCIgdGhpcyBvcHRpb24gKG5lc3RpbmcgaXRzIHZhbHVlL3MgaW5zaWRlIGFuIGFycmF5KVxuXHRcdFx0XHRpZighb3B0aW9uLnN0YWNrZWQpe1xuXHRcdFx0XHRcdGNvbnN0IHN0YWNrID0gW107XG5cdFx0XHRcdFx0Zm9yKGNvbnN0IHZhbHVlIG9mIGFycmF5aWZ5KHZhbHVlcykpXG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKFt2YWx1ZV0pO1xuXHRcdFx0XHRcdHZhbHVlcyA9IHN0YWNrO1xuXHRcdFx0XHRcdG9wdGlvbi5zdGFja2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0YXJyYXlpZnkodmFsdWUpLmZvckVhY2goKHYsIGkpID0+IHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBBbiBhcnJheSBoYXNuJ3QgYmVlbiBjcmVhdGVkIGF0IHRoaXMgaW5kZXggeWV0LFxuXHRcdFx0XHRcdC8vIGJlY2F1c2UgYW4gZWFybGllciBvcHRpb24gd2Fzbid0IGdpdmVuIGVub3VnaCBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRcdGlmKHVuZGVmaW5lZCA9PT0gdmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0dmFsdWVzW2ldID0gQXJyYXkodmFsdWVzWzBdLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhbHVlc1tpXS5wdXNoKHYpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdHJlc3VsdC5vcHRpb25zW25hbWVdID0gdmFsdWVzO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvLyBBc3NpZ24gYW4gb3B0aW9uJ3MgcGFyc2VkIHZhbHVlIHRvIHRoZSByZXN1bHQncyBgLm9wdGlvbnNgIHByb3BlcnR5XG5cdGZ1bmN0aW9uIHNldFZhbHVlKG9wdGlvbiwgdmFsdWUpe1xuXHRcdFxuXHRcdC8vIEFzc2lnbiB0aGUgdmFsdWUgb25seSB0byB0aGUgb3B0aW9uIG5hbWUgaXQgbWF0Y2hlZFxuXHRcdGlmKG5vQWxpYXNQcm9wYWdhdGlvbil7XG5cdFx0XHRsZXQgbmFtZSA9IG9wdGlvbi5sYXN0TWF0Y2hlZE5hbWU7XG5cdFx0XHRcblx0XHRcdC8vIFNwZWNpYWwgYWx0ZXJuYXRpdmU6XG5cdFx0XHQvLyBJbiBsaWV1IG9mIHVzaW5nIHRoZSBtYXRjaGVkIG9wdGlvbiBuYW1lLCB1c2UgdGhlIGZpcnN0IC0tbG9uZy1uYW1lIG9ubHlcblx0XHRcdGlmKFwiZmlyc3Qtb25seVwiID09PSBub0FsaWFzUHJvcGFnYXRpb24pXG5cdFx0XHRcdG5hbWUgPSBvcHRpb24ubG9uZ05hbWVzWzBdIHx8IG9wdGlvbi5zaG9ydE5hbWVzWzBdO1xuXHRcdFx0XG5cdFx0XHQvLyBjYW1lbENhc2U/XG5cdFx0XHRuYW1lID0gZm9ybWF0TmFtZShuYW1lLCBub0NhbWVsQ2FzZSk7XG5cdFx0XHRcblx0XHRcdC8vIFRoaXMgb3B0aW9uJ3MgYWxyZWFkeSBiZWVuIHNldCBiZWZvcmVcblx0XHRcdGlmKHJlc3VsdC5vcHRpb25zW25hbWVdKVxuXHRcdFx0XHRyZXNvbHZlRHVwbGljYXRlKG9wdGlvbiwgbmFtZSwgdmFsdWUpO1xuXHRcdFx0XG5cdFx0XHRlbHNlIHJlc3VsdC5vcHRpb25zW25hbWVdID0gdmFsdWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIENvcHkgYWNyb3NzIGV2ZXJ5IGFsaWFzIHRoaXMgb3B0aW9uJ3MgcmVjb2duaXNlZCBieVxuXHRcdGVsc2V7XG5cdFx0XHRjb25zdCB7bmFtZXN9ID0gb3B0aW9uO1xuXHRcdFx0XG5cdFx0XHRmb3IobGV0IG5hbWUgb2YgbmFtZXMpe1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRGVjaWRlIHdoZXRoZXIgdG8gY2FtZWxDYXNlIHRoaXMgb3B0aW9uIG5hbWVcblx0XHRcdFx0bmFtZSA9IGZvcm1hdE5hbWUobmFtZSwgbm9DYW1lbENhc2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQXNjZXJ0YWluIGlmIHRoaXMgb3B0aW9uJ3MgYmVpbmcgZHVwbGljYXRlZFxuXHRcdFx0XHRpZihyZXN1bHQub3B0aW9uc1tuYW1lXSlcblx0XHRcdFx0XHRyZXNvbHZlRHVwbGljYXRlKG9wdGlvbiwgbmFtZSwgdmFsdWUpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmVzdWx0Lm9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvLyBQdXNoIHdoYXRldmVyIHdlJ3ZlIGN1cnJlbnRseSBjb2xsZWN0ZWQgZm9yIHRoaXMgb3B0aW9uIGFuZCByZXNldCBwb2ludGVyXG5cdGZ1bmN0aW9uIHdyYXBJdFVwKCl7XG5cdFx0bGV0IG9wdFZhbHVlID0gY3VycmVudE9wdGlvbi52YWx1ZXM7XG5cdFx0XG5cdFx0Ly8gRG9uJ3Qgc3RvcmUgc29saXRhcnkgdmFsdWVzIGluIGFuIGFycmF5LiBTdG9yZSB0aGVtIGRpcmVjdGx5IGFzIHN0cmluZ3Ncblx0XHRpZigxID09PSBjdXJyZW50T3B0aW9uLmFyaXR5ICYmICFjdXJyZW50T3B0aW9uLnZhcmlhZGljKVxuXHRcdFx0b3B0VmFsdWUgPSBvcHRWYWx1ZVswXTtcblxuXHRcdHNldFZhbHVlKGN1cnJlbnRPcHRpb24sIG9wdFZhbHVlKTtcblx0XHRjdXJyZW50T3B0aW9uLnZhbHVlcyA9IFtdO1xuXHRcdGN1cnJlbnRPcHRpb24gPSBudWxsO1xuXHR9XG5cdFxuXHRcblx0Ly8gUmV2ZXJzZSB0aGUgb3JkZXIgb2YgYW4gYXJndW1lbnQgbGlzdCwga2VlcGluZyBvcHRpb25zIGFuZCB0aGVpciBwYXJhbWV0ZXIgbGlzdHMgaW50YWN0XG5cdGZ1bmN0aW9uIGZsaXAoaW5wdXQpe1xuXHRcdGlucHV0ID0gaW5wdXQucmV2ZXJzZSgpO1xuXHRcdFxuXHRcdC8vIEZsaXAgYW55IG9wdGlvbnMgYmFjayBpbnRvIHRoZSByaWdodCBvcmRlclxuXHRcdGZvcihsZXQgaSA9IDAsIGwgPSBpbnB1dC5sZW5ndGg7IGkgPCBsOyArK2kpe1xuXHRcdFx0Y29uc3QgYXJnID0gaW5wdXRbaV07XG5cdFx0XHRjb25zdCBvcHQgPSBzaG9ydE5hbWVzW2FyZ10gfHwgbG9uZ05hbWVzW2FyZ107XG5cdFx0XHRcblx0XHRcdGlmKG9wdCl7XG5cdFx0XHRcdGNvbnN0IGZyb20gICAgPSBNYXRoLm1heCgwLCBpIC0gb3B0LmFyaXR5KTtcblx0XHRcdFx0Y29uc3QgdG8gICAgICA9IGkgKyAxO1xuXHRcdFx0XHRjb25zdCBleHRyYWN0ID0gaW5wdXQuc2xpY2UoZnJvbSwgdG8pLnJldmVyc2UoKTtcblx0XHRcdFx0aW5wdXQuc3BsaWNlKGZyb20sIGV4dHJhY3QubGVuZ3RoLCAuLi5leHRyYWN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGlucHV0O1xuXHR9XG5cdFxuXHRcblx0Ly8gVGFja2xlIGJ1bmRsaW5nLiBFbnN1cmUgdGhlcmUncyBhdCBsZWFzdCBvbmUgb3B0aW9uIHdpdGggYSBzaG9ydCBuYW1lIHRvIHdvcmsgd2l0aC5cblx0Y29uc3QgbmFtZUtleXMgPSBPYmplY3Qua2V5cyhzaG9ydE5hbWVzKTtcblx0bGV0IGJ1bmRsZU1hdGNoLCBidW5kbGVQYXR0ZXJucywgbmlsYWRpY0FyZ3M7XG5cdFxuXHRpZighbm9CdW5kbGluZyAmJiBuYW1lS2V5cy5sZW5ndGgpe1xuXHRcdGJ1bmRsZVBhdHRlcm5zICA9IHVuaXF1ZVN0cmluZ3MobmFtZUtleXMubWFwKG4gPT4gc2hvcnROYW1lc1tuXS5idW5kbGVQYXR0ZXJuKSkuam9pbihcInxcIik7XG5cdFx0YnVuZGxlTWF0Y2ggICAgID0gbmV3IFJlZ0V4cChgXi0oJHtidW5kbGVQYXR0ZXJuc30pK2AsIFwiZ1wiKTtcblx0XHRuaWxhZGljQXJncyAgICAgPSB1bmlxdWVTdHJpbmdzKG5hbWVLZXlzLmZpbHRlcihuID0+ICFzaG9ydE5hbWVzW25dLmFyaXR5KS5tYXAobiA9PiBzaG9ydE5hbWVzW25dLmJ1bmRsZVBhdHRlcm4pKS5qb2luKFwifFwiKTtcblx0XHRuaWxhZGljQXJncyAgICAgPSBuZXcgUmVnRXhwKGBeKC0oPzoke25pbGFkaWNBcmdzfSkrKSgoPyEke2J1bmRsZVBhdHRlcm5zfSlcXFxcUyspYCk7XG5cdFx0YnVuZGxlUGF0dGVybnMgID0gbmV3IFJlZ0V4cChidW5kbGVQYXR0ZXJucywgXCJnXCIpO1xuXHR9XG5cdFxuXHRcblx0Ly8gSXMgcHJlLXByb2Nlc3Npbmcgb2YgdGhlIGFyZ3VtZW50IGxpc3QgbmVjZXNzYXJ5P1xuXHRpZighaWdub3JlRXF1YWxzIHx8IGJ1bmRsZU1hdGNoKXtcblx0XHRcblx0XHQvLyBMaW1pdCBlcXVhbHMtc2lnbiBleHBhbnNpb24gdG8gaXRlbXMgdGhhdCBiZWdpbiB3aXRoIHJlY29nbmlzZWQgb3B0aW9uIG5hbWVzXG5cdFx0Y29uc3QgbGVnYWxOYW1lcyA9IG5ldyBSZWdFeHAoYF4oPzokeyBPYmplY3Qua2V5cyhsb25nTmFtZXMpLmpvaW4oXCJ8XCIpIH0pPWApO1xuXHRcdFxuXHRcdGZvcihsZXQgaSA9IDAsIGwgPSBpbnB1dC5sZW5ndGg7IGkgPCBsOyArK2kpe1xuXHRcdFx0bGV0IGFyZyA9IGlucHV0W2ldO1xuXHRcdFx0XG5cdFx0XHQvLyBXZSBoYXZlIGJ1bmRsaW5nIGluIHVzZVxuXHRcdFx0aWYoYnVuZGxlTWF0Y2gpe1xuXHRcdFx0XHRidW5kbGVNYXRjaC5sYXN0SW5kZXggPSAwO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRXhwYW5kIGJ1bmRsZWQgb3B0aW9uIGNsdXN0ZXJzIChcIi1tdmwyXCIgLT4gXCItbSAtdiAtbCAyXCIpXG5cdFx0XHRcdGlmKGJ1bmRsZU1hdGNoLnRlc3QoYXJnKSl7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gQnJlYWsgb2ZmIGFyZ3VtZW50cyBhdHRhY2hlZCB0byBuaWxhZGljIG9wdGlvbnNcblx0XHRcdFx0XHRjb25zdCBuaWxhZGljTWF0Y2ggPSBhcmcubWF0Y2gobmlsYWRpY0FyZ3MpO1xuXHRcdFx0XHRcdGlmKG5pbGFkaWNNYXRjaCl7XG5cdFx0XHRcdFx0XHRuaWxhZGljQXJncy5sYXN0SW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0YXJnID0gbmlsYWRpY01hdGNoWzFdO1xuXHRcdFx0XHRcdFx0aW5wdXQuc3BsaWNlKGkgKyAxLCAwLCBuaWxhZGljTWF0Y2hbMl0pO1xuXHRcdFx0XHRcdFx0bCA9IGlucHV0Lmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgc2VnbWVudHMgPSBbXS5jb25jYXQoLi4uYXJnLm1hdGNoKGJ1bmRsZVBhdHRlcm5zKS5tYXAobSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBvcHRpb24gPSBzaG9ydE5hbWVzW2AtJHttWzBdfWBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gW2AtJHttWzBdfWBdO1xuXHRcdFx0XHRcdFx0aWYoIW9wdGlvbi5hcml0eSkgcmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKC4uLm0ubWF0Y2gobmV3IFJlZ0V4cChvcHRpb24uYnVuZGxlUGF0dGVybikpLnNsaWNlKDEpLmZpbHRlcihpID0+IGkpKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdGlucHV0LnNwbGljZShpLCAxLCAuLi5zZWdtZW50cyk7XG5cdFx0XHRcdFx0bCA9ICBpbnB1dC5sZW5ndGg7XG5cdFx0XHRcdFx0aSArPSBzZWdtZW50cy5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIEV4cGFuZCBcIi0tb3B0aW9uPXZhbHVlXCIgc2VxdWVuY2VzIHRvIGJlY29tZSBcIi0tb3B0aW9uIHZhbHVlXCJcblx0XHRcdGlmKGxlZ2FsTmFtZXMudGVzdChhcmcpKXtcblx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBhcmcubWF0Y2goL14oW149XSspPSguKykkLyk7XG5cdFx0XHRcdGlucHV0LnNwbGljZShpLCAxLCBtYXRjaFsxXSwgbWF0Y2hbMl0pO1xuXHRcdFx0XHRsID0gIGlucHV0Lmxlbmd0aDtcblx0XHRcdFx0aSArPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8vIElmIHdlJ3JlIGhhbmRsaW5nIGR1cGxpY2F0ZSBvcHRpb25zIHdpdGggXCJsaW1pdC1sYXN0XCIsIGZsaXAgdGhlIGlucHV0IG9yZGVyXG5cdGlmKFwibGltaXQtbGFzdFwiID09PSBkdXBsaWNhdGVzKVxuXHRcdGlucHV0ID0gZmxpcChpbnB1dCk7XG5cdFxuXHQvLyBTdGFydCBwcm9jZXNzaW5nIHRoZSBhcmd1bWVudHMgd2Ugd2VyZSBnaXZlbiB0byBoYW5kbGVcblx0Zm9yKGxldCBpID0gMCwgbCA9IGlucHV0Lmxlbmd0aDsgaSA8IGw7ICsraSl7XG5cdFx0Y29uc3QgYXJnID0gaW5wdXRbaV07XG5cdFx0Y29uc3Qgb3B0ID0gc2hvcnROYW1lc1thcmddIHx8IGxvbmdOYW1lc1thcmddO1xuXHRcdFxuXHRcdC8vIFRoaXMgYXJndW1lbnQgbWF0Y2hlcyBhIHJlY29nbmlzZWQgb3B0aW9uIG5hbWVcblx0XHRpZihvcHQpe1xuXHRcdFx0XG5cdFx0XHQvLyBSZWNvcmQgdGhlIG5hbWUgZ2l2ZW4gb24gY29tbWFuZC1saW5lIHRoYXQgbWF0Y2hlZCB0aGUgb3B0aW9uXG5cdFx0XHRvcHQubGFzdE1hdGNoZWROYW1lID0gYXJnO1xuXHRcdFx0XG5cdFx0XHQvLyBEaWQgd2UgaGF2ZSBhbiBleGlzdGluZyBvcHRpb24gdGhhdCB3YXMgY29sbGVjdGluZyB2YWx1ZXM/XG5cdFx0XHRpZihjdXJyZW50T3B0aW9uKSB3cmFwSXRVcCgpO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8vIE9wdGlvbiB0YWtlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnRcblx0XHRcdGlmKG9wdC5hcml0eSlcblx0XHRcdFx0Y3VycmVudE9wdGlvbiA9IG9wdDtcblx0XHRcdFxuXHRcdFx0Ly8gVGhpcyBvcHRpb24gdGFrZXMgbm8gYXJndW1lbnRzLCBzbyBqdXN0IGFzc2lnbiBpdCBhIHZhbHVlIG9mIFwidHJ1ZVwiXG5cdFx0XHRlbHNlIHNldFZhbHVlKG9wdCwgdHJ1ZSk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gU3RvcmUgYW4gYWRkaXRpb25hbCBiYWNrLXJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBvcHRpb24ncyBuYW1lXG5cdFx0XHRvcHQucHJldk1hdGNoZWROYW1lID0gYXJnO1xuXHRcdH1cblx0XHRcblx0XHRlbHNle1xuXHRcdFx0Y29uc3QgaXNUZXJtaW5hdG9yID0gbWF0Y2goYXJnLCB0ZXJtaW5hdG9yKTtcblx0XHRcdGNvbnN0IGtlZXBSZXN0ID0gKCkgPT4gcmVzdWx0LmFyZ3YucHVzaCguLi5pbnB1dC5zbGljZShpICsgMSkpO1xuXHRcdFx0XG5cdFx0XHQvLyBBIHByZXZpb3VzIG9wdGlvbiBpcyBzdGlsbCBjb2xsZWN0aW5nIGFyZ3VtZW50c1xuXHRcdFx0aWYoY3VycmVudE9wdGlvbiAmJiBjdXJyZW50T3B0aW9uLmNhbkNvbGxlY3QgJiYgIWlzVGVybWluYXRvcilcblx0XHRcdFx0Y3VycmVudE9wdGlvbi52YWx1ZXMucHVzaChhcmcpO1xuXHRcdFx0XG5cdFx0XHQvLyBOb3QgYXNzb2NpYXRlZCB3aXRoIGFuIG9wdGlvblxuXHRcdFx0ZWxzZXtcblx0XHRcdFx0Y3VycmVudE9wdGlvbiAmJiB3cmFwSXRVcCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVGVybWluYXRlIG9wdGlvbiBwYXJzaW5nP1xuXHRcdFx0XHRpZihpc1Rlcm1pbmF0b3Ipe1xuXHRcdFx0XHRcdGtlZXBSZXN0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFJhaXNlIGFuIGV4Y2VwdGlvbiBpZiB1bnJlY29nbmlzZWQgc3dpdGNoZXMgYXJlIGNvbnNpZGVyZWQgYW4gZXJyb3Jcblx0XHRcdFx0aWYobm9VbmRlZmluZWQgJiYgL14tLi8udGVzdChhcmcpKXtcblx0XHRcdFx0XHRsZXQgZXJyb3IgPSBub1VuZGVmaW5lZDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBQcmVwYXJlIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gaW4gdGhlIHVzZXIncyBkaXJlY3Rpb25cblx0XHRcdFx0XHRzd2l0Y2godHlwZW9mIG5vVW5kZWZpbmVkKXtcblx0XHRcdFx0XHRcdGNhc2UgXCJmdW5jdGlvblwiOiBlcnJvciA9IGVycm9yKGFyZyk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcImJvb2xlYW5cIjogIGVycm9yID0gJ1Vua25vd24gb3B0aW9uOiBcIiVzXCInOyAvLyBGYWxsLXRocm91Z2hcblx0XHRcdFx0XHRcdGNhc2UgXCJzdHJpbmdcIjogICBlcnJvciA9IG5ldyBUeXBlRXJyb3IoZXJyb3IucmVwbGFjZShcIiVzXCIsIGFyZykpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmVzdWx0LmFyZ3YucHVzaChhcmcpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRmluaXNoIHByb2Nlc3NpbmcgaWYgbWl4ZWQtb3JkZXIgaXMgZGlzYWJsZWRcblx0XHRcdFx0aWYobm9NaXhlZE9yZGVyKXtcblx0XHRcdFx0XHRrZWVwUmVzdCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0Ly8gRW5kZWQgYWJydXB0bHk/XG5cdGlmKGN1cnJlbnRPcHRpb24pIHdyYXBJdFVwKCk7XG5cdFxuXHRcblx0Ly8gQ2hlY2sgaWYgd2UgbmVlZCB0byBmbGlwIHRoZSByZXR1cm5lZCAuYXJndiBhcnJheSBiYWNrIGludG8gdGhlIHJpZ2h0IG9yZGVyIGFnYWluXG5cdGlmKFwibGltaXQtbGFzdFwiID09PSBkdXBsaWNhdGVzKVxuXHRcdHJlc3VsdC5hcmd2ID0gZmxpcChyZXN1bHQuYXJndik7XG5cdFx0XG5cdHJldHVybiByZXN1bHQ7XG59XG5cblxuaWYoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIG1vZHVsZS5leHBvcnRzKVxuXHRtb2R1bGUuZXhwb3J0cyA9IGdldE9wdHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvaW1tdXRhYmxlL2Rpc3QvaW1tdXRhYmxlLmVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbW11dGFibGUvZGlzdC9pbW11dGFibGUuZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQsIHZlcnNpb24sIENvbGxlY3Rpb24sIEl0ZXJhYmxlLCBTZXEsIE1hcCwgT3JkZXJlZE1hcCwgTGlzdCwgU3RhY2ssIFNldCwgT3JkZXJlZFNldCwgUmVjb3JkLCBSYW5nZSwgUmVwZWF0LCBpcywgZnJvbUpTLCBoYXNoLCBpc0ltbXV0YWJsZSwgaXNDb2xsZWN0aW9uLCBpc0tleWVkLCBpc0luZGV4ZWQsIGlzQXNzb2NpYXRpdmUsIGlzT3JkZXJlZCwgaXNWYWx1ZU9iamVjdCwgZ2V0LCBnZXRJbiwgaGFzLCBoYXNJbiwgbWVyZ2UsIG1lcmdlRGVlcCwgbWVyZ2VXaXRoLCBtZXJnZURlZXBXaXRoLCByZW1vdmUsIHJlbW92ZUluLCBzZXQsIHNldEluLCB1cGRhdGUsIHVwZGF0ZUluICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInZlcnNpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiB2ZXJzaW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDb2xsZWN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ29sbGVjdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiSXRlcmFibGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBJdGVyYWJsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU2VxXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2VxOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJNYXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNYXA7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIk9yZGVyZWRNYXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBPcmRlcmVkTWFwOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMaXN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGlzdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU3RhY2tcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTdGFjazsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU2V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2V0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJPcmRlcmVkU2V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gT3JkZXJlZFNldDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUmVjb3JkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUmVjb3JkOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJSYW5nZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJhbmdlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJSZXBlYXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSZXBlYXQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZyb21KU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZyb21KUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaGFzaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGhhc2g7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzSW1tdXRhYmxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNJbW11dGFibGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzQ29sbGVjdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQ29sbGVjdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNLZXllZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzS2V5ZWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzSW5kZXhlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzSW5kZXhlZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNBc3NvY2lhdGl2ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQXNzb2NpYXRpdmU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzT3JkZXJlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzT3JkZXJlZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNWYWx1ZU9iamVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzVmFsdWVPYmplY3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0SW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRJbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaGFzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoYXNJblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGhhc0luOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtZXJnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1lcmdlJDE7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1lcmdlRGVlcFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1lcmdlRGVlcDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWVyZ2VXaXRoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVyZ2VXaXRoJDE7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1lcmdlRGVlcFdpdGhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZXJnZURlZXBXaXRoOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZW1vdmVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZW1vdmU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlbW92ZUluXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVtb3ZlSW47IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNldFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNldDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2V0SW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXRJbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidXBkYXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBkYXRlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ1cGRhdGVJblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHVwZGF0ZUluOyB9KTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLy8gVXNlZCBmb3Igc2V0dGluZyBwcm90b3R5cGUgbWV0aG9kcyB0aGF0IElFOCBjaG9rZXMgb24uXG52YXIgREVMRVRFID0gJ2RlbGV0ZSc7XG5cbi8vIENvbnN0YW50cyBkZXNjcmliaW5nIHRoZSBzaXplIG9mIHRyaWUgbm9kZXMuXG52YXIgU0hJRlQgPSA1OyAvLyBSZXN1bHRlZCBpbiBiZXN0IHBlcmZvcm1hbmNlIGFmdGVyIF9fX19fXz9cbnZhciBTSVpFID0gMSA8PCBTSElGVDtcbnZhciBNQVNLID0gU0laRSAtIDE7XG5cbi8vIEEgY29uc2lzdGVudCBzaGFyZWQgdmFsdWUgcmVwcmVzZW50aW5nIFwibm90IHNldFwiIHdoaWNoIGVxdWFscyBub3RoaW5nIG90aGVyXG4vLyB0aGFuIGl0c2VsZiwgYW5kIG5vdGhpbmcgdGhhdCBjb3VsZCBiZSBwcm92aWRlZCBleHRlcm5hbGx5LlxudmFyIE5PVF9TRVQgPSB7fTtcblxuLy8gQm9vbGVhbiByZWZlcmVuY2VzLCBSb3VnaCBlcXVpdmFsZW50IG9mIGBib29sICZgLlxuZnVuY3Rpb24gTWFrZVJlZigpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IGZhbHNlIH07XG59XG5cbmZ1bmN0aW9uIFNldFJlZihyZWYpIHtcbiAgaWYgKHJlZikge1xuICAgIHJlZi52YWx1ZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgdmFsdWUgcmVwcmVzZW50aW5nIGFuIFwib3duZXJcIiBmb3IgdHJhbnNpZW50IHdyaXRlc1xuLy8gdG8gdHJpZXMuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBvbmx5IGV2ZXIgZXF1YWwgaXRzZWxmLCBhbmQgd2lsbCBub3QgZXF1YWxcbi8vIHRoZSByZXR1cm4gb2YgYW55IHN1YnNlcXVlbnQgY2FsbCBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gT3duZXJJRCgpIHt9XG5cbmZ1bmN0aW9uIGVuc3VyZVNpemUoaXRlcikge1xuICBpZiAoaXRlci5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICBpdGVyLnNpemUgPSBpdGVyLl9faXRlcmF0ZShyZXR1cm5UcnVlKTtcbiAgfVxuICByZXR1cm4gaXRlci5zaXplO1xufVxuXG5mdW5jdGlvbiB3cmFwSW5kZXgoaXRlciwgaW5kZXgpIHtcbiAgLy8gVGhpcyBpbXBsZW1lbnRzIFwiaXMgYXJyYXkgaW5kZXhcIiB3aGljaCB0aGUgRUNNQVN0cmluZyBzcGVjIGRlZmluZXMgYXM6XG4gIC8vXG4gIC8vICAgICBBIFN0cmluZyBwcm9wZXJ0eSBuYW1lIFAgaXMgYW4gYXJyYXkgaW5kZXggaWYgYW5kIG9ubHkgaWZcbiAgLy8gICAgIFRvU3RyaW5nKFRvVWludDMyKFApKSBpcyBlcXVhbCB0byBQIGFuZCBUb1VpbnQzMihQKSBpcyBub3QgZXF1YWxcbiAgLy8gICAgIHRvIDJeMzLiiJIxLlxuICAvL1xuICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXktZXhvdGljLW9iamVjdHNcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICB2YXIgdWludDMySW5kZXggPSBpbmRleCA+Pj4gMDsgLy8gTiA+Pj4gMCBpcyBzaG9ydGhhbmQgZm9yIFRvVWludDMyXG4gICAgaWYgKCcnICsgdWludDMySW5kZXggIT09IGluZGV4IHx8IHVpbnQzMkluZGV4ID09PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBpbmRleCA9IHVpbnQzMkluZGV4O1xuICB9XG4gIHJldHVybiBpbmRleCA8IDAgPyBlbnN1cmVTaXplKGl0ZXIpICsgaW5kZXggOiBpbmRleDtcbn1cblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkge1xuICByZXR1cm4gKFxuICAgICgoYmVnaW4gPT09IDAgJiYgIWlzTmVnKGJlZ2luKSkgfHxcbiAgICAgIChzaXplICE9PSB1bmRlZmluZWQgJiYgYmVnaW4gPD0gLXNpemUpKSAmJlxuICAgIChlbmQgPT09IHVuZGVmaW5lZCB8fCAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA+PSBzaXplKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSB7XG4gIHJldHVybiByZXNvbHZlSW5kZXgoYmVnaW4sIHNpemUsIDApO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRW5kKGVuZCwgc2l6ZSkge1xuICByZXR1cm4gcmVzb2x2ZUluZGV4KGVuZCwgc2l6ZSwgc2l6ZSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmRleChpbmRleCwgc2l6ZSwgZGVmYXVsdEluZGV4KSB7XG4gIC8vIFNhbml0aXplIGluZGljZXMgdXNpbmcgdGhpcyBzaG9ydGhhbmQgZm9yIFRvSW50MzIoYXJndW1lbnQpXG4gIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2ludDMyXG4gIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkXG4gICAgPyBkZWZhdWx0SW5kZXhcbiAgICA6IGlzTmVnKGluZGV4KVxuICAgICAgPyBzaXplID09PSBJbmZpbml0eVxuICAgICAgICA/IHNpemVcbiAgICAgICAgOiBNYXRoLm1heCgwLCBzaXplICsgaW5kZXgpIHwgMFxuICAgICAgOiBzaXplID09PSB1bmRlZmluZWQgfHwgc2l6ZSA9PT0gaW5kZXhcbiAgICAgICAgPyBpbmRleFxuICAgICAgICA6IE1hdGgubWluKHNpemUsIGluZGV4KSB8IDA7XG59XG5cbmZ1bmN0aW9uIGlzTmVnKHZhbHVlKSB7XG4gIC8vIEFjY291bnQgZm9yIC0wIHdoaWNoIGlzIG5lZ2F0aXZlLCBidXQgbm90IGxlc3MgdGhhbiAwLlxuICByZXR1cm4gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPT09IC1JbmZpbml0eSk7XG59XG5cbi8vIE5vdGU6IHZhbHVlIGlzIHVuY2hhbmdlZCB0byBub3QgYnJlYWsgaW1tdXRhYmxlLWRldnRvb2xzLlxudmFyIElTX0NPTExFQ1RJT05fU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfSVRFUkFCTEVfX0BAJztcblxuZnVuY3Rpb24gaXNDb2xsZWN0aW9uKG1heWJlQ29sbGVjdGlvbikge1xuICByZXR1cm4gQm9vbGVhbihtYXliZUNvbGxlY3Rpb24gJiYgbWF5YmVDb2xsZWN0aW9uW0lTX0NPTExFQ1RJT05fU1lNQk9MXSk7XG59XG5cbnZhciBJU19LRVlFRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9LRVlFRF9fQEAnO1xuXG5mdW5jdGlvbiBpc0tleWVkKG1heWJlS2V5ZWQpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVLZXllZCAmJiBtYXliZUtleWVkW0lTX0tFWUVEX1NZTUJPTF0pO1xufVxuXG52YXIgSVNfSU5ERVhFRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9JTkRFWEVEX19AQCc7XG5cbmZ1bmN0aW9uIGlzSW5kZXhlZChtYXliZUluZGV4ZWQpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVJbmRleGVkICYmIG1heWJlSW5kZXhlZFtJU19JTkRFWEVEX1NZTUJPTF0pO1xufVxuXG5mdW5jdGlvbiBpc0Fzc29jaWF0aXZlKG1heWJlQXNzb2NpYXRpdmUpIHtcbiAgcmV0dXJuIGlzS2V5ZWQobWF5YmVBc3NvY2lhdGl2ZSkgfHwgaXNJbmRleGVkKG1heWJlQXNzb2NpYXRpdmUpO1xufVxuXG52YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIENvbGxlY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzQ29sbGVjdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IFNlcSh2YWx1ZSk7XG59O1xuXG52YXIgS2V5ZWRDb2xsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICBmdW5jdGlvbiBLZXllZENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZSA6IEtleWVkU2VxKHZhbHVlKTtcbiAgfVxuXG4gIGlmICggQ29sbGVjdGlvbiApIEtleWVkQ29sbGVjdGlvbi5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5ZWRDb2xsZWN0aW9uO1xuXG4gIHJldHVybiBLZXllZENvbGxlY3Rpb247XG59KENvbGxlY3Rpb24pKTtcblxudmFyIEluZGV4ZWRDb2xsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICBmdW5jdGlvbiBJbmRleGVkQ29sbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBpc0luZGV4ZWQodmFsdWUpID8gdmFsdWUgOiBJbmRleGVkU2VxKHZhbHVlKTtcbiAgfVxuXG4gIGlmICggQ29sbGVjdGlvbiApIEluZGV4ZWRDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5kZXhlZENvbGxlY3Rpb247XG5cbiAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uO1xufShDb2xsZWN0aW9uKSk7XG5cbnZhciBTZXRDb2xsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICBmdW5jdGlvbiBTZXRDb2xsZWN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQ29sbGVjdGlvbih2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpID8gdmFsdWUgOiBTZXRTZXEodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uICkgU2V0Q29sbGVjdGlvbi5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRDb2xsZWN0aW9uO1xuXG4gIHJldHVybiBTZXRDb2xsZWN0aW9uO1xufShDb2xsZWN0aW9uKSk7XG5cbkNvbGxlY3Rpb24uS2V5ZWQgPSBLZXllZENvbGxlY3Rpb247XG5Db2xsZWN0aW9uLkluZGV4ZWQgPSBJbmRleGVkQ29sbGVjdGlvbjtcbkNvbGxlY3Rpb24uU2V0ID0gU2V0Q29sbGVjdGlvbjtcblxudmFyIElTX1NFUV9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9TRVFfX0BAJztcblxuZnVuY3Rpb24gaXNTZXEobWF5YmVTZXEpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVTZXEgJiYgbWF5YmVTZXFbSVNfU0VRX1NZTUJPTF0pO1xufVxuXG52YXIgSVNfUkVDT1JEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1JFQ09SRF9fQEAnO1xuXG5mdW5jdGlvbiBpc1JlY29yZChtYXliZVJlY29yZCkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZVJlY29yZCAmJiBtYXliZVJlY29yZFtJU19SRUNPUkRfU1lNQk9MXSk7XG59XG5cbmZ1bmN0aW9uIGlzSW1tdXRhYmxlKG1heWJlSW1tdXRhYmxlKSB7XG4gIHJldHVybiBpc0NvbGxlY3Rpb24obWF5YmVJbW11dGFibGUpIHx8IGlzUmVjb3JkKG1heWJlSW1tdXRhYmxlKTtcbn1cblxudmFyIElTX09SREVSRURfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfT1JERVJFRF9fQEAnO1xuXG5mdW5jdGlvbiBpc09yZGVyZWQobWF5YmVPcmRlcmVkKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlT3JkZXJlZCAmJiBtYXliZU9yZGVyZWRbSVNfT1JERVJFRF9TWU1CT0xdKTtcbn1cblxudmFyIElURVJBVEVfS0VZUyA9IDA7XG52YXIgSVRFUkFURV9WQUxVRVMgPSAxO1xudmFyIElURVJBVEVfRU5UUklFUyA9IDI7XG5cbnZhciBSRUFMX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gUkVBTF9JVEVSQVRPUl9TWU1CT0wgfHwgRkFVWF9JVEVSQVRPUl9TWU1CT0w7XG5cbnZhciBJdGVyYXRvciA9IGZ1bmN0aW9uIEl0ZXJhdG9yKG5leHQpIHtcbiAgdGhpcy5uZXh0ID0gbmV4dDtcbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuICdbSXRlcmF0b3JdJztcbn07XG5cbkl0ZXJhdG9yLktFWVMgPSBJVEVSQVRFX0tFWVM7XG5JdGVyYXRvci5WQUxVRVMgPSBJVEVSQVRFX1ZBTFVFUztcbkl0ZXJhdG9yLkVOVFJJRVMgPSBJVEVSQVRFX0VOVFJJRVM7XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5pbnNwZWN0ID0gSXRlcmF0b3IucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG59O1xuSXRlcmF0b3IucHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIGl0ZXJhdG9yUmVzdWx0KSB7XG4gIHZhciB2YWx1ZSA9IHR5cGUgPT09IDAgPyBrIDogdHlwZSA9PT0gMSA/IHYgOiBbaywgdl07XG4gIGl0ZXJhdG9yUmVzdWx0XG4gICAgPyAoaXRlcmF0b3JSZXN1bHQudmFsdWUgPSB2YWx1ZSlcbiAgICA6IChpdGVyYXRvclJlc3VsdCA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgIH0pO1xuICByZXR1cm4gaXRlcmF0b3JSZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yRG9uZSgpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xufVxuXG5mdW5jdGlvbiBoYXNJdGVyYXRvcihtYXliZUl0ZXJhYmxlKSB7XG4gIHJldHVybiAhIWdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSk7XG59XG5cbmZ1bmN0aW9uIGlzSXRlcmF0b3IobWF5YmVJdGVyYXRvcikge1xuICByZXR1cm4gbWF5YmVJdGVyYXRvciAmJiB0eXBlb2YgbWF5YmVJdGVyYXRvci5uZXh0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihpdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpO1xuICByZXR1cm4gaXRlcmF0b3JGbiAmJiBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGUpO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKGl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID1cbiAgICBpdGVyYWJsZSAmJlxuICAgICgoUkVBTF9JVEVSQVRPUl9TWU1CT0wgJiYgaXRlcmFibGVbUkVBTF9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgaXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgdmFsdWUgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZS5sZW5ndGgpICYmXG4gICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAodmFsdWUubGVuZ3RoID09PSAwXG4gICAgICA/IC8vIE9ubHkge2xlbmd0aDogMH0gaXMgY29uc2lkZXJlZCBBcnJheS1saWtlLlxuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAxXG4gICAgICA6IC8vIEFuIG9iamVjdCBpcyBvbmx5IEFycmF5LWxpa2UgaWYgaXQgaGFzIGEgcHJvcGVydHkgd2hlcmUgdGhlIGxhc3QgdmFsdWVcbiAgICAgICAgLy8gaW4gdGhlIGFycmF5LWxpa2UgbWF5IGJlIGZvdW5kICh3aGljaCBjb3VsZCBiZSB1bmRlZmluZWQpLlxuICAgICAgICB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZS5sZW5ndGggLSAxKSlcbiAgKTtcbn1cblxudmFyIFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbGxlY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gU2VxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlTZXF1ZW5jZSgpXG4gICAgICA6IGlzSW1tdXRhYmxlKHZhbHVlKVxuICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgOiBzZXFGcm9tVmFsdWUodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uJCQxICkgU2VxLl9fcHJvdG9fXyA9IENvbGxlY3Rpb24kJDE7XG4gIFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uJCQxICYmIENvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXE7XG5cbiAgU2VxLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uIHRvU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSB7JywgJ30nKTtcbiAgfTtcblxuICBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gZnVuY3Rpb24gY2FjaGVSZXN1bHQgKCkge1xuICAgIGlmICghdGhpcy5fY2FjaGUgJiYgdGhpcy5fX2l0ZXJhdGVVbmNhY2hlZCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB0aGlzLmVudHJ5U2VxKCkudG9BcnJheSgpO1xuICAgICAgdGhpcy5zaXplID0gdGhpcy5fY2FjaGUubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGVVbmNhY2hlZChmbiwgcmV2ZXJzZSlcblxuICBTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHZhciBzaXplID0gY2FjaGUubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgICBpZiAoZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKTtcbiAgfTtcblxuICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSlcblxuICBTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB2YXIgc2l6ZSA9IGNhY2hlLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvclVuY2FjaGVkKHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIHJldHVybiBTZXE7XG59KENvbGxlY3Rpb24pKTtcblxudmFyIEtleWVkU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VxKSB7XG4gIGZ1bmN0aW9uIEtleWVkU2VxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlTZXF1ZW5jZSgpLnRvS2V5ZWRTZXEoKVxuICAgICAgOiBpc0NvbGxlY3Rpb24odmFsdWUpXG4gICAgICAgID8gaXNLZXllZCh2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgICA6IHZhbHVlLmZyb21FbnRyeVNlcSgpXG4gICAgICAgIDogaXNSZWNvcmQodmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZS50b1NlcSgpXG4gICAgICAgICAgOiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIFNlcSApIEtleWVkU2VxLl9fcHJvdG9fXyA9IFNlcTtcbiAgS2V5ZWRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgS2V5ZWRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5ZWRTZXE7XG5cbiAgS2V5ZWRTZXEucHJvdG90eXBlLnRvS2V5ZWRTZXEgPSBmdW5jdGlvbiB0b0tleWVkU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gS2V5ZWRTZXE7XG59KFNlcSkpO1xuXG52YXIgSW5kZXhlZFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICBmdW5jdGlvbiBJbmRleGVkU2VxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlTZXF1ZW5jZSgpXG4gICAgICA6IGlzQ29sbGVjdGlvbih2YWx1ZSlcbiAgICAgICAgPyBpc0tleWVkKHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUuZW50cnlTZXEoKVxuICAgICAgICAgIDogdmFsdWUudG9JbmRleGVkU2VxKClcbiAgICAgICAgOiBpc1JlY29yZCh2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlLnRvU2VxKCkuZW50cnlTZXEoKVxuICAgICAgICAgIDogaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIFNlcSApIEluZGV4ZWRTZXEuX19wcm90b19fID0gU2VxO1xuICBJbmRleGVkU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlcSAmJiBTZXEucHJvdG90eXBlICk7XG4gIEluZGV4ZWRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5kZXhlZFNlcTtcblxuICBJbmRleGVkU2VxLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gSW5kZXhlZFNlcShhcmd1bWVudHMpO1xuICB9O1xuXG4gIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvSW5kZXhlZFNlcSA9IGZ1bmN0aW9uIHRvSW5kZXhlZFNlcSAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgSW5kZXhlZFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2VxIFsnLCAnXScpO1xuICB9O1xuXG4gIHJldHVybiBJbmRleGVkU2VxO1xufShTZXEpKTtcblxudmFyIFNldFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICBmdW5jdGlvbiBTZXRTZXEodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzQ29sbGVjdGlvbih2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IEluZGV4ZWRTZXEodmFsdWUpXG4gICAgKS50b1NldFNlcSgpO1xuICB9XG5cbiAgaWYgKCBTZXEgKSBTZXRTZXEuX19wcm90b19fID0gU2VxO1xuICBTZXRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgU2V0U2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldFNlcTtcblxuICBTZXRTZXEub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiBTZXRTZXEoYXJndW1lbnRzKTtcbiAgfTtcblxuICBTZXRTZXEucHJvdG90eXBlLnRvU2V0U2VxID0gZnVuY3Rpb24gdG9TZXRTZXEgKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBTZXRTZXE7XG59KFNlcSkpO1xuXG5TZXEuaXNTZXEgPSBpc1NlcTtcblNlcS5LZXllZCA9IEtleWVkU2VxO1xuU2VxLlNldCA9IFNldFNlcTtcblNlcS5JbmRleGVkID0gSW5kZXhlZFNlcTtcblxuU2VxLnByb3RvdHlwZVtJU19TRVFfU1lNQk9MXSA9IHRydWU7XG5cbi8vICNwcmFnbWEgUm9vdCBTZXF1ZW5jZXNcblxudmFyIEFycmF5U2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSkge1xuICBmdW5jdGlvbiBBcnJheVNlcShhcnJheSkge1xuICAgIHRoaXMuX2FycmF5ID0gYXJyYXk7XG4gICAgdGhpcy5zaXplID0gYXJyYXkubGVuZ3RoO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkU2VxICkgQXJyYXlTZXEuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgQXJyYXlTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICBBcnJheVNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJheVNlcTtcblxuICBBcnJheVNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID8gdGhpcy5fYXJyYXlbd3JhcEluZGV4KHRoaXMsIGluZGV4KV0gOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgIHZhciBzaXplID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgdmFyIGlpID0gcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKys7XG4gICAgICBpZiAoZm4oYXJyYXlbaWldLCBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICB2YXIgc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgaWkgPSByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKztcbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGlpLCBhcnJheVtpaV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBBcnJheVNlcTtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgT2JqZWN0U2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoS2V5ZWRTZXEpIHtcbiAgZnVuY3Rpb24gT2JqZWN0U2VxKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICB0aGlzLl9vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgdGhpcy5zaXplID0ga2V5cy5sZW5ndGg7XG4gIH1cblxuICBpZiAoIEtleWVkU2VxICkgT2JqZWN0U2VxLl9fcHJvdG9fXyA9IEtleWVkU2VxO1xuICBPYmplY3RTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRTZXEgJiYgS2V5ZWRTZXEucHJvdG90eXBlICk7XG4gIE9iamVjdFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPYmplY3RTZXE7XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICBpZiAobm90U2V0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0W2tleV07XG4gIH07XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX29iamVjdCwga2V5KTtcbiAgfTtcblxuICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICB2YXIgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgaWYgKGZuKG9iamVjdFtrZXldLCBrZXksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgIHZhciBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwga2V5LCBvYmplY3Rba2V5XSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdFNlcTtcbn0oS2V5ZWRTZXEpKTtcbk9iamVjdFNlcS5wcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxudmFyIENvbGxlY3Rpb25TZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gIGZ1bmN0aW9uIENvbGxlY3Rpb25TZXEoY29sbGVjdGlvbikge1xuICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgIHRoaXMuc2l6ZSA9IGNvbGxlY3Rpb24ubGVuZ3RoIHx8IGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuXG4gIGlmICggSW5kZXhlZFNlcSApIENvbGxlY3Rpb25TZXEuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gIENvbGxlY3Rpb25TZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29sbGVjdGlvblNlcTtcblxuICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIF9faXRlcmF0ZVVuY2FjaGVkIChmbiwgcmV2ZXJzZSkge1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbjtcbiAgICB2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihjb2xsZWN0aW9uKTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgaWYgKGlzSXRlcmF0b3IoaXRlcmF0b3IpKSB7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gX19pdGVyYXRvclVuY2FjaGVkICh0eXBlLCByZXZlcnNlKSB7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNJdGVyYXRvcihpdGVyYXRvcikpIHtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoaXRlcmF0b3JEb25lKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ29sbGVjdGlvblNlcTtcbn0oSW5kZXhlZFNlcSkpO1xuXG4vLyAjIHByYWdtYSBIZWxwZXIgZnVuY3Rpb25zXG5cbnZhciBFTVBUWV9TRVE7XG5cbmZ1bmN0aW9uIGVtcHR5U2VxdWVuY2UoKSB7XG4gIHJldHVybiBFTVBUWV9TRVEgfHwgKEVNUFRZX1NFUSA9IG5ldyBBcnJheVNlcShbXSkpO1xufVxuXG5mdW5jdGlvbiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICB2YXIgc2VxID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICA/IG5ldyBBcnJheVNlcSh2YWx1ZSlcbiAgICA6IGhhc0l0ZXJhdG9yKHZhbHVlKVxuICAgICAgPyBuZXcgQ29sbGVjdGlvblNlcSh2YWx1ZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZiAoc2VxKSB7XG4gICAgcmV0dXJuIHNlcS5mcm9tRW50cnlTZXEoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBuZXcgT2JqZWN0U2VxKHZhbHVlKTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdFeHBlY3RlZCBBcnJheSBvciBjb2xsZWN0aW9uIG9iamVjdCBvZiBbaywgdl0gZW50cmllcywgb3Iga2V5ZWQgb2JqZWN0OiAnICtcbiAgICAgIHZhbHVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIGlmIChzZXEpIHtcbiAgICByZXR1cm4gc2VxO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ0V4cGVjdGVkIEFycmF5IG9yIGNvbGxlY3Rpb24gb2JqZWN0IG9mIHZhbHVlczogJyArIHZhbHVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICB2YXIgc2VxID0gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgaWYgKHNlcSkge1xuICAgIHJldHVybiBzZXE7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdFNlcSh2YWx1ZSk7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgY29sbGVjdGlvbiBvYmplY3Qgb2YgdmFsdWVzLCBvciBrZXllZCBvYmplY3Q6ICcgKyB2YWx1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKHZhbHVlKVxuICAgID8gbmV3IEFycmF5U2VxKHZhbHVlKVxuICAgIDogaGFzSXRlcmF0b3IodmFsdWUpXG4gICAgICA/IG5ldyBDb2xsZWN0aW9uU2VxKHZhbHVlKVxuICAgICAgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBJU19NQVBfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfTUFQX19AQCc7XG5cbmZ1bmN0aW9uIGlzTWFwKG1heWJlTWFwKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlTWFwICYmIG1heWJlTWFwW0lTX01BUF9TWU1CT0xdKTtcbn1cblxuZnVuY3Rpb24gaXNPcmRlcmVkTWFwKG1heWJlT3JkZXJlZE1hcCkge1xuICByZXR1cm4gaXNNYXAobWF5YmVPcmRlcmVkTWFwKSAmJiBpc09yZGVyZWQobWF5YmVPcmRlcmVkTWFwKTtcbn1cblxuZnVuY3Rpb24gaXNWYWx1ZU9iamVjdChtYXliZVZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIG1heWJlVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBtYXliZVZhbHVlLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIG1heWJlVmFsdWUuaGFzaENvZGUgPT09ICdmdW5jdGlvbidcbiAgKTtcbn1cblxuLyoqXG4gKiBBbiBleHRlbnNpb24gb2YgdGhlIFwic2FtZS12YWx1ZVwiIGFsZ29yaXRobSBhcyBbZGVzY3JpYmVkIGZvciB1c2UgYnkgRVM2IE1hcFxuICogYW5kIFNldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwI0tleV9lcXVhbGl0eSlcbiAqXG4gKiBOYU4gaXMgY29uc2lkZXJlZCB0aGUgc2FtZSBhcyBOYU4sIGhvd2V2ZXIgLTAgYW5kIDAgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAqIHZhbHVlLCB3aGljaCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBieVxuICogW2BPYmplY3QuaXNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXMpLlxuICpcbiAqIFRoaXMgaXMgZXh0ZW5kZWQgZnVydGhlciB0byBhbGxvdyBPYmplY3RzIHRvIGRlc2NyaWJlIHRoZSB2YWx1ZXMgdGhleVxuICogcmVwcmVzZW50LCBieSB3YXkgb2YgYHZhbHVlT2ZgIG9yIGBlcXVhbHNgIChhbmQgYGhhc2hDb2RlYCkuXG4gKlxuICogTm90ZTogYmVjYXVzZSBvZiB0aGlzIGV4dGVuc2lvbiwgdGhlIGtleSBlcXVhbGl0eSBvZiBJbW11dGFibGUuTWFwIGFuZCB0aGVcbiAqIHZhbHVlIGVxdWFsaXR5IG9mIEltbXV0YWJsZS5TZXQgd2lsbCBkaWZmZXIgZnJvbSBFUzYgTWFwIGFuZCBTZXQuXG4gKlxuICogIyMjIERlZmluaW5nIGN1c3RvbSB2YWx1ZXNcbiAqXG4gKiBUaGUgZWFzaWVzdCB3YXkgdG8gZGVzY3JpYmUgdGhlIHZhbHVlIGFuIG9iamVjdCByZXByZXNlbnRzIGlzIGJ5IGltcGxlbWVudGluZ1xuICogYHZhbHVlT2ZgLiBGb3IgZXhhbXBsZSwgYERhdGVgIHJlcHJlc2VudHMgYSB2YWx1ZSBieSByZXR1cm5pbmcgYSB1bml4XG4gKiB0aW1lc3RhbXAgZm9yIGB2YWx1ZU9mYDpcbiAqXG4gKiAgICAgdmFyIGRhdGUxID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7IC8vIEZyaSBGZWIgMTMgMjAwOSAuLi5cbiAqICAgICB2YXIgZGF0ZTIgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTtcbiAqICAgICBkYXRlMS52YWx1ZU9mKCk7IC8vIDEyMzQ1Njc4OTAwMDBcbiAqICAgICBhc3NlcnQoIGRhdGUxICE9PSBkYXRlMiApO1xuICogICAgIGFzc2VydCggSW1tdXRhYmxlLmlzKCBkYXRlMSwgZGF0ZTIgKSApO1xuICpcbiAqIE5vdGU6IG92ZXJyaWRpbmcgYHZhbHVlT2ZgIG1heSBoYXZlIG90aGVyIGltcGxpY2F0aW9ucyBpZiB5b3UgdXNlIHRoaXMgb2JqZWN0XG4gKiB3aGVyZSBKYXZhU2NyaXB0IGV4cGVjdHMgYSBwcmltaXRpdmUsIHN1Y2ggYXMgaW1wbGljaXQgc3RyaW5nIGNvZXJjaW9uLlxuICpcbiAqIEZvciBtb3JlIGNvbXBsZXggdHlwZXMsIGVzcGVjaWFsbHkgY29sbGVjdGlvbnMsIGltcGxlbWVudGluZyBgdmFsdWVPZmAgbWF5XG4gKiBub3QgYmUgcGVyZm9ybWFudC4gQW4gYWx0ZXJuYXRpdmUgaXMgdG8gaW1wbGVtZW50IGBlcXVhbHNgIGFuZCBgaGFzaENvZGVgLlxuICpcbiAqIGBlcXVhbHNgIHRha2VzIGFub3RoZXIgb2JqZWN0LCBwcmVzdW1hYmx5IG9mIHNpbWlsYXIgdHlwZSwgYW5kIHJldHVybnMgdHJ1ZVxuICogaWYgaXQgaXMgZXF1YWwuIEVxdWFsaXR5IGlzIHN5bW1ldHJpY2FsLCBzbyB0aGUgc2FtZSByZXN1bHQgc2hvdWxkIGJlXG4gKiByZXR1cm5lZCBpZiB0aGlzIGFuZCB0aGUgYXJndW1lbnQgYXJlIGZsaXBwZWQuXG4gKlxuICogICAgIGFzc2VydCggYS5lcXVhbHMoYikgPT09IGIuZXF1YWxzKGEpICk7XG4gKlxuICogYGhhc2hDb2RlYCByZXR1cm5zIGEgMzJiaXQgaW50ZWdlciBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBvYmplY3Qgd2hpY2ggd2lsbFxuICogYmUgdXNlZCB0byBkZXRlcm1pbmUgaG93IHRvIHN0b3JlIHRoZSB2YWx1ZSBvYmplY3QgaW4gYSBNYXAgb3IgU2V0LiBZb3UgbXVzdFxuICogcHJvdmlkZSBib3RoIG9yIG5laXRoZXIgbWV0aG9kcywgb25lIG11c3Qgbm90IGV4aXN0IHdpdGhvdXQgdGhlIG90aGVyLlxuICpcbiAqIEFsc28sIGFuIGltcG9ydGFudCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGVzZSBtZXRob2RzIG11c3QgYmUgdXBoZWxkOiBpZiB0d29cbiAqIHZhbHVlcyBhcmUgZXF1YWwsIHRoZXkgKm11c3QqIHJldHVybiB0aGUgc2FtZSBoYXNoQ29kZS4gSWYgdGhlIHZhbHVlcyBhcmUgbm90XG4gKiBlcXVhbCwgdGhleSBtaWdodCBoYXZlIHRoZSBzYW1lIGhhc2hDb2RlOyB0aGlzIGlzIGNhbGxlZCBhIGhhc2ggY29sbGlzaW9uLFxuICogYW5kIHdoaWxlIHVuZGVzaXJhYmxlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBpcyBhY2NlcHRhYmxlLlxuICpcbiAqICAgICBpZiAoYS5lcXVhbHMoYikpIHtcbiAqICAgICAgIGFzc2VydCggYS5oYXNoQ29kZSgpID09PSBiLmhhc2hDb2RlKCkgKTtcbiAqICAgICB9XG4gKlxuICogQWxsIEltbXV0YWJsZSBjb2xsZWN0aW9ucyBhcmUgVmFsdWUgT2JqZWN0czogdGhleSBpbXBsZW1lbnQgYGVxdWFscygpYFxuICogYW5kIGBoYXNoQ29kZSgpYC5cbiAqL1xuZnVuY3Rpb24gaXModmFsdWVBLCB2YWx1ZUIpIHtcbiAgaWYgKHZhbHVlQSA9PT0gdmFsdWVCIHx8ICh2YWx1ZUEgIT09IHZhbHVlQSAmJiB2YWx1ZUIgIT09IHZhbHVlQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXZhbHVlQSB8fCAhdmFsdWVCKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChcbiAgICB0eXBlb2YgdmFsdWVBLnZhbHVlT2YgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsdWVCLnZhbHVlT2YgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgdmFsdWVBID0gdmFsdWVBLnZhbHVlT2YoKTtcbiAgICB2YWx1ZUIgPSB2YWx1ZUIudmFsdWVPZigpO1xuICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gISEoXG4gICAgaXNWYWx1ZU9iamVjdCh2YWx1ZUEpICYmXG4gICAgaXNWYWx1ZU9iamVjdCh2YWx1ZUIpICYmXG4gICAgdmFsdWVBLmVxdWFscyh2YWx1ZUIpXG4gICk7XG59XG5cbnZhciBpbXVsID1cbiAgdHlwZW9mIE1hdGguaW11bCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXRoLmltdWwoMHhmZmZmZmZmZiwgMikgPT09IC0yXG4gICAgPyBNYXRoLmltdWxcbiAgICA6IGZ1bmN0aW9uIGltdWwoYSwgYikge1xuICAgICAgICBhIHw9IDA7IC8vIGludFxuICAgICAgICBiIHw9IDA7IC8vIGludFxuICAgICAgICB2YXIgYyA9IGEgJiAweGZmZmY7XG4gICAgICAgIHZhciBkID0gYiAmIDB4ZmZmZjtcbiAgICAgICAgLy8gU2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0LlxuICAgICAgICByZXR1cm4gKGMgKiBkICsgKCgoKGEgPj4+IDE2KSAqIGQgKyBjICogKGIgPj4+IDE2KSkgPDwgMTYpID4+PiAwKSkgfCAwOyAvLyBpbnRcbiAgICAgIH07XG5cbi8vIHY4IGhhcyBhbiBvcHRpbWl6YXRpb24gZm9yIHN0b3JpbmcgMzEtYml0IHNpZ25lZCBudW1iZXJzLlxuLy8gVmFsdWVzIHdoaWNoIGhhdmUgZWl0aGVyIDAwIG9yIDExIGFzIHRoZSBoaWdoIG9yZGVyIGJpdHMgcXVhbGlmeS5cbi8vIFRoaXMgZnVuY3Rpb24gZHJvcHMgdGhlIGhpZ2hlc3Qgb3JkZXIgYml0IGluIGEgc2lnbmVkIG51bWJlciwgbWFpbnRhaW5pbmdcbi8vIHRoZSBzaWduIGJpdC5cbmZ1bmN0aW9uIHNtaShpMzIpIHtcbiAgcmV0dXJuICgoaTMyID4+PiAxKSAmIDB4NDAwMDAwMDApIHwgKGkzMiAmIDB4YmZmZmZmZmYpO1xufVxuXG52YXIgZGVmYXVsdFZhbHVlT2YgPSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2Y7XG5cbmZ1bmN0aW9uIGhhc2gobykge1xuICBzd2l0Y2ggKHR5cGVvZiBvKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAvLyBUaGUgaGFzaCB2YWx1ZXMgZm9yIGJ1aWx0LWluIGNvbnN0YW50cyBhcmUgYSAxIHZhbHVlIGZvciBlYWNoIDUtYnl0ZVxuICAgICAgLy8gc2hpZnQgcmVnaW9uIGV4cGVjdCBmb3IgdGhlIGZpcnN0LCB3aGljaCBlbmNvZGVzIHRoZSB2YWx1ZS4gVGhpc1xuICAgICAgLy8gcmVkdWNlcyB0aGUgb2RkcyBvZiBhIGhhc2ggY29sbGlzaW9uIGZvciB0aGVzZSBjb21tb24gdmFsdWVzLlxuICAgICAgcmV0dXJuIG8gPyAweDQyMTA4NDIxIDogMHg0MjEwODQyMDtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGhhc2hOdW1iZXIobyk7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBvLmxlbmd0aCA+IFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU5cbiAgICAgICAgPyBjYWNoZWRIYXNoU3RyaW5nKG8pXG4gICAgICAgIDogaGFzaFN0cmluZyhvKTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGlmIChvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAweDQyMTA4NDIyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIERyb3AgYW55IGhpZ2ggYml0cyBmcm9tIGFjY2lkZW50YWxseSBsb25nIGhhc2ggY29kZXMuXG4gICAgICAgIHJldHVybiBzbWkoby5oYXNoQ29kZShvKSk7XG4gICAgICB9XG4gICAgICBpZiAoby52YWx1ZU9mICE9PSBkZWZhdWx0VmFsdWVPZiAmJiB0eXBlb2Ygby52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG8gPSBvLnZhbHVlT2Yobyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzaEpTT2JqKG8pO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gMHg0MjEwODQyMztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBvLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBoYXNoU3RyaW5nKG8udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHR5cGUgJyArIHR5cGVvZiBvICsgJyBjYW5ub3QgYmUgaGFzaGVkLicpO1xuICB9XG59XG5cbi8vIENvbXByZXNzIGFyYml0cmFyaWx5IGxhcmdlIG51bWJlcnMgaW50byBzbWkgaGFzaGVzLlxuZnVuY3Rpb24gaGFzaE51bWJlcihuKSB7XG4gIGlmIChuICE9PSBuIHx8IG4gPT09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIGhhc2ggPSBuIHwgMDtcbiAgaWYgKGhhc2ggIT09IG4pIHtcbiAgICBoYXNoIF49IG4gKiAweGZmZmZmZmZmO1xuICB9XG4gIHdoaWxlIChuID4gMHhmZmZmZmZmZikge1xuICAgIG4gLz0gMHhmZmZmZmZmZjtcbiAgICBoYXNoIF49IG47XG4gIH1cbiAgcmV0dXJuIHNtaShoYXNoKTtcbn1cblxuZnVuY3Rpb24gY2FjaGVkSGFzaFN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIGhhc2hlZCA9IHN0cmluZ0hhc2hDYWNoZVtzdHJpbmddO1xuICBpZiAoaGFzaGVkID09PSB1bmRlZmluZWQpIHtcbiAgICBoYXNoZWQgPSBoYXNoU3RyaW5nKHN0cmluZyk7XG4gICAgaWYgKFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPT09IFNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFKSB7XG4gICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgICAgIHN0cmluZ0hhc2hDYWNoZSA9IHt9O1xuICAgIH1cbiAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFKys7XG4gICAgc3RyaW5nSGFzaENhY2hlW3N0cmluZ10gPSBoYXNoZWQ7XG4gIH1cbiAgcmV0dXJuIGhhc2hlZDtcbn1cblxuLy8gaHR0cDovL2pzcGVyZi5jb20vaGFzaGluZy1zdHJpbmdzXG5mdW5jdGlvbiBoYXNoU3RyaW5nKHN0cmluZykge1xuICAvLyBUaGlzIGlzIHRoZSBoYXNoIGZyb20gSlZNXG4gIC8vIFRoZSBoYXNoIGNvZGUgZm9yIGEgc3RyaW5nIGlzIGNvbXB1dGVkIGFzXG4gIC8vIHNbMF0gKiAzMSBeIChuIC0gMSkgKyBzWzFdICogMzEgXiAobiAtIDIpICsgLi4uICsgc1tuIC0gMV0sXG4gIC8vIHdoZXJlIHNbaV0gaXMgdGhlIGl0aCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyBhbmQgbiBpcyB0aGUgbGVuZ3RoIG9mXG4gIC8vIHRoZSBzdHJpbmcuIFdlIFwibW9kXCIgdGhlIHJlc3VsdCB0byBtYWtlIGl0IGJldHdlZW4gMCAoaW5jbHVzaXZlKSBhbmQgMl4zMVxuICAvLyAoZXhjbHVzaXZlKSBieSBkcm9wcGluZyBoaWdoIGJpdHMuXG4gIHZhciBoYXNoZWQgPSAwO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc3RyaW5nLmxlbmd0aDsgaWkrKykge1xuICAgIGhhc2hlZCA9ICgzMSAqIGhhc2hlZCArIHN0cmluZy5jaGFyQ29kZUF0KGlpKSkgfCAwO1xuICB9XG4gIHJldHVybiBzbWkoaGFzaGVkKTtcbn1cblxuZnVuY3Rpb24gaGFzaEpTT2JqKG9iaikge1xuICB2YXIgaGFzaGVkO1xuICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgaGFzaGVkID0gd2Vha01hcC5nZXQob2JqKTtcbiAgICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYXNoZWQ7XG4gICAgfVxuICB9XG5cbiAgaGFzaGVkID0gb2JqW1VJRF9IQVNIX0tFWV07XG4gIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNoZWQ7XG4gIH1cblxuICBpZiAoIWNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgaGFzaGVkID0gb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlICYmIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZVtVSURfSEFTSF9LRVldO1xuICAgIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhc2hlZDtcbiAgICB9XG5cbiAgICBoYXNoZWQgPSBnZXRJRU5vZGVIYXNoKG9iaik7XG4gICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaGFzaGVkO1xuICAgIH1cbiAgfVxuXG4gIGhhc2hlZCA9ICsrb2JqSGFzaFVJRDtcbiAgaWYgKG9iakhhc2hVSUQgJiAweDQwMDAwMDAwKSB7XG4gICAgb2JqSGFzaFVJRCA9IDA7XG4gIH1cblxuICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgd2Vha01hcC5zZXQob2JqLCBoYXNoZWQpO1xuICB9IGVsc2UgaWYgKGlzRXh0ZW5zaWJsZSAhPT0gdW5kZWZpbmVkICYmIGlzRXh0ZW5zaWJsZShvYmopID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWV4dGVuc2libGUgb2JqZWN0cyBhcmUgbm90IGFsbG93ZWQgYXMga2V5cy4nKTtcbiAgfSBlbHNlIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFVJRF9IQVNIX0tFWSwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IGhhc2hlZCxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChcbiAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgIT09IHVuZGVmaW5lZCAmJlxuICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9PT0gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICApIHtcbiAgICAvLyBTaW5jZSB3ZSBjYW4ndCBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0XG4gICAgLy8gd2UnbGwgaGlqYWNrIG9uZSBvZiB0aGUgbGVzcy11c2VkIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgdG9cbiAgICAvLyBzYXZlIG91ciBoYXNoIG9uIGl0LiBTaW5jZSB0aGlzIGlzIGEgZnVuY3Rpb24gaXQgd2lsbCBub3Qgc2hvdyB1cCBpblxuICAgIC8vIGBKU09OLnN0cmluZ2lmeWAgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmFwcGx5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBhcmd1bWVudHNcbiAgICAgICk7XG4gICAgfTtcbiAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXSA9IGhhc2hlZDtcbiAgfSBlbHNlIGlmIChvYmoubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY291bGRuJ3QgZ2V0IHRoZSBJRSBgdW5pcXVlSURgIHRvIHVzZSBhcyBhIGhhc2hcbiAgICAvLyBhbmQgd2UgY291bGRuJ3QgdXNlIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgdG8gZXhwbG9pdCB0aGVcbiAgICAvLyBkb250RW51bSBidWcgc28gd2Ugc2ltcGx5IGFkZCB0aGUgYFVJRF9IQVNIX0tFWWAgb24gdGhlIG5vZGVcbiAgICAvLyBpdHNlbGYuXG4gICAgb2JqW1VJRF9IQVNIX0tFWV0gPSBoYXNoZWQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gb2JqZWN0LicpO1xuICB9XG5cbiAgcmV0dXJuIGhhc2hlZDtcbn1cblxuLy8gR2V0IHJlZmVyZW5jZXMgdG8gRVM1IG9iamVjdCBtZXRob2RzLlxudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbi8vIFRydWUgaWYgT2JqZWN0LmRlZmluZVByb3BlcnR5IHdvcmtzIGFzIGV4cGVjdGVkLiBJRTggZmFpbHMgdGhpcyB0ZXN0LlxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ0AnLCB7fSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8vIElFIGhhcyBhIGB1bmlxdWVJRGAgcHJvcGVydHkgb24gRE9NIG5vZGVzLiBXZSBjYW4gY29uc3RydWN0IHRoZSBoYXNoIGZyb20gaXRcbi8vIGFuZCBhdm9pZCBtZW1vcnkgbGVha3MgZnJvbSB0aGUgSUUgY2xvbmVOb2RlIGJ1Zy5cbmZ1bmN0aW9uIGdldElFTm9kZUhhc2gobm9kZSkge1xuICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID4gMCkge1xuICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgY2FzZSAxOiAvLyBFbGVtZW50XG4gICAgICAgIHJldHVybiBub2RlLnVuaXF1ZUlEO1xuICAgICAgY2FzZSA5OiAvLyBEb2N1bWVudFxuICAgICAgICByZXR1cm4gbm9kZS5kb2N1bWVudEVsZW1lbnQgJiYgbm9kZS5kb2N1bWVudEVsZW1lbnQudW5pcXVlSUQ7XG4gICAgfVxuICB9XG59XG5cbi8vIElmIHBvc3NpYmxlLCB1c2UgYSBXZWFrTWFwLlxudmFyIHVzaW5nV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nO1xudmFyIHdlYWtNYXA7XG5pZiAodXNpbmdXZWFrTWFwKSB7XG4gIHdlYWtNYXAgPSBuZXcgV2Vha01hcCgpO1xufVxuXG52YXIgb2JqSGFzaFVJRCA9IDA7XG5cbnZhciBVSURfSEFTSF9LRVkgPSAnX19pbW11dGFibGVoYXNoX18nO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgVUlEX0hBU0hfS0VZID0gU3ltYm9sKFVJRF9IQVNIX0tFWSk7XG59XG5cbnZhciBTVFJJTkdfSEFTSF9DQUNIRV9NSU5fU1RSTEVOID0gMTY7XG52YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUgPSAyNTU7XG52YXIgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9IDA7XG52YXIgc3RyaW5nSGFzaENhY2hlID0ge307XG5cbnZhciBUb0tleWVkU2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZFNlcSQkMSkge1xuICBmdW5jdGlvbiBUb0tleWVkU2VxdWVuY2UoaW5kZXhlZCwgdXNlS2V5cykge1xuICAgIHRoaXMuX2l0ZXIgPSBpbmRleGVkO1xuICAgIHRoaXMuX3VzZUtleXMgPSB1c2VLZXlzO1xuICAgIHRoaXMuc2l6ZSA9IGluZGV4ZWQuc2l6ZTtcbiAgfVxuXG4gIGlmICggS2V5ZWRTZXEkJDEgKSBUb0tleWVkU2VxdWVuY2UuX19wcm90b19fID0gS2V5ZWRTZXEkJDE7XG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZFNlcSQkMSAmJiBLZXllZFNlcSQkMS5wcm90b3R5cGUgKTtcbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvS2V5ZWRTZXF1ZW5jZTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLmdldChrZXksIG5vdFNldFZhbHVlKTtcbiAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuaGFzKGtleSk7XG4gIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS52YWx1ZVNlcSA9IGZ1bmN0aW9uIHZhbHVlU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci52YWx1ZVNlcSgpO1xuICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKTtcbiAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgIHJldmVyc2VkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuX2l0ZXIudG9TZXEoKS5yZXZlcnNlKCk7IH07XG4gICAgfVxuICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KTtcbiAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgIG1hcHBlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLl9pdGVyLnRvU2VxKCkubWFwKG1hcHBlciwgY29udGV4dCk7IH07XG4gICAgfVxuICAgIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbiAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgaywgdGhpcyQxKTsgfSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgcmV0dXJuIFRvS2V5ZWRTZXF1ZW5jZTtcbn0oS2V5ZWRTZXEpKTtcblRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxudmFyIFRvSW5kZXhlZFNlcXVlbmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSQkMSkge1xuICBmdW5jdGlvbiBUb0luZGV4ZWRTZXF1ZW5jZShpdGVyKSB7XG4gICAgdGhpcy5faXRlciA9IGl0ZXI7XG4gICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkU2VxJCQxICkgVG9JbmRleGVkU2VxdWVuY2UuX19wcm90b19fID0gSW5kZXhlZFNlcSQkMTtcbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSQkMSAmJiBJbmRleGVkU2VxJCQxLnByb3RvdHlwZSApO1xuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb0luZGV4ZWRTZXF1ZW5jZTtcblxuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyh2YWx1ZSk7XG4gIH07XG5cbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpID0gMDtcbiAgICByZXZlcnNlICYmIGVuc3VyZVNpemUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZuKHYsIHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKywgdGhpcyQxKTsgfSxcbiAgICAgIHJldmVyc2VcbiAgICApO1xuICB9O1xuXG4gIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKHRoaXMpO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3RlcC5kb25lXG4gICAgICAgID8gc3RlcFxuICAgICAgICA6IGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcmV2ZXJzZSA/IHRoaXMkMS5zaXplIC0gKytpIDogaSsrLFxuICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICApO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUb0luZGV4ZWRTZXF1ZW5jZTtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgVG9TZXRTZXF1ZW5jZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNldFNlcSQkMSkge1xuICBmdW5jdGlvbiBUb1NldFNlcXVlbmNlKGl0ZXIpIHtcbiAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gIH1cblxuICBpZiAoIFNldFNlcSQkMSApIFRvU2V0U2VxdWVuY2UuX19wcm90b19fID0gU2V0U2VxJCQxO1xuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldFNlcSQkMSAmJiBTZXRTZXEkJDEucHJvdG90eXBlICk7XG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9TZXRTZXF1ZW5jZTtcblxuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKGtleSk7XG4gIH07XG5cbiAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2KSB7IHJldHVybiBmbih2LCB2LCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgfTtcblxuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHJldHVybiBzdGVwLmRvbmVcbiAgICAgICAgPyBzdGVwXG4gICAgICAgIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBzdGVwLnZhbHVlLCBzdGVwLnZhbHVlLCBzdGVwKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVG9TZXRTZXF1ZW5jZTtcbn0oU2V0U2VxKSk7XG5cbnZhciBGcm9tRW50cmllc1NlcXVlbmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoS2V5ZWRTZXEkJDEpIHtcbiAgZnVuY3Rpb24gRnJvbUVudHJpZXNTZXF1ZW5jZShlbnRyaWVzKSB7XG4gICAgdGhpcy5faXRlciA9IGVudHJpZXM7XG4gICAgdGhpcy5zaXplID0gZW50cmllcy5zaXplO1xuICB9XG5cbiAgaWYgKCBLZXllZFNlcSQkMSApIEZyb21FbnRyaWVzU2VxdWVuY2UuX19wcm90b19fID0gS2V5ZWRTZXEkJDE7XG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRTZXEkJDEgJiYgS2V5ZWRTZXEkJDEucHJvdG90eXBlICk7XG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJvbUVudHJpZXNTZXF1ZW5jZTtcblxuICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5lbnRyeVNlcSA9IGZ1bmN0aW9uIGVudHJ5U2VxICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci50b1NlcSgpO1xuICB9O1xuXG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBmaXJzdCBzbyBhcnJheSBhY2Nlc3MgZG9lc24ndCB0aHJvdyBmb3IgaG9sZXNcbiAgICAgIC8vIGluIHRoZSBwYXJlbnQgaXRlcmF0aW9uLlxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHZhbGlkYXRlRW50cnkoZW50cnkpO1xuICAgICAgICB2YXIgaW5kZXhlZENvbGxlY3Rpb24gPSBpc0NvbGxlY3Rpb24oZW50cnkpO1xuICAgICAgICByZXR1cm4gZm4oXG4gICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgIHRoaXMkMVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIHJldmVyc2UpO1xuICB9O1xuXG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgICAgdmFyIGluZGV4ZWRDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uKGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEZyb21FbnRyaWVzU2VxdWVuY2U7XG59KEtleWVkU2VxKSk7XG5cblRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPSBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuXG5mdW5jdGlvbiBmbGlwRmFjdG9yeShjb2xsZWN0aW9uKSB7XG4gIHZhciBmbGlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGZsaXBTZXF1ZW5jZS5faXRlciA9IGNvbGxlY3Rpb247XG4gIGZsaXBTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplO1xuICBmbGlwU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb247IH07XG4gIGZsaXBTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBjb2xsZWN0aW9uLnJldmVyc2UuYXBwbHkodGhpcyk7IC8vIHN1cGVyLnJldmVyc2UoKVxuICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24ucmV2ZXJzZSgpOyB9O1xuICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICB9O1xuICBmbGlwU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5pbmNsdWRlcyhrZXkpOyB9O1xuICBmbGlwU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyhrZXkpOyB9O1xuICBmbGlwU2VxdWVuY2UuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdFRocm91Z2g7XG4gIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZuKGssIHYsIHRoaXMkMSkgIT09IGZhbHNlOyB9LCByZXZlcnNlKTtcbiAgfTtcbiAgZmxpcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmICghc3RlcC5kb25lKSB7XG4gICAgICAgICAgdmFyIGsgPSBzdGVwLnZhbHVlWzBdO1xuICAgICAgICAgIHN0ZXAudmFsdWVbMF0gPSBzdGVwLnZhbHVlWzFdO1xuICAgICAgICAgIHN0ZXAudmFsdWVbMV0gPSBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0b3IoXG4gICAgICB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUyA/IElURVJBVEVfS0VZUyA6IElURVJBVEVfVkFMVUVTLFxuICAgICAgcmV2ZXJzZVxuICAgICk7XG4gIH07XG4gIHJldHVybiBmbGlwU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIG1hcEZhY3RvcnkoY29sbGVjdGlvbiwgbWFwcGVyLCBjb250ZXh0KSB7XG4gIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgbWFwcGVkU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcbiAgbWFwcGVkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5oYXMoa2V5KTsgfTtcbiAgbWFwcGVkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgdiA9IGNvbGxlY3Rpb24uZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgcmV0dXJuIHYgPT09IE5PVF9TRVRcbiAgICAgID8gbm90U2V0VmFsdWVcbiAgICAgIDogbWFwcGVyLmNhbGwoY29udGV4dCwgdiwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfTtcbiAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKHYsIGssIGMpIHsgcmV0dXJuIGZuKG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGssIGMpLCBrLCB0aGlzJDEpICE9PSBmYWxzZTsgfSxcbiAgICAgIHJldmVyc2VcbiAgICApO1xuICB9O1xuICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9XG4gICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGtleSxcbiAgICAgICAgbWFwcGVyLmNhbGwoY29udGV4dCwgZW50cnlbMV0sIGtleSwgY29sbGVjdGlvbiksXG4gICAgICAgIHN0ZXBcbiAgICAgICk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZUZhY3RvcnkoY29sbGVjdGlvbiwgdXNlS2V5cykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5faXRlciA9IGNvbGxlY3Rpb247XG4gIHJldmVyc2VkU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbjsgfTtcbiAgaWYgKGNvbGxlY3Rpb24uZmxpcCkge1xuICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZsaXBTZXF1ZW5jZSA9IGZsaXBGYWN0b3J5KGNvbGxlY3Rpb24pO1xuICAgICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uLmZsaXAoKTsgfTtcbiAgICAgIHJldHVybiBmbGlwU2VxdWVuY2U7XG4gICAgfTtcbiAgfVxuICByZXZlcnNlZFNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uIChrZXksIG5vdFNldFZhbHVlKSB7IHJldHVybiBjb2xsZWN0aW9uLmdldCh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXksIG5vdFNldFZhbHVlKTsgfTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXkpOyB9O1xuICByZXZlcnNlZFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBjb2xsZWN0aW9uLmluY2x1ZGVzKHZhbHVlKTsgfTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5jYWNoZVJlc3VsdCA9IGNhY2hlUmVzdWx0VGhyb3VnaDtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZShjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiByZXZlcnNlID8gdGhpcyQxLnNpemUgLSArK2kgOiBpKyssIHRoaXMkMSk7IH0sXG4gICAgICAhcmV2ZXJzZVxuICAgICk7XG4gIH07XG4gIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRvciA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZShjb2xsZWN0aW9uKTtcbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCAhcmV2ZXJzZSk7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9XG4gICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHVzZUtleXMgPyBlbnRyeVswXSA6IHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKyxcbiAgICAgICAgZW50cnlbMV0sXG4gICAgICAgIHN0ZXBcbiAgICAgICk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJGYWN0b3J5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgY29udGV4dCwgdXNlS2V5cykge1xuICB2YXIgZmlsdGVyU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGlmICh1c2VLZXlzKSB7XG4gICAgZmlsdGVyU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHYgPSBjb2xsZWN0aW9uLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgISFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrZXksIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgZmlsdGVyU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciB2ID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgIHJldHVybiB2ICE9PSBOT1RfU0VUICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgY29sbGVjdGlvbilcbiAgICAgICAgPyB2XG4gICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgfTtcbiAgfVxuICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpO1xuICAgICAgfVxuICAgIH0sIHJldmVyc2UpO1xuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5WzFdO1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCB1c2VLZXlzID8ga2V5IDogaXRlcmF0aW9ucysrLCB2YWx1ZSwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIGZpbHRlclNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBjb3VudEJ5RmFjdG9yeShjb2xsZWN0aW9uLCBncm91cGVyLCBjb250ZXh0KSB7XG4gIHZhciBncm91cHMgPSBNYXAoKS5hc011dGFibGUoKTtcbiAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICBncm91cHMudXBkYXRlKGdyb3VwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjb2xsZWN0aW9uKSwgMCwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgKyAxOyB9KTtcbiAgfSk7XG4gIHJldHVybiBncm91cHMuYXNJbW11dGFibGUoKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBCeUZhY3RvcnkoY29sbGVjdGlvbiwgZ3JvdXBlciwgY29udGV4dCkge1xuICB2YXIgaXNLZXllZEl0ZXIgPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICB2YXIgZ3JvdXBzID0gKGlzT3JkZXJlZChjb2xsZWN0aW9uKSA/IE9yZGVyZWRNYXAoKSA6IE1hcCgpKS5hc011dGFibGUoKTtcbiAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICBncm91cHMudXBkYXRlKFxuICAgICAgZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pLFxuICAgICAgZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoYSA9IGEgfHwgW10pLCBhLnB1c2goaXNLZXllZEl0ZXIgPyBbaywgdl0gOiB2KSwgYSk7IH1cbiAgICApO1xuICB9KTtcbiAgdmFyIGNvZXJjZSA9IGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKTtcbiAgcmV0dXJuIGdyb3Vwcy5tYXAoZnVuY3Rpb24gKGFycikgeyByZXR1cm4gcmVpZnkoY29sbGVjdGlvbiwgY29lcmNlKGFycikpOyB9KS5hc0ltbXV0YWJsZSgpO1xufVxuXG5mdW5jdGlvbiBzbGljZUZhY3RvcnkoY29sbGVjdGlvbiwgYmVnaW4sIGVuZCwgdXNlS2V5cykge1xuICB2YXIgb3JpZ2luYWxTaXplID0gY29sbGVjdGlvbi5zaXplO1xuXG4gIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIG9yaWdpbmFsU2l6ZSkpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuXG4gIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBvcmlnaW5hbFNpemUpO1xuICB2YXIgcmVzb2x2ZWRFbmQgPSByZXNvbHZlRW5kKGVuZCwgb3JpZ2luYWxTaXplKTtcblxuICAvLyBiZWdpbiBvciBlbmQgd2lsbCBiZSBOYU4gaWYgdGhleSB3ZXJlIHByb3ZpZGVkIGFzIG5lZ2F0aXZlIG51bWJlcnMgYW5kXG4gIC8vIHRoaXMgY29sbGVjdGlvbidzIHNpemUgaXMgdW5rbm93bi4gSW4gdGhhdCBjYXNlLCBjYWNoZSBmaXJzdCBzbyB0aGVyZSBpc1xuICAvLyBhIGtub3duIHNpemUgYW5kIHRoZXNlIGRvIG5vdCByZXNvbHZlIHRvIE5hTi5cbiAgaWYgKHJlc29sdmVkQmVnaW4gIT09IHJlc29sdmVkQmVnaW4gfHwgcmVzb2x2ZWRFbmQgIT09IHJlc29sdmVkRW5kKSB7XG4gICAgcmV0dXJuIHNsaWNlRmFjdG9yeShjb2xsZWN0aW9uLnRvU2VxKCkuY2FjaGVSZXN1bHQoKSwgYmVnaW4sIGVuZCwgdXNlS2V5cyk7XG4gIH1cblxuICAvLyBOb3RlOiByZXNvbHZlZEVuZCBpcyB1bmRlZmluZWQgd2hlbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UncyBsZW5ndGggaXNcbiAgLy8gdW5rbm93biBhbmQgdGhpcyBzbGljZSBkaWQgbm90IHN1cHBseSBhbiBlbmQgYW5kIHNob3VsZCBjb250YWluIGFsbFxuICAvLyBlbGVtZW50cyBhZnRlciByZXNvbHZlZEJlZ2luLlxuICAvLyBJbiB0aGF0IGNhc2UsIHJlc29sdmVkU2l6ZSB3aWxsIGJlIE5hTiBhbmQgc2xpY2VTaXplIHdpbGwgcmVtYWluIHVuZGVmaW5lZC5cbiAgdmFyIHJlc29sdmVkU2l6ZSA9IHJlc29sdmVkRW5kIC0gcmVzb2x2ZWRCZWdpbjtcbiAgdmFyIHNsaWNlU2l6ZTtcbiAgaWYgKHJlc29sdmVkU2l6ZSA9PT0gcmVzb2x2ZWRTaXplKSB7XG4gICAgc2xpY2VTaXplID0gcmVzb2x2ZWRTaXplIDwgMCA/IDAgOiByZXNvbHZlZFNpemU7XG4gIH1cblxuICB2YXIgc2xpY2VTZXEgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG5cbiAgLy8gSWYgY29sbGVjdGlvbi5zaXplIGlzIHVuZGVmaW5lZCwgdGhlIHNpemUgb2YgdGhlIHJlYWxpemVkIHNsaWNlU2VxIGlzXG4gIC8vIHVua25vd24gYXQgdGhpcyBwb2ludCB1bmxlc3MgdGhlIG51bWJlciBvZiBpdGVtcyB0byBzbGljZSBpcyAwXG4gIHNsaWNlU2VxLnNpemUgPVxuICAgIHNsaWNlU2l6ZSA9PT0gMCA/IHNsaWNlU2l6ZSA6IChjb2xsZWN0aW9uLnNpemUgJiYgc2xpY2VTaXplKSB8fCB1bmRlZmluZWQ7XG5cbiAgaWYgKCF1c2VLZXlzICYmIGlzU2VxKGNvbGxlY3Rpb24pICYmIHNsaWNlU2l6ZSA+PSAwKSB7XG4gICAgc2xpY2VTZXEuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHNsaWNlU2l6ZVxuICAgICAgICA/IGNvbGxlY3Rpb24uZ2V0KGluZGV4ICsgcmVzb2x2ZWRCZWdpbiwgbm90U2V0VmFsdWUpXG4gICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHNsaWNlU2VxLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChzbGljZVNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgdmFyIGlzU2tpcHBpbmcgPSB0cnVlO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgaWYgKCEoaXNTa2lwcGluZyAmJiAoaXNTa2lwcGluZyA9IHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pKSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQxKSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICBpdGVyYXRpb25zICE9PSBzbGljZVNpemVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcblxuICBzbGljZVNlcS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgaWYgKHNsaWNlU2l6ZSAhPT0gMCAmJiByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBpbnN0YW50aWF0aW5nIHBhcmVudCBpdGVyYXRvciBpZiB0YWtpbmcgMC5cbiAgICBpZiAoc2xpY2VTaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGl0ZXJhdG9yRG9uZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pIHtcbiAgICAgICAgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgICAgaWYgKCsraXRlcmF0aW9ucyA+IHNsaWNlU2l6ZSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmICh1c2VLZXlzIHx8IHR5cGUgPT09IElURVJBVEVfVkFMVUVTIHx8IHN0ZXAuZG9uZSkge1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucyAtIDEsIHVuZGVmaW5lZCwgc3RlcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHNsaWNlU2VxO1xufVxuXG5mdW5jdGlvbiB0YWtlV2hpbGVGYWN0b3J5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICB2YXIgdGFrZVNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICB0YWtlU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKHYsIGssIGMpIHsgcmV0dXJuIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpICYmICsraXRlcmF0aW9ucyAmJiBmbih2LCBrLCB0aGlzJDEpOyB9XG4gICAgKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgdGFrZVNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgIHZhciBpdGVyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpdGVyYXRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgfVxuICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgIHZhciBrID0gZW50cnlbMF07XG4gICAgICB2YXIgdiA9IGVudHJ5WzFdO1xuICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDEpKSB7XG4gICAgICAgIGl0ZXJhdGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB0YWtlU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIHNraXBXaGlsZUZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gIHZhciBza2lwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpKSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuICBza2lwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgdmFyIHNraXBwaW5nID0gdHJ1ZTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBrO1xuICAgICAgdmFyIHY7XG4gICAgICBkbyB7XG4gICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICBpZiAodXNlS2V5cyB8fCB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUykge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlWzFdLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICBrID0gZW50cnlbMF07XG4gICAgICAgIHYgPSBlbnRyeVsxXTtcbiAgICAgICAgc2tpcHBpbmcgJiYgKHNraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgdGhpcyQxKSk7XG4gICAgICB9IHdoaWxlIChza2lwcGluZyk7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBza2lwU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdEZhY3RvcnkoY29sbGVjdGlvbiwgdmFsdWVzKSB7XG4gIHZhciBpc0tleWVkQ29sbGVjdGlvbiA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gIHZhciBpdGVycyA9IFtjb2xsZWN0aW9uXVxuICAgIC5jb25jYXQodmFsdWVzKVxuICAgIC5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlmICghaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgIHYgPSBpc0tleWVkQ29sbGVjdGlvblxuICAgICAgICAgID8ga2V5ZWRTZXFGcm9tVmFsdWUodilcbiAgICAgICAgICA6IGluZGV4ZWRTZXFGcm9tVmFsdWUoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdl0pO1xuICAgICAgfSBlbHNlIGlmIChpc0tleWVkQ29sbGVjdGlvbikge1xuICAgICAgICB2ID0gS2V5ZWRDb2xsZWN0aW9uKHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnNpemUgIT09IDA7IH0pO1xuXG4gIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuXG4gIGlmIChpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc2luZ2xldG9uID0gaXRlcnNbMF07XG4gICAgaWYgKFxuICAgICAgc2luZ2xldG9uID09PSBjb2xsZWN0aW9uIHx8XG4gICAgICAoaXNLZXllZENvbGxlY3Rpb24gJiYgaXNLZXllZChzaW5nbGV0b24pKSB8fFxuICAgICAgKGlzSW5kZXhlZChjb2xsZWN0aW9uKSAmJiBpc0luZGV4ZWQoc2luZ2xldG9uKSlcbiAgICApIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b247XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbmNhdFNlcSA9IG5ldyBBcnJheVNlcShpdGVycyk7XG4gIGlmIChpc0tleWVkQ29sbGVjdGlvbikge1xuICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b0tleWVkU2VxKCk7XG4gIH0gZWxzZSBpZiAoIWlzSW5kZXhlZChjb2xsZWN0aW9uKSkge1xuICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b1NldFNlcSgpO1xuICB9XG4gIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS5mbGF0dGVuKHRydWUpO1xuICBjb25jYXRTZXEuc2l6ZSA9IGl0ZXJzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBzZXEpIHtcbiAgICBpZiAoc3VtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBzaXplID0gc2VxLnNpemU7XG4gICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdW0gKyBzaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwgMCk7XG4gIHJldHVybiBjb25jYXRTZXE7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5GYWN0b3J5KGNvbGxlY3Rpb24sIGRlcHRoLCB1c2VLZXlzKSB7XG4gIHZhciBmbGF0U2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gZmxhdERlZXAoaXRlciwgY3VycmVudERlcHRoKSB7XG4gICAgICBpdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgICBpZiAoKCFkZXB0aCB8fCBjdXJyZW50RGVwdGggPCBkZXB0aCkgJiYgaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgICAgZmxhdERlZXAodiwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIGlmIChmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCBmbGF0U2VxdWVuY2UpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhc3RvcHBlZDtcbiAgICAgIH0sIHJldmVyc2UpO1xuICAgIH1cbiAgICBmbGF0RGVlcChjb2xsZWN0aW9uLCAwKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgZmxhdFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKGl0ZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lICE9PSBmYWxzZSkge1xuICAgICAgICAgIGl0ZXJhdG9yID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBzdGVwLnZhbHVlO1xuICAgICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICAgICAgdiA9IHZbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghZGVwdGggfHwgc3RhY2subGVuZ3RoIDwgZGVwdGgpICYmIGlzQ29sbGVjdGlvbih2KSkge1xuICAgICAgICAgIHN0YWNrLnB1c2goaXRlcmF0b3IpO1xuICAgICAgICAgIGl0ZXJhdG9yID0gdi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1c2VLZXlzID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2LCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gZmxhdFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBmbGF0TWFwRmFjdG9yeShjb2xsZWN0aW9uLCBtYXBwZXIsIGNvbnRleHQpIHtcbiAgdmFyIGNvZXJjZSA9IGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKTtcbiAgcmV0dXJuIGNvbGxlY3Rpb25cbiAgICAudG9TZXEoKVxuICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGNvZXJjZShtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjb2xsZWN0aW9uKSk7IH0pXG4gICAgLmZsYXR0ZW4odHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGludGVycG9zZUZhY3RvcnkoY29sbGVjdGlvbiwgc2VwYXJhdG9yKSB7XG4gIHZhciBpbnRlcnBvc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGludGVycG9zZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplICYmIGNvbGxlY3Rpb24uc2l6ZSAqIDIgLSAxO1xuICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuICghaXRlcmF0aW9ucyB8fCBmbihzZXBhcmF0b3IsIGl0ZXJhdGlvbnMrKywgdGhpcyQxKSAhPT0gZmFsc2UpICYmXG4gICAgICAgIGZuKHYsIGl0ZXJhdGlvbnMrKywgdGhpcyQxKSAhPT0gZmFsc2U7IH0sXG4gICAgICByZXZlcnNlXG4gICAgKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgaW50ZXJwb3NlZFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB2YXIgc3RlcDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3RlcCB8fCBpdGVyYXRpb25zICUgMikge1xuICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zICUgMlxuICAgICAgICA/IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzZXBhcmF0b3IpXG4gICAgICAgIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gaW50ZXJwb3NlZFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBzb3J0RmFjdG9yeShjb2xsZWN0aW9uLCBjb21wYXJhdG9yLCBtYXBwZXIpIHtcbiAgaWYgKCFjb21wYXJhdG9yKSB7XG4gICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICB9XG4gIHZhciBpc0tleWVkQ29sbGVjdGlvbiA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBlbnRyaWVzID0gY29sbGVjdGlvblxuICAgIC50b1NlcSgpXG4gICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gW2ssIHYsIGluZGV4KyssIG1hcHBlciA/IG1hcHBlcih2LCBrLCBjb2xsZWN0aW9uKSA6IHZdOyB9KVxuICAgIC52YWx1ZVNlcSgpXG4gICAgLnRvQXJyYXkoKTtcbiAgZW50cmllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjb21wYXJhdG9yKGFbM10sIGJbM10pIHx8IGFbMl0gLSBiWzJdOyB9KS5mb3JFYWNoKFxuICAgIGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgICA/IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgZW50cmllc1tpXS5sZW5ndGggPSAyO1xuICAgICAgICB9XG4gICAgICA6IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgZW50cmllc1tpXSA9IHZbMV07XG4gICAgICAgIH1cbiAgKTtcbiAgcmV0dXJuIGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgPyBLZXllZFNlcShlbnRyaWVzKVxuICAgIDogaXNJbmRleGVkKGNvbGxlY3Rpb24pXG4gICAgICA/IEluZGV4ZWRTZXEoZW50cmllcylcbiAgICAgIDogU2V0U2VxKGVudHJpZXMpO1xufVxuXG5mdW5jdGlvbiBtYXhGYWN0b3J5KGNvbGxlY3Rpb24sIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICBpZiAoIWNvbXBhcmF0b3IpIHtcbiAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gIH1cbiAgaWYgKG1hcHBlcikge1xuICAgIHZhciBlbnRyeSA9IGNvbGxlY3Rpb25cbiAgICAgIC50b1NlcSgpXG4gICAgICAubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBbdiwgbWFwcGVyKHYsIGssIGNvbGxlY3Rpb24pXTsgfSlcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGFbMV0sIGJbMV0pID8gYiA6IGEpOyB9KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb24ucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAobWF4Q29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSA/IGIgOiBhKTsgfSk7XG59XG5cbmZ1bmN0aW9uIG1heENvbXBhcmUoY29tcGFyYXRvciwgYSwgYikge1xuICB2YXIgY29tcCA9IGNvbXBhcmF0b3IoYiwgYSk7XG4gIC8vIGIgaXMgY29uc2lkZXJlZCB0aGUgbmV3IG1heCBpZiB0aGUgY29tcGFyYXRvciBkZWNsYXJlcyB0aGVtIGVxdWFsLCBidXRcbiAgLy8gdGhleSBhcmUgbm90IGVxdWFsIGFuZCBiIGlzIGluIGZhY3QgYSBudWxsaXNoIHZhbHVlLlxuICByZXR1cm4gKFxuICAgIChjb21wID09PSAwICYmIGIgIT09IGEgJiYgKGIgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgIT09IGIpKSB8fFxuICAgIGNvbXAgPiAwXG4gICk7XG59XG5cbmZ1bmN0aW9uIHppcFdpdGhGYWN0b3J5KGtleUl0ZXIsIHppcHBlciwgaXRlcnMsIHppcEFsbCkge1xuICB2YXIgemlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2Uoa2V5SXRlcik7XG4gIHZhciBzaXplcyA9IG5ldyBBcnJheVNlcShpdGVycykubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnNpemU7IH0pO1xuICB6aXBTZXF1ZW5jZS5zaXplID0gemlwQWxsID8gc2l6ZXMubWF4KCkgOiBzaXplcy5taW4oKTtcbiAgLy8gTm90ZTogdGhpcyBhIGdlbmVyaWMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBfX2l0ZXJhdGUgaW4gdGVybXMgb2ZcbiAgLy8gX19pdGVyYXRvciB3aGljaCBtYXkgYmUgbW9yZSBnZW5lcmljYWxseSB1c2VmdWwgaW4gdGhlIGZ1dHVyZS5cbiAgemlwU2VxdWVuY2UuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAvKiBnZW5lcmljOlxuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgIHZhciBzdGVwO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICBpdGVyYXRpb25zKys7XG4gICAgICBpZiAoZm4oc3RlcC52YWx1ZVsxXSwgc3RlcC52YWx1ZVswXSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICAqL1xuICAgIC8vIGluZGV4ZWQ6XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICB2YXIgc3RlcDtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgemlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBpdGVyYXRvcnMgPSBpdGVycy5tYXAoXG4gICAgICBmdW5jdGlvbiAoaSkgeyByZXR1cm4gKChpID0gQ29sbGVjdGlvbihpKSksIGdldEl0ZXJhdG9yKHJldmVyc2UgPyBpLnJldmVyc2UoKSA6IGkpKTsgfVxuICAgICk7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHZhciBpc0RvbmUgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwcztcbiAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgIHN0ZXBzID0gaXRlcmF0b3JzLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5uZXh0KCk7IH0pO1xuICAgICAgICBpc0RvbmUgPSB6aXBBbGwgPyBzdGVwcy5ldmVyeShmdW5jdGlvbiAocykgeyByZXR1cm4gcy5kb25lOyB9KSA6IHN0ZXBzLnNvbWUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuZG9uZTsgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICB0eXBlLFxuICAgICAgICBpdGVyYXRpb25zKyssXG4gICAgICAgIHppcHBlci5hcHBseShudWxsLCBzdGVwcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudmFsdWU7IH0pKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHppcFNlcXVlbmNlO1xufVxuXG4vLyAjcHJhZ21hIEhlbHBlciBGdW5jdGlvbnNcblxuZnVuY3Rpb24gcmVpZnkoaXRlciwgc2VxKSB7XG4gIHJldHVybiBpdGVyID09PSBzZXEgPyBpdGVyIDogaXNTZXEoaXRlcikgPyBzZXEgOiBpdGVyLmNvbnN0cnVjdG9yKHNlcSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRW50cnkoZW50cnkpIHtcbiAgaWYgKGVudHJ5ICE9PSBPYmplY3QoZW50cnkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgW0ssIFZdIHR1cGxlOiAnICsgZW50cnkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBpc0tleWVkKGNvbGxlY3Rpb24pXG4gICAgPyBLZXllZENvbGxlY3Rpb25cbiAgICA6IGlzSW5kZXhlZChjb2xsZWN0aW9uKVxuICAgICAgPyBJbmRleGVkQ29sbGVjdGlvblxuICAgICAgOiBTZXRDb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbikge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShcbiAgICAoaXNLZXllZChjb2xsZWN0aW9uKVxuICAgICAgPyBLZXllZFNlcVxuICAgICAgOiBpc0luZGV4ZWQoY29sbGVjdGlvbilcbiAgICAgICAgPyBJbmRleGVkU2VxXG4gICAgICAgIDogU2V0U2VxXG4gICAgKS5wcm90b3R5cGVcbiAgKTtcbn1cblxuZnVuY3Rpb24gY2FjaGVSZXN1bHRUaHJvdWdoKCkge1xuICBpZiAodGhpcy5faXRlci5jYWNoZVJlc3VsdCkge1xuICAgIHRoaXMuX2l0ZXIuY2FjaGVSZXN1bHQoKTtcbiAgICB0aGlzLnNpemUgPSB0aGlzLl9pdGVyLnNpemU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIFNlcS5wcm90b3R5cGUuY2FjaGVSZXN1bHQuY2FsbCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmF0b3IoYSwgYikge1xuICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn1cblxuLy8gaHR0cDovL2pzcGVyZi5jb20vY29weS1hcnJheS1pbmxpbmVcbmZ1bmN0aW9uIGFyckNvcHkoYXJyLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1heCgwLCBhcnIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgbmV3QXJyW2lpXSA9IGFycltpaSArIG9mZnNldF07XG4gIH1cbiAgcmV0dXJuIG5ld0Fycjtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZXJyb3IpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKGVycm9yKTsgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnROb3RJbmZpbml0ZShzaXplKSB7XG4gIGludmFyaWFudChcbiAgICBzaXplICE9PSBJbmZpbml0eSxcbiAgICAnQ2Fubm90IHBlcmZvcm0gdGhpcyBhY3Rpb24gd2l0aCBhbiBpbmZpbml0ZSBzaXplLidcbiAgKTtcbn1cblxuZnVuY3Rpb24gY29lcmNlS2V5UGF0aChrZXlQYXRoKSB7XG4gIGlmIChpc0FycmF5TGlrZShrZXlQYXRoKSAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ga2V5UGF0aDtcbiAgfVxuICBpZiAoaXNPcmRlcmVkKGtleVBhdGgpKSB7XG4gICAgcmV0dXJuIGtleVBhdGgudG9BcnJheSgpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ0ludmFsaWQga2V5UGF0aDogZXhwZWN0ZWQgT3JkZXJlZCBDb2xsZWN0aW9uIG9yIEFycmF5OiAnICsga2V5UGF0aFxuICApO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluT2JqKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgJiZcbiAgICAodHlwZW9mIHZhbHVlLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JylcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgcG90ZW50aWFsbHktcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZSwgZWl0aGVyXG4gKiBwcm92aWRlZCBieSBJbW11dGFibGUuanMgb3IgYSBwbGFpbiBBcnJheSBvciBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0YVN0cnVjdHVyZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAoaXNJbW11dGFibGUodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmoodmFsdWUpKVxuICApO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgdmFsdWUgdG8gYSBzdHJpbmcsIGFkZGluZyBxdW90ZXMgaWYgYSBzdHJpbmcgd2FzIHByb3ZpZGVkLlxuICovXG5mdW5jdGlvbiBxdW90ZVN0cmluZyh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbiAgfSBjYXRjaCAoX2lnbm9yZUVycm9yKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXMoY29sbGVjdGlvbiwga2V5KSB7XG4gIHJldHVybiBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKVxuICAgID8gY29sbGVjdGlvbi5oYXMoa2V5KVxuICAgIDogaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pICYmIGhhc093blByb3BlcnR5LmNhbGwoY29sbGVjdGlvbiwga2V5KTtcbn1cblxuZnVuY3Rpb24gZ2V0KGNvbGxlY3Rpb24sIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgcmV0dXJuIGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pXG4gICAgPyBjb2xsZWN0aW9uLmdldChrZXksIG5vdFNldFZhbHVlKVxuICAgIDogIWhhcyhjb2xsZWN0aW9uLCBrZXkpXG4gICAgICA/IG5vdFNldFZhbHVlXG4gICAgICA6IHR5cGVvZiBjb2xsZWN0aW9uLmdldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNvbGxlY3Rpb24uZ2V0KGtleSlcbiAgICAgICAgOiBjb2xsZWN0aW9uW2tleV07XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KGZyb20pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbSkpIHtcbiAgICByZXR1cm4gYXJyQ29weShmcm9tKTtcbiAgfVxuICB2YXIgdG8gPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uLCBrZXkpIHtcbiAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0Nhbm5vdCB1cGRhdGUgbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICk7XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uLnJlbW92ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgaW1tdXRhYmxlIHZhbHVlIHdpdGhvdXQgLnJlbW92ZSgpIG1ldGhvZDogJyArIGNvbGxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZShrZXkpO1xuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cbiAgdmFyIGNvbGxlY3Rpb25Db3B5ID0gc2hhbGxvd0NvcHkoY29sbGVjdGlvbik7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb25Db3B5KSkge1xuICAgIGNvbGxlY3Rpb25Db3B5LnNwbGljZShrZXksIDEpO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBjb2xsZWN0aW9uQ29weVtrZXldO1xuICB9XG4gIHJldHVybiBjb2xsZWN0aW9uQ29weTtcbn1cblxuZnVuY3Rpb24gc2V0KGNvbGxlY3Rpb24sIGtleSwgdmFsdWUpIHtcbiAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0Nhbm5vdCB1cGRhdGUgbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICk7XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uLnNldCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgaW1tdXRhYmxlIHZhbHVlIHdpdGhvdXQgLnNldCgpIG1ldGhvZDogJyArIGNvbGxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpICYmIHZhbHVlID09PSBjb2xsZWN0aW9uW2tleV0pIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuICB2YXIgY29sbGVjdGlvbkNvcHkgPSBzaGFsbG93Q29weShjb2xsZWN0aW9uKTtcbiAgY29sbGVjdGlvbkNvcHlba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gY29sbGVjdGlvbkNvcHk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gIGlmICghdXBkYXRlcikge1xuICAgIHVwZGF0ZXIgPSBub3RTZXRWYWx1ZTtcbiAgICBub3RTZXRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgdXBkYXRlZFZhbHVlID0gdXBkYXRlSW5EZWVwbHkoXG4gICAgaXNJbW11dGFibGUoY29sbGVjdGlvbiksXG4gICAgY29sbGVjdGlvbixcbiAgICBjb2VyY2VLZXlQYXRoKGtleVBhdGgpLFxuICAgIDAsXG4gICAgbm90U2V0VmFsdWUsXG4gICAgdXBkYXRlclxuICApO1xuICByZXR1cm4gdXBkYXRlZFZhbHVlID09PSBOT1RfU0VUID8gbm90U2V0VmFsdWUgOiB1cGRhdGVkVmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluRGVlcGx5KFxuICBpbkltbXV0YWJsZSxcbiAgZXhpc3RpbmcsXG4gIGtleVBhdGgsXG4gIGksXG4gIG5vdFNldFZhbHVlLFxuICB1cGRhdGVyXG4pIHtcbiAgdmFyIHdhc05vdFNldCA9IGV4aXN0aW5nID09PSBOT1RfU0VUO1xuICBpZiAoaSA9PT0ga2V5UGF0aC5sZW5ndGgpIHtcbiAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHdhc05vdFNldCA/IG5vdFNldFZhbHVlIDogZXhpc3Rpbmc7XG4gICAgdmFyIG5ld1ZhbHVlID0gdXBkYXRlcihleGlzdGluZ1ZhbHVlKTtcbiAgICByZXR1cm4gbmV3VmFsdWUgPT09IGV4aXN0aW5nVmFsdWUgPyBleGlzdGluZyA6IG5ld1ZhbHVlO1xuICB9XG4gIGlmICghd2FzTm90U2V0ICYmICFpc0RhdGFTdHJ1Y3R1cmUoZXhpc3RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdDYW5ub3QgdXBkYXRlIHdpdGhpbiBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWUgaW4gcGF0aCBbJyArXG4gICAgICAgIGtleVBhdGguc2xpY2UoMCwgaSkubWFwKHF1b3RlU3RyaW5nKSArXG4gICAgICAgICddOiAnICtcbiAgICAgICAgZXhpc3RpbmdcbiAgICApO1xuICB9XG4gIHZhciBrZXkgPSBrZXlQYXRoW2ldO1xuICB2YXIgbmV4dEV4aXN0aW5nID0gd2FzTm90U2V0ID8gTk9UX1NFVCA6IGdldChleGlzdGluZywga2V5LCBOT1RfU0VUKTtcbiAgdmFyIG5leHRVcGRhdGVkID0gdXBkYXRlSW5EZWVwbHkoXG4gICAgbmV4dEV4aXN0aW5nID09PSBOT1RfU0VUID8gaW5JbW11dGFibGUgOiBpc0ltbXV0YWJsZShuZXh0RXhpc3RpbmcpLFxuICAgIG5leHRFeGlzdGluZyxcbiAgICBrZXlQYXRoLFxuICAgIGkgKyAxLFxuICAgIG5vdFNldFZhbHVlLFxuICAgIHVwZGF0ZXJcbiAgKTtcbiAgcmV0dXJuIG5leHRVcGRhdGVkID09PSBuZXh0RXhpc3RpbmdcbiAgICA/IGV4aXN0aW5nXG4gICAgOiBuZXh0VXBkYXRlZCA9PT0gTk9UX1NFVFxuICAgICAgPyByZW1vdmUoZXhpc3RpbmcsIGtleSlcbiAgICAgIDogc2V0KFxuICAgICAgICAgIHdhc05vdFNldCA/IChpbkltbXV0YWJsZSA/IGVtcHR5TWFwKCkgOiB7fSkgOiBleGlzdGluZyxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmV4dFVwZGF0ZWRcbiAgICAgICAgKTtcbn1cblxuZnVuY3Rpb24gc2V0SW4oY29sbGVjdGlvbiwga2V5UGF0aCwgdmFsdWUpIHtcbiAgcmV0dXJuIHVwZGF0ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgsIE5PVF9TRVQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn1cblxuZnVuY3Rpb24gc2V0SW4kMShrZXlQYXRoLCB2KSB7XG4gIHJldHVybiBzZXRJbih0aGlzLCBrZXlQYXRoLCB2KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSW4oY29sbGVjdGlvbiwga2V5UGF0aCkge1xuICByZXR1cm4gdXBkYXRlSW4oY29sbGVjdGlvbiwga2V5UGF0aCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gTk9UX1NFVDsgfSk7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZUluKGtleVBhdGgpIHtcbiAgcmV0dXJuIHJlbW92ZUluKHRoaXMsIGtleVBhdGgpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUoY29sbGVjdGlvbiwga2V5LCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICByZXR1cm4gdXBkYXRlSW4oY29sbGVjdGlvbiwgW2tleV0sIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlJDEoa2V5LCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgID8ga2V5KHRoaXMpXG4gICAgOiB1cGRhdGUodGhpcywga2V5LCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluJDEoa2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgcmV0dXJuIHVwZGF0ZUluKHRoaXMsIGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gbWVyZ2VJbnRvS2V5ZWRXaXRoKHRoaXMsIGl0ZXJzKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VXaXRoKG1lcmdlcikge1xuICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgaWYgKHR5cGVvZiBtZXJnZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1lcmdlciBmdW5jdGlvbjogJyArIG1lcmdlcik7XG4gIH1cbiAgcmV0dXJuIG1lcmdlSW50b0tleWVkV2l0aCh0aGlzLCBpdGVycywgbWVyZ2VyKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VJbnRvS2V5ZWRXaXRoKGNvbGxlY3Rpb24sIGNvbGxlY3Rpb25zLCBtZXJnZXIpIHtcbiAgdmFyIGl0ZXJzID0gW107XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGlpKyspIHtcbiAgICB2YXIgY29sbGVjdGlvbiQxID0gS2V5ZWRDb2xsZWN0aW9uKGNvbGxlY3Rpb25zW2lpXSk7XG4gICAgaWYgKGNvbGxlY3Rpb24kMS5zaXplICE9PSAwKSB7XG4gICAgICBpdGVycy5wdXNoKGNvbGxlY3Rpb24kMSk7XG4gICAgfVxuICB9XG4gIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuICBpZiAoXG4gICAgY29sbGVjdGlvbi50b1NlcSgpLnNpemUgPT09IDAgJiZcbiAgICAhY29sbGVjdGlvbi5fX293bmVySUQgJiZcbiAgICBpdGVycy5sZW5ndGggPT09IDFcbiAgKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICB9XG4gIHJldHVybiBjb2xsZWN0aW9uLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbWVyZ2VJbnRvQ29sbGVjdGlvbiA9IG1lcmdlclxuICAgICAgPyBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIHVwZGF0ZShcbiAgICAgICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBOT1RfU0VULFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9sZFZhbCkgeyByZXR1cm4gKG9sZFZhbCA9PT0gTk9UX1NFVCA/IHZhbHVlIDogbWVyZ2VyKG9sZFZhbCwgdmFsdWUsIGtleSkpOyB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIGNvbGxlY3Rpb24uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGl0ZXJzW2lpXS5mb3JFYWNoKG1lcmdlSW50b0NvbGxlY3Rpb24pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlJDEoY29sbGVjdGlvbikge1xuICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVdpdGgkMShtZXJnZXIsIGNvbGxlY3Rpb24pIHtcbiAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICByZXR1cm4gbWVyZ2VXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXAoY29sbGVjdGlvbikge1xuICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aChtZXJnZXIsIGNvbGxlY3Rpb24pIHtcbiAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKSB7XG4gIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIGRlZXBNZXJnZXJXaXRoKG1lcmdlcikpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcikge1xuICBpZiAoIWlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnQ2Fubm90IG1lcmdlIGludG8gbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICk7XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXJnZXIgPT09ICdmdW5jdGlvbicgJiYgY29sbGVjdGlvbi5tZXJnZVdpdGhcbiAgICAgID8gY29sbGVjdGlvbi5tZXJnZVdpdGguYXBwbHkoY29sbGVjdGlvbiwgWyBtZXJnZXIgXS5jb25jYXQoIHNvdXJjZXMgKSlcbiAgICAgIDogY29sbGVjdGlvbi5tZXJnZVxuICAgICAgICA/IGNvbGxlY3Rpb24ubWVyZ2UuYXBwbHkoY29sbGVjdGlvbiwgc291cmNlcylcbiAgICAgICAgOiBjb2xsZWN0aW9uLmNvbmNhdC5hcHBseShjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbiAgfVxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbik7XG4gIHZhciBtZXJnZWQgPSBjb2xsZWN0aW9uO1xuICB2YXIgQ29sbGVjdGlvbiQkMSA9IGlzQXJyYXkgPyBJbmRleGVkQ29sbGVjdGlvbiA6IEtleWVkQ29sbGVjdGlvbjtcbiAgdmFyIG1lcmdlSXRlbSA9IGlzQXJyYXlcbiAgICA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBDb3B5IG9uIHdyaXRlXG4gICAgICAgIGlmIChtZXJnZWQgPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtZXJnZWQgPSBzaGFsbG93Q29weShtZXJnZWQpO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlZC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICA6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBoYXNWYWwgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG1lcmdlZCwga2V5KTtcbiAgICAgICAgdmFyIG5leHRWYWwgPVxuICAgICAgICAgIGhhc1ZhbCAmJiBtZXJnZXIgPyBtZXJnZXIobWVyZ2VkW2tleV0sIHZhbHVlLCBrZXkpIDogdmFsdWU7XG4gICAgICAgIGlmICghaGFzVmFsIHx8IG5leHRWYWwgIT09IG1lcmdlZFtrZXldKSB7XG4gICAgICAgICAgLy8gQ29weSBvbiB3cml0ZVxuICAgICAgICAgIGlmIChtZXJnZWQgPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIG1lcmdlZCA9IHNoYWxsb3dDb3B5KG1lcmdlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lcmdlZFtrZXldID0gbmV4dFZhbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgQ29sbGVjdGlvbiQkMShzb3VyY2VzW2ldKS5mb3JFYWNoKG1lcmdlSXRlbSk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gZGVlcE1lcmdlcldpdGgobWVyZ2VyKSB7XG4gIGZ1bmN0aW9uIGRlZXBNZXJnZXIob2xkVmFsdWUsIG5ld1ZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gaXNEYXRhU3RydWN0dXJlKG9sZFZhbHVlKSAmJiBpc0RhdGFTdHJ1Y3R1cmUobmV3VmFsdWUpXG4gICAgICA/IG1lcmdlV2l0aFNvdXJjZXMob2xkVmFsdWUsIFtuZXdWYWx1ZV0sIGRlZXBNZXJnZXIpXG4gICAgICA6IG1lcmdlclxuICAgICAgICA/IG1lcmdlcihvbGRWYWx1ZSwgbmV3VmFsdWUsIGtleSlcbiAgICAgICAgOiBuZXdWYWx1ZTtcbiAgfVxuICByZXR1cm4gZGVlcE1lcmdlcjtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwJDEoKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXModGhpcywgaXRlcnMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXBXaXRoJDEobWVyZ2VyKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXModGhpcywgaXRlcnMsIG1lcmdlcik7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSW4oa2V5UGF0aCkge1xuICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgcmV0dXJuIHVwZGF0ZUluKHRoaXMsIGtleVBhdGgsIGVtcHR5TWFwKCksIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKG0sIGl0ZXJzKTsgfSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcEluKGtleVBhdGgpIHtcbiAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiB1cGRhdGVJbih0aGlzLCBrZXlQYXRoLCBlbXB0eU1hcCgpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXMobSwgaXRlcnMpOyB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIHdpdGhNdXRhdGlvbnMoZm4pIHtcbiAgdmFyIG11dGFibGUgPSB0aGlzLmFzTXV0YWJsZSgpO1xuICBmbihtdXRhYmxlKTtcbiAgcmV0dXJuIG11dGFibGUud2FzQWx0ZXJlZCgpID8gbXV0YWJsZS5fX2Vuc3VyZU93bmVyKHRoaXMuX19vd25lcklEKSA6IHRoaXM7XG59XG5cbmZ1bmN0aW9uIGFzTXV0YWJsZSgpIHtcbiAgcmV0dXJuIHRoaXMuX19vd25lcklEID8gdGhpcyA6IHRoaXMuX19lbnN1cmVPd25lcihuZXcgT3duZXJJRCgpKTtcbn1cblxuZnVuY3Rpb24gYXNJbW11dGFibGUoKSB7XG4gIHJldHVybiB0aGlzLl9fZW5zdXJlT3duZXIoKTtcbn1cblxuZnVuY3Rpb24gd2FzQWx0ZXJlZCgpIHtcbiAgcmV0dXJuIHRoaXMuX19hbHRlcmVkO1xufVxuXG52YXIgTWFwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoS2V5ZWRDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIE1hcCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGVtcHR5TWFwKClcbiAgICAgIDogaXNNYXAodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZENvbGxlY3Rpb24kJDEodmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gbWFwLnNldChrLCB2KTsgfSk7XG4gICAgICAgICAgfSk7XG4gIH1cblxuICBpZiAoIEtleWVkQ29sbGVjdGlvbiQkMSApIE1hcC5fX3Byb3RvX18gPSBLZXllZENvbGxlY3Rpb24kJDE7XG4gIE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZENvbGxlY3Rpb24kJDEgJiYgS2V5ZWRDb2xsZWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwO1xuXG4gIE1hcC5vZiA9IGZ1bmN0aW9uIG9mICgpIHtcbiAgICB2YXIga2V5VmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGtleVZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBpZiAoaSArIDEgPj0ga2V5VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2YWx1ZSBmb3Iga2V5OiAnICsga2V5VmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBtYXAuc2V0KGtleVZhbHVlc1tpXSwga2V5VmFsdWVzW2kgKyAxXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdNYXAgeycsICd9Jyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdFxuICAgICAgPyB0aGlzLl9yb290LmdldCgwLCB1bmRlZmluZWQsIGssIG5vdFNldFZhbHVlKVxuICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChrLCB2KSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hcCh0aGlzLCBrLCB2KTtcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5kZWxldGVBbGwgPSBmdW5jdGlvbiBkZWxldGVBbGwgKGtleXMpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IENvbGxlY3Rpb24oa2V5cyk7XG5cbiAgICBpZiAoY29sbGVjdGlvbi5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBtYXAucmVtb3ZlKGtleSk7IH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5TWFwKCk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIE1hcC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIHNvcnQgKGNvbXBhcmF0b3IpIHtcbiAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiBzb3J0QnkgKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIC8vIExhdGUgYmluZGluZ1xuICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBtYXBwZXIuY2FsbChjb250ZXh0LCB2YWx1ZSwga2V5LCBtYXApKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG4gIE1hcC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuX3Jvb3QgJiZcbiAgICAgIHRoaXMuX3Jvb3QuaXRlcmF0ZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICByZXR1cm4gZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzJDEpO1xuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZW1wdHlNYXAoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VNYXAodGhpcy5zaXplLCB0aGlzLl9yb290LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gIH07XG5cbiAgcmV0dXJuIE1hcDtcbn0oS2V5ZWRDb2xsZWN0aW9uKSk7XG5cbk1hcC5pc01hcCA9IGlzTWFwO1xuXG52YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcbk1hcFByb3RvdHlwZVtJU19NQVBfU1lNQk9MXSA9IHRydWU7XG5NYXBQcm90b3R5cGVbREVMRVRFXSA9IE1hcFByb3RvdHlwZS5yZW1vdmU7XG5NYXBQcm90b3R5cGUucmVtb3ZlQWxsID0gTWFwUHJvdG90eXBlLmRlbGV0ZUFsbDtcbk1hcFByb3RvdHlwZS5zZXRJbiA9IHNldEluJDE7XG5NYXBQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUuZGVsZXRlSW4gPSBkZWxldGVJbjtcbk1hcFByb3RvdHlwZS51cGRhdGUgPSB1cGRhdGUkMTtcbk1hcFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluJDE7XG5NYXBQcm90b3R5cGUubWVyZ2UgPSBNYXBQcm90b3R5cGUuY29uY2F0ID0gbWVyZ2U7XG5NYXBQcm90b3R5cGUubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuTWFwUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcCQxO1xuTWFwUHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBtZXJnZURlZXBXaXRoJDE7XG5NYXBQcm90b3R5cGUubWVyZ2VJbiA9IG1lcmdlSW47XG5NYXBQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBtZXJnZURlZXBJbjtcbk1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbk1hcFByb3RvdHlwZS53YXNBbHRlcmVkID0gd2FzQWx0ZXJlZDtcbk1hcFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuTWFwUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbk1hcFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgYXJyKSB7XG4gIHJldHVybiByZXN1bHQuc2V0KGFyclswXSwgYXJyWzFdKTtcbn07XG5NYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG59O1xuXG4vLyAjcHJhZ21hIFRyaWUgTm9kZXNcblxudmFyIEFycmF5TWFwTm9kZSA9IGZ1bmN0aW9uIEFycmF5TWFwTm9kZShvd25lcklELCBlbnRyaWVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG59O1xuXG5BcnJheU1hcE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gIGZvciAodmFyIGlpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgaWYgKGlzKGtleSwgZW50cmllc1tpaV1bMF0pKSB7XG4gICAgICByZXR1cm4gZW50cmllc1tpaV1bMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBub3RTZXRWYWx1ZTtcbn07XG5cbkFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDtcbiAgZm9yICg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lkeF1bMF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGV4aXN0cyA9IGlkeCA8IGxlbjtcblxuICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIFNldFJlZihkaWRBbHRlcik7XG4gIChyZW1vdmVkIHx8ICFleGlzdHMpICYmIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblxuICBpZiAocmVtb3ZlZCAmJiBlbnRyaWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWV4aXN0cyAmJiAhcmVtb3ZlZCAmJiBlbnRyaWVzLmxlbmd0aCA+PSBNQVhfQVJSQVlfTUFQX1NJWkUpIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSk7XG4gIH1cblxuICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICBpZiAoZXhpc3RzKSB7XG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIGlkeCA9PT0gbGVuIC0gMVxuICAgICAgICA/IG5ld0VudHJpZXMucG9wKClcbiAgICAgICAgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH1cblxuICBpZiAoaXNFZGl0YWJsZSkge1xuICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gbmV3IEFycmF5TWFwTm9kZShvd25lcklELCBuZXdFbnRyaWVzKTtcbn07XG5cbnZhciBCaXRtYXBJbmRleGVkTm9kZSA9IGZ1bmN0aW9uIEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgbm9kZXMpIHtcbiAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgdGhpcy5iaXRtYXAgPSBiaXRtYXA7XG4gIHRoaXMubm9kZXMgPSBub2Rlcztcbn07XG5cbkJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICB9XG4gIHZhciBiaXQgPSAxIDw8ICgoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSyk7XG4gIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcbiAgcmV0dXJuIChiaXRtYXAgJiBiaXQpID09PSAwXG4gICAgPyBub3RTZXRWYWx1ZVxuICAgIDogdGhpcy5ub2Rlc1twb3BDb3VudChiaXRtYXAgJiAoYml0IC0gMSkpXS5nZXQoXG4gICAgICAgIHNoaWZ0ICsgU0hJRlQsXG4gICAgICAgIGtleUhhc2gsXG4gICAgICAgIGtleSxcbiAgICAgICAgbm90U2V0VmFsdWVcbiAgICAgICk7XG59O1xuXG5CaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gIH1cbiAgdmFyIGtleUhhc2hGcmFnID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gIHZhciBiaXQgPSAxIDw8IGtleUhhc2hGcmFnO1xuICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gIHZhciBleGlzdHMgPSAoYml0bWFwICYgYml0KSAhPT0gMDtcblxuICBpZiAoIWV4aXN0cyAmJiB2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGlkeCA9IHBvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIHZhciBub2RlID0gZXhpc3RzID8gbm9kZXNbaWR4XSA6IHVuZGVmaW5lZDtcbiAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKFxuICAgIG5vZGUsXG4gICAgb3duZXJJRCxcbiAgICBzaGlmdCArIFNISUZULFxuICAgIGtleUhhc2gsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIGRpZENoYW5nZVNpemUsXG4gICAgZGlkQWx0ZXJcbiAgKTtcblxuICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKCFleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPj0gTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUpIHtcbiAgICByZXR1cm4gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwga2V5SGFzaEZyYWcsIG5ld05vZGUpO1xuICB9XG5cbiAgaWYgKFxuICAgIGV4aXN0cyAmJlxuICAgICFuZXdOb2RlICYmXG4gICAgbm9kZXMubGVuZ3RoID09PSAyICYmXG4gICAgaXNMZWFmTm9kZShub2Rlc1tpZHggXiAxXSlcbiAgKSB7XG4gICAgcmV0dXJuIG5vZGVzW2lkeCBeIDFdO1xuICB9XG5cbiAgaWYgKGV4aXN0cyAmJiBuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBpc0xlYWZOb2RlKG5ld05vZGUpKSB7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICB2YXIgbmV3Qml0bWFwID0gZXhpc3RzID8gKG5ld05vZGUgPyBiaXRtYXAgOiBiaXRtYXAgXiBiaXQpIDogYml0bWFwIHwgYml0O1xuICB2YXIgbmV3Tm9kZXMgPSBleGlzdHNcbiAgICA/IG5ld05vZGVcbiAgICAgID8gc2V0QXQobm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSlcbiAgICAgIDogc3BsaWNlT3V0KG5vZGVzLCBpZHgsIGlzRWRpdGFibGUpXG4gICAgOiBzcGxpY2VJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICBpZiAoaXNFZGl0YWJsZSkge1xuICAgIHRoaXMuYml0bWFwID0gbmV3Qml0bWFwO1xuICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgbmV3Qml0bWFwLCBuZXdOb2Rlcyk7XG59O1xuXG52YXIgSGFzaEFycmF5TWFwTm9kZSA9IGZ1bmN0aW9uIEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQsIG5vZGVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMuY291bnQgPSBjb3VudDtcbiAgdGhpcy5ub2RlcyA9IG5vZGVzO1xufTtcblxuSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgfVxuICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpZHhdO1xuICByZXR1cm4gbm9kZVxuICAgID8gbm9kZS5nZXQoc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSlcbiAgICA6IG5vdFNldFZhbHVlO1xufTtcblxuSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gIH1cbiAgdmFyIGlkeCA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgbm9kZSA9IG5vZGVzW2lkeF07XG5cbiAgaWYgKHJlbW92ZWQgJiYgIW5vZGUpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBuZXdOb2RlID0gdXBkYXRlTm9kZShcbiAgICBub2RlLFxuICAgIG93bmVySUQsXG4gICAgc2hpZnQgKyBTSElGVCxcbiAgICBrZXlIYXNoLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBkaWRDaGFuZ2VTaXplLFxuICAgIGRpZEFsdGVyXG4gICk7XG4gIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbmV3Q291bnQgPSB0aGlzLmNvdW50O1xuICBpZiAoIW5vZGUpIHtcbiAgICBuZXdDb3VudCsrO1xuICB9IGVsc2UgaWYgKCFuZXdOb2RlKSB7XG4gICAgbmV3Q291bnQtLTtcbiAgICBpZiAobmV3Q291bnQgPCBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSkge1xuICAgICAgcmV0dXJuIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgbmV3Q291bnQsIGlkeCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgdmFyIG5ld05vZGVzID0gc2V0QXQobm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSk7XG5cbiAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICB0aGlzLmNvdW50ID0gbmV3Q291bnQ7XG4gICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0NvdW50LCBuZXdOb2Rlcyk7XG59O1xuXG52YXIgSGFzaENvbGxpc2lvbk5vZGUgPSBmdW5jdGlvbiBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyaWVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG59O1xuXG5IYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vdFNldFZhbHVlO1xufTtcblxuSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICB9XG5cbiAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICBpZiAoa2V5SGFzaCAhPT0gdGhpcy5rZXlIYXNoKSB7XG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICByZXR1cm4gbWVyZ2VJbnRvTm9kZSh0aGlzLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgfVxuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoO1xuICBmb3IgKDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWR4XVswXSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuXG4gIGlmIChleGlzdHMgPyBlbnRyaWVzW2lkeF1bMV0gPT09IHZhbHVlIDogcmVtb3ZlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgKHJlbW92ZWQgfHwgIWV4aXN0cykgJiYgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuXG4gIGlmIChyZW1vdmVkICYmIGxlbiA9PT0gMikge1xuICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgZW50cmllc1tpZHggXiAxXSk7XG4gIH1cblxuICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICBpZiAoZXhpc3RzKSB7XG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIGlkeCA9PT0gbGVuIC0gMVxuICAgICAgICA/IG5ld0VudHJpZXMucG9wKClcbiAgICAgICAgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH1cblxuICBpZiAoaXNFZGl0YWJsZSkge1xuICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgbmV3RW50cmllcyk7XG59O1xuXG52YXIgVmFsdWVOb2RlID0gZnVuY3Rpb24gVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gIHRoaXMuZW50cnkgPSBlbnRyeTtcbn07XG5cblZhbHVlTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICByZXR1cm4gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKSA/IHRoaXMuZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcbn07XG5cblZhbHVlTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgdmFyIGtleU1hdGNoID0gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKTtcbiAgaWYgKGtleU1hdGNoID8gdmFsdWUgPT09IHRoaXMuZW50cnlbMV0gOiByZW1vdmVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBTZXRSZWYoZGlkQWx0ZXIpO1xuXG4gIGlmIChyZW1vdmVkKSB7XG4gICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoa2V5TWF0Y2gpIHtcbiAgICBpZiAob3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQpIHtcbiAgICAgIHRoaXMuZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gIH1cblxuICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vLyAjcHJhZ21hIEl0ZXJhdG9yc1xuXG5BcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uKFxuICBmbixcbiAgcmV2ZXJzZVxuKSB7XG4gIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICBmb3IgKHZhciBpaSA9IDAsIG1heEluZGV4ID0gZW50cmllcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgIGlmIChmbihlbnRyaWVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbkJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uKFxuICBmbixcbiAgcmV2ZXJzZVxuKSB7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBub2Rlcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5pdGVyYXRlKGZuLCByZXZlcnNlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuVmFsdWVOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgcmV0dXJuIGZuKHRoaXMuZW50cnkpO1xufTtcblxudmFyIE1hcEl0ZXJhdG9yID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSXRlcmF0b3IkJDEpIHtcbiAgZnVuY3Rpb24gTWFwSXRlcmF0b3IobWFwLCB0eXBlLCByZXZlcnNlKSB7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgdGhpcy5fc3RhY2sgPSBtYXAuX3Jvb3QgJiYgbWFwSXRlcmF0b3JGcmFtZShtYXAuX3Jvb3QpO1xuICB9XG5cbiAgaWYgKCBJdGVyYXRvciQkMSApIE1hcEl0ZXJhdG9yLl9fcHJvdG9fXyA9IEl0ZXJhdG9yJCQxO1xuICBNYXBJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJdGVyYXRvciQkMSAmJiBJdGVyYXRvciQkMS5wcm90b3R5cGUgKTtcbiAgTWFwSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwSXRlcmF0b3I7XG5cbiAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2s7XG4gICAgd2hpbGUgKHN0YWNrKSB7XG4gICAgICB2YXIgbm9kZSA9IHN0YWNrLm5vZGU7XG4gICAgICB2YXIgaW5kZXggPSBzdGFjay5pbmRleCsrO1xuICAgICAgdmFyIG1heEluZGV4ID0gKHZvaWQgMCk7XG4gICAgICBpZiAobm9kZS5lbnRyeSkge1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmVudHJpZXMpIHtcbiAgICAgICAgbWF4SW5kZXggPSBub2RlLmVudHJpZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbm9kZS5lbnRyaWVzW3RoaXMuX3JldmVyc2UgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXhdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4SW5kZXggPSBub2RlLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgIHZhciBzdWJOb2RlID0gbm9kZS5ub2Rlc1t0aGlzLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XTtcbiAgICAgICAgICBpZiAoc3ViTm9kZSkge1xuICAgICAgICAgICAgaWYgKHN1Yk5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgc3ViTm9kZS5lbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gbWFwSXRlcmF0b3JGcmFtZShzdWJOb2RlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gdGhpcy5fc3RhY2suX19wcmV2O1xuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gIH07XG5cbiAgcmV0dXJuIE1hcEl0ZXJhdG9yO1xufShJdGVyYXRvcikpO1xuXG5mdW5jdGlvbiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5KSB7XG4gIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG59XG5cbmZ1bmN0aW9uIG1hcEl0ZXJhdG9yRnJhbWUobm9kZSwgcHJldikge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG5vZGUsXG4gICAgaW5kZXg6IDAsXG4gICAgX19wcmV2OiBwcmV2LFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlTWFwKHNpemUsIHJvb3QsIG93bmVySUQsIGhhc2gkJDEpIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoTWFwUHJvdG90eXBlKTtcbiAgbWFwLnNpemUgPSBzaXplO1xuICBtYXAuX3Jvb3QgPSByb290O1xuICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgbWFwLl9faGFzaCA9IGhhc2gkJDE7XG4gIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIEVNUFRZX01BUDtcbmZ1bmN0aW9uIGVtcHR5TWFwKCkge1xuICByZXR1cm4gRU1QVFlfTUFQIHx8IChFTVBUWV9NQVAgPSBtYWtlTWFwKDApKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWFwKG1hcCwgaywgdikge1xuICB2YXIgbmV3Um9vdDtcbiAgdmFyIG5ld1NpemU7XG4gIGlmICghbWFwLl9yb290KSB7XG4gICAgaWYgKHYgPT09IE5PVF9TRVQpIHtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIG5ld1NpemUgPSAxO1xuICAgIG5ld1Jvb3QgPSBuZXcgQXJyYXlNYXBOb2RlKG1hcC5fX293bmVySUQsIFtbaywgdl1dKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlkQ2hhbmdlU2l6ZSA9IE1ha2VSZWYoKTtcbiAgICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKCk7XG4gICAgbmV3Um9vdCA9IHVwZGF0ZU5vZGUoXG4gICAgICBtYXAuX3Jvb3QsXG4gICAgICBtYXAuX19vd25lcklELFxuICAgICAgMCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGssXG4gICAgICB2LFxuICAgICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcbiAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBuZXdTaXplID0gbWFwLnNpemUgKyAoZGlkQ2hhbmdlU2l6ZS52YWx1ZSA/ICh2ID09PSBOT1RfU0VUID8gLTEgOiAxKSA6IDApO1xuICB9XG4gIGlmIChtYXAuX19vd25lcklEKSB7XG4gICAgbWFwLnNpemUgPSBuZXdTaXplO1xuICAgIG1hcC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgbWFwLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICBtYXAuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIHJldHVybiBuZXdSb290ID8gbWFrZU1hcChuZXdTaXplLCBuZXdSb290KSA6IGVtcHR5TWFwKCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5vZGUoXG4gIG5vZGUsXG4gIG93bmVySUQsXG4gIHNoaWZ0LFxuICBrZXlIYXNoLFxuICBrZXksXG4gIHZhbHVlLFxuICBkaWRDaGFuZ2VTaXplLFxuICBkaWRBbHRlclxuKSB7XG4gIGlmICghbm9kZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gIH1cbiAgcmV0dXJuIG5vZGUudXBkYXRlKFxuICAgIG93bmVySUQsXG4gICAgc2hpZnQsXG4gICAga2V5SGFzaCxcbiAgICBrZXksXG4gICAgdmFsdWUsXG4gICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICBkaWRBbHRlclxuICApO1xufVxuXG5mdW5jdGlvbiBpc0xlYWZOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICBub2RlLmNvbnN0cnVjdG9yID09PSBWYWx1ZU5vZGUgfHwgbm9kZS5jb25zdHJ1Y3RvciA9PT0gSGFzaENvbGxpc2lvbk5vZGVcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgZW50cnkpIHtcbiAgaWYgKG5vZGUua2V5SGFzaCA9PT0ga2V5SGFzaCkge1xuICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwga2V5SGFzaCwgW25vZGUuZW50cnksIGVudHJ5XSk7XG4gIH1cblxuICB2YXIgaWR4MSA9IChzaGlmdCA9PT0gMCA/IG5vZGUua2V5SGFzaCA6IG5vZGUua2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgdmFyIGlkeDIgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcblxuICB2YXIgbmV3Tm9kZTtcbiAgdmFyIG5vZGVzID1cbiAgICBpZHgxID09PSBpZHgyXG4gICAgICA/IFttZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGVudHJ5KV1cbiAgICAgIDogKChuZXdOb2RlID0gbmV3IFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyeSkpLFxuICAgICAgICBpZHgxIDwgaWR4MiA/IFtub2RlLCBuZXdOb2RlXSA6IFtuZXdOb2RlLCBub2RlXSk7XG5cbiAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCAoMSA8PCBpZHgxKSB8ICgxIDw8IGlkeDIpLCBub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzKG93bmVySUQsIGVudHJpZXMsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCFvd25lcklEKSB7XG4gICAgb3duZXJJRCA9IG5ldyBPd25lcklEKCk7XG4gIH1cbiAgdmFyIG5vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGVudHJpZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpaV07XG4gICAgbm9kZSA9IG5vZGUudXBkYXRlKG93bmVySUQsIDAsIHVuZGVmaW5lZCwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gcGFja05vZGVzKG93bmVySUQsIG5vZGVzLCBjb3VudCwgZXhjbHVkaW5nKSB7XG4gIHZhciBiaXRtYXAgPSAwO1xuICB2YXIgcGFja2VkSUkgPSAwO1xuICB2YXIgcGFja2VkTm9kZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICBmb3IgKHZhciBpaSA9IDAsIGJpdCA9IDEsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyssIGJpdCA8PD0gMSkge1xuICAgIHZhciBub2RlID0gbm9kZXNbaWldO1xuICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgaWkgIT09IGV4Y2x1ZGluZykge1xuICAgICAgYml0bWFwIHw9IGJpdDtcbiAgICAgIHBhY2tlZE5vZGVzW3BhY2tlZElJKytdID0gbm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIHBhY2tlZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwgaW5jbHVkaW5nLCBub2RlKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBleHBhbmRlZE5vZGVzID0gbmV3IEFycmF5KFNJWkUpO1xuICBmb3IgKHZhciBpaSA9IDA7IGJpdG1hcCAhPT0gMDsgaWkrKywgYml0bWFwID4+Pj0gMSkge1xuICAgIGV4cGFuZGVkTm9kZXNbaWldID0gYml0bWFwICYgMSA/IG5vZGVzW2NvdW50KytdIDogdW5kZWZpbmVkO1xuICB9XG4gIGV4cGFuZGVkTm9kZXNbaW5jbHVkaW5nXSA9IG5vZGU7XG4gIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCArIDEsIGV4cGFuZGVkTm9kZXMpO1xufVxuXG5mdW5jdGlvbiBwb3BDb3VudCh4KSB7XG4gIHggLT0gKHggPj4gMSkgJiAweDU1NTU1NTU1O1xuICB4ID0gKHggJiAweDMzMzMzMzMzKSArICgoeCA+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICB4ID0gKHggKyAoeCA+PiA0KSkgJiAweDBmMGYwZjBmO1xuICB4ICs9IHggPj4gODtcbiAgeCArPSB4ID4+IDE2O1xuICByZXR1cm4geCAmIDB4N2Y7XG59XG5cbmZ1bmN0aW9uIHNldEF0KGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICB2YXIgbmV3QXJyYXkgPSBjYW5FZGl0ID8gYXJyYXkgOiBhcnJDb3B5KGFycmF5KTtcbiAgbmV3QXJyYXlbaWR4XSA9IHZhbDtcbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VJbihhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcbiAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCArIDE7XG4gIGlmIChjYW5FZGl0ICYmIGlkeCArIDEgPT09IG5ld0xlbikge1xuICAgIGFycmF5W2lkeF0gPSB2YWw7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICB2YXIgYWZ0ZXIgPSAwO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgIG5ld0FycmF5W2lpXSA9IHZhbDtcbiAgICAgIGFmdGVyID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU91dChhcnJheSwgaWR4LCBjYW5FZGl0KSB7XG4gIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggLSAxO1xuICBpZiAoY2FuRWRpdCAmJiBpZHggPT09IG5ld0xlbikge1xuICAgIGFycmF5LnBvcCgpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgdmFyIGFmdGVyID0gMDtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICBhZnRlciA9IDE7XG4gICAgfVxuICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICB9XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxudmFyIE1BWF9BUlJBWV9NQVBfU0laRSA9IFNJWkUgLyA0O1xudmFyIE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFID0gU0laRSAvIDI7XG52YXIgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcblxudmFyIElTX0xJU1RfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfTElTVF9fQEAnO1xuXG5mdW5jdGlvbiBpc0xpc3QobWF5YmVMaXN0KSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlTGlzdCAmJiBtYXliZUxpc3RbSVNfTElTVF9TWU1CT0xdKTtcbn1cblxudmFyIExpc3QgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkQ29sbGVjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBMaXN0KHZhbHVlKSB7XG4gICAgdmFyIGVtcHR5ID0gZW1wdHlMaXN0KCk7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgaWYgKGlzTGlzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIGl0ZXIgPSBJbmRleGVkQ29sbGVjdGlvbiQkMSh2YWx1ZSk7XG4gICAgdmFyIHNpemUgPSBpdGVyLnNpemU7XG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSk7XG4gICAgaWYgKHNpemUgPiAwICYmIHNpemUgPCBTSVpFKSB7XG4gICAgICByZXR1cm4gbWFrZUxpc3QoMCwgc2l6ZSwgU0hJRlQsIG51bGwsIG5ldyBWTm9kZShpdGVyLnRvQXJyYXkoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgbGlzdC5zZXRTaXplKHNpemUpO1xuICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBsaXN0LnNldChpLCB2KTsgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIEluZGV4ZWRDb2xsZWN0aW9uJCQxICkgTGlzdC5fX3Byb3RvX18gPSBJbmRleGVkQ29sbGVjdGlvbiQkMTtcbiAgTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkQ29sbGVjdGlvbiQkMSAmJiBJbmRleGVkQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaXN0O1xuXG4gIExpc3Qub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTGlzdCBbJywgJ10nKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gIExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICBpbmRleCArPSB0aGlzLl9vcmlnaW47XG4gICAgICB2YXIgbm9kZSA9IGxpc3ROb2RlRm9yKHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiBub2RlICYmIG5vZGUuYXJyYXlbaW5kZXggJiBNQVNLXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgTGlzdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdXBkYXRlTGlzdCh0aGlzLCBpbmRleCwgdmFsdWUpO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuaGFzKGluZGV4KVxuICAgICAgPyB0aGlzXG4gICAgICA6IGluZGV4ID09PSAwXG4gICAgICAgID8gdGhpcy5zaGlmdCgpXG4gICAgICAgIDogaW5kZXggPT09IHRoaXMuc2l6ZSAtIDFcbiAgICAgICAgICA/IHRoaXMucG9wKClcbiAgICAgICAgICA6IHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMCwgdmFsdWUpO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX29yaWdpbiA9IHRoaXMuX2NhcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMuX2xldmVsID0gU0hJRlQ7XG4gICAgICB0aGlzLl9yb290ID0gdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHlMaXN0KCk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgIHZhciBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgMCwgb2xkU2l6ZSArIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgbGlzdC5zZXQob2xkU2l6ZSArIGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIC0xKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCAoLyouLi52YWx1ZXMqLykge1xuICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAtdmFsdWVzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBsaXN0LnNldChpaSwgdmFsdWVzW2lpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCAoKSB7XG4gICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIExpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAoLyouLi5jb2xsZWN0aW9ucyovKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIHNlcXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyZ3VtZW50ID0gYXJndW1lbnRzJDFbaV07XG4gICAgICB2YXIgc2VxID0gSW5kZXhlZENvbGxlY3Rpb24kJDEoXG4gICAgICAgIHR5cGVvZiBhcmd1bWVudCAhPT0gJ3N0cmluZycgJiYgaGFzSXRlcmF0b3IoYXJndW1lbnQpXG4gICAgICAgICAgPyBhcmd1bWVudFxuICAgICAgICAgIDogW2FyZ3VtZW50XVxuICAgICAgKTtcbiAgICAgIGlmIChzZXEuc2l6ZSAhPT0gMCkge1xuICAgICAgICBzZXFzLnB1c2goc2VxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlcXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCAmJiAhdGhpcy5fX293bmVySUQgJiYgc2Vxcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHNlcXNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBzZXFzLmZvckVhY2goZnVuY3Rpb24gKHNlcSkgeyByZXR1cm4gc2VxLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBsaXN0LnB1c2godmFsdWUpOyB9KTsgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUgKHNpemUpIHtcbiAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCBzaXplKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzJDEuc2l6ZTsgaSsrKSB7XG4gICAgICAgIGxpc3Quc2V0KGksIG1hcHBlci5jYWxsKGNvbnRleHQsIGxpc3QuZ2V0KGkpLCBpLCBsaXN0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICBMaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyhcbiAgICAgIHRoaXMsXG4gICAgICByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpLFxuICAgICAgcmVzb2x2ZUVuZChlbmQsIHNpemUpXG4gICAgKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyB0aGlzLnNpemUgOiAwO1xuICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcygpO1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBET05FXG4gICAgICAgID8gaXRlcmF0b3JEb25lKClcbiAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyAtLWluZGV4IDogaW5kZXgrKywgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gdGhpcy5zaXplIDogMDtcbiAgICB2YXIgdmFsdWVzID0gaXRlcmF0ZUxpc3QodGhpcywgcmV2ZXJzZSk7XG4gICAgdmFyIHZhbHVlO1xuICAgIHdoaWxlICgodmFsdWUgPSB2YWx1ZXMoKSkgIT09IERPTkUpIHtcbiAgICAgIGlmIChmbih2YWx1ZSwgcmV2ZXJzZSA/IC0taW5kZXggOiBpbmRleCsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZW1wdHlMaXN0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlTGlzdChcbiAgICAgIHRoaXMuX29yaWdpbixcbiAgICAgIHRoaXMuX2NhcGFjaXR5LFxuICAgICAgdGhpcy5fbGV2ZWwsXG4gICAgICB0aGlzLl9yb290LFxuICAgICAgdGhpcy5fdGFpbCxcbiAgICAgIG93bmVySUQsXG4gICAgICB0aGlzLl9faGFzaFxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIExpc3Q7XG59KEluZGV4ZWRDb2xsZWN0aW9uKSk7XG5cbkxpc3QuaXNMaXN0ID0gaXNMaXN0O1xuXG52YXIgTGlzdFByb3RvdHlwZSA9IExpc3QucHJvdG90eXBlO1xuTGlzdFByb3RvdHlwZVtJU19MSVNUX1NZTUJPTF0gPSB0cnVlO1xuTGlzdFByb3RvdHlwZVtERUxFVEVdID0gTGlzdFByb3RvdHlwZS5yZW1vdmU7XG5MaXN0UHJvdG90eXBlLm1lcmdlID0gTGlzdFByb3RvdHlwZS5jb25jYXQ7XG5MaXN0UHJvdG90eXBlLnNldEluID0gc2V0SW4kMTtcbkxpc3RQcm90b3R5cGUuZGVsZXRlSW4gPSBMaXN0UHJvdG90eXBlLnJlbW92ZUluID0gZGVsZXRlSW47XG5MaXN0UHJvdG90eXBlLnVwZGF0ZSA9IHVwZGF0ZSQxO1xuTGlzdFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluJDE7XG5MaXN0UHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuTGlzdFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IG1lcmdlRGVlcEluO1xuTGlzdFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbkxpc3RQcm90b3R5cGUud2FzQWx0ZXJlZCA9IHdhc0FsdGVyZWQ7XG5MaXN0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5MaXN0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gTGlzdFByb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG5MaXN0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBhcnIpIHtcbiAgcmV0dXJuIHJlc3VsdC5wdXNoKGFycik7XG59O1xuTGlzdFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbn07XG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlKGFycmF5LCBvd25lcklEKSB7XG4gIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbn07XG5cbi8vIFRPRE86IHNlZW1zIGxpa2UgdGhlc2UgbWV0aG9kcyBhcmUgdmVyeSBzaW1pbGFyXG5cblZOb2RlLnByb3RvdHlwZS5yZW1vdmVCZWZvcmUgPSBmdW5jdGlvbiByZW1vdmVCZWZvcmUgKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IGxldmVsID8gMSA8PCBsZXZlbCA6IHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIG9yaWdpbkluZGV4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICBpZiAob3JpZ2luSW5kZXggPj0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKFtdLCBvd25lcklEKTtcbiAgfVxuICB2YXIgcmVtb3ZpbmdGaXJzdCA9IG9yaWdpbkluZGV4ID09PSAwO1xuICB2YXIgbmV3Q2hpbGQ7XG4gIGlmIChsZXZlbCA+IDApIHtcbiAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W29yaWdpbkluZGV4XTtcbiAgICBuZXdDaGlsZCA9XG4gICAgICBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVCZWZvcmUob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuICAgIGlmIChuZXdDaGlsZCA9PT0gb2xkQ2hpbGQgJiYgcmVtb3ZpbmdGaXJzdCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmluZ0ZpcnN0ICYmICFuZXdDaGlsZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG4gIGlmICghcmVtb3ZpbmdGaXJzdCkge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBvcmlnaW5JbmRleDsgaWkrKykge1xuICAgICAgZWRpdGFibGUuYXJyYXlbaWldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBpZiAobmV3Q2hpbGQpIHtcbiAgICBlZGl0YWJsZS5hcnJheVtvcmlnaW5JbmRleF0gPSBuZXdDaGlsZDtcbiAgfVxuICByZXR1cm4gZWRpdGFibGU7XG59O1xuXG5WTm9kZS5wcm90b3R5cGUucmVtb3ZlQWZ0ZXIgPSBmdW5jdGlvbiByZW1vdmVBZnRlciAob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gKGxldmVsID8gMSA8PCBsZXZlbCA6IDApIHx8IHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHNpemVJbmRleCA9ICgoaW5kZXggLSAxKSA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgaWYgKHNpemVJbmRleCA+PSB0aGlzLmFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIG5ld0NoaWxkO1xuICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtzaXplSW5kZXhdO1xuICAgIG5ld0NoaWxkID1cbiAgICAgIG9sZENoaWxkICYmIG9sZENoaWxkLnJlbW92ZUFmdGVyKG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4KTtcbiAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHNpemVJbmRleCA9PT0gdGhpcy5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgZWRpdGFibGUgPSBlZGl0YWJsZVZOb2RlKHRoaXMsIG93bmVySUQpO1xuICBlZGl0YWJsZS5hcnJheS5zcGxpY2Uoc2l6ZUluZGV4ICsgMSk7XG4gIGlmIChuZXdDaGlsZCkge1xuICAgIGVkaXRhYmxlLmFycmF5W3NpemVJbmRleF0gPSBuZXdDaGlsZDtcbiAgfVxuICByZXR1cm4gZWRpdGFibGU7XG59O1xuXG52YXIgRE9ORSA9IHt9O1xuXG5mdW5jdGlvbiBpdGVyYXRlTGlzdChsaXN0LCByZXZlcnNlKSB7XG4gIHZhciBsZWZ0ID0gbGlzdC5fb3JpZ2luO1xuICB2YXIgcmlnaHQgPSBsaXN0Ll9jYXBhY2l0eTtcbiAgdmFyIHRhaWxQb3MgPSBnZXRUYWlsT2Zmc2V0KHJpZ2h0KTtcbiAgdmFyIHRhaWwgPSBsaXN0Ll90YWlsO1xuXG4gIHJldHVybiBpdGVyYXRlTm9kZU9yTGVhZihsaXN0Ll9yb290LCBsaXN0Ll9sZXZlbCwgMCk7XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZU5vZGVPckxlYWYobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgIHJldHVybiBsZXZlbCA9PT0gMFxuICAgICAgPyBpdGVyYXRlTGVhZihub2RlLCBvZmZzZXQpXG4gICAgICA6IGl0ZXJhdGVOb2RlKG5vZGUsIGxldmVsLCBvZmZzZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gb2Zmc2V0ID09PSB0YWlsUG9zID8gdGFpbCAmJiB0YWlsLmFycmF5IDogbm9kZSAmJiBub2RlLmFycmF5O1xuICAgIHZhciBmcm9tID0gb2Zmc2V0ID4gbGVmdCA/IDAgOiBsZWZ0IC0gb2Zmc2V0O1xuICAgIHZhciB0byA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgIGlmICh0byA+IFNJWkUpIHtcbiAgICAgIHRvID0gU0laRTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICByZXR1cm4gRE9ORTtcbiAgICAgIH1cbiAgICAgIHZhciBpZHggPSByZXZlcnNlID8gLS10byA6IGZyb20rKztcbiAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheVtpZHhdO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbHVlcztcbiAgICB2YXIgYXJyYXkgPSBub2RlICYmIG5vZGUuYXJyYXk7XG4gICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IChsZWZ0IC0gb2Zmc2V0KSA+PiBsZXZlbDtcbiAgICB2YXIgdG8gPSAoKHJpZ2h0IC0gb2Zmc2V0KSA+PiBsZXZlbCkgKyAxO1xuICAgIGlmICh0byA+IFNJWkUpIHtcbiAgICAgIHRvID0gU0laRTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMoKTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IERPTkUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICByZXR1cm4gRE9ORTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gcmV2ZXJzZSA/IC0tdG8gOiBmcm9tKys7XG4gICAgICAgIHZhbHVlcyA9IGl0ZXJhdGVOb2RlT3JMZWFmKFxuICAgICAgICAgIGFycmF5ICYmIGFycmF5W2lkeF0sXG4gICAgICAgICAgbGV2ZWwgLSBTSElGVCxcbiAgICAgICAgICBvZmZzZXQgKyAoaWR4IDw8IGxldmVsKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUxpc3Qob3JpZ2luLCBjYXBhY2l0eSwgbGV2ZWwsIHJvb3QsIHRhaWwsIG93bmVySUQsIGhhc2gpIHtcbiAgdmFyIGxpc3QgPSBPYmplY3QuY3JlYXRlKExpc3RQcm90b3R5cGUpO1xuICBsaXN0LnNpemUgPSBjYXBhY2l0eSAtIG9yaWdpbjtcbiAgbGlzdC5fb3JpZ2luID0gb3JpZ2luO1xuICBsaXN0Ll9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICBsaXN0Ll9sZXZlbCA9IGxldmVsO1xuICBsaXN0Ll9yb290ID0gcm9vdDtcbiAgbGlzdC5fdGFpbCA9IHRhaWw7XG4gIGxpc3QuX19vd25lcklEID0gb3duZXJJRDtcbiAgbGlzdC5fX2hhc2ggPSBoYXNoO1xuICBsaXN0Ll9fYWx0ZXJlZCA9IGZhbHNlO1xuICByZXR1cm4gbGlzdDtcbn1cblxudmFyIEVNUFRZX0xJU1Q7XG5mdW5jdGlvbiBlbXB0eUxpc3QoKSB7XG4gIHJldHVybiBFTVBUWV9MSVNUIHx8IChFTVBUWV9MSVNUID0gbWFrZUxpc3QoMCwgMCwgU0hJRlQpKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdChsaXN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaW5kZXggPSB3cmFwSW5kZXgobGlzdCwgaW5kZXgpO1xuXG4gIGlmIChpbmRleCAhPT0gaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIGlmIChpbmRleCA+PSBsaXN0LnNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGxpc3Qud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgaW5kZXggPCAwXG4gICAgICAgID8gc2V0TGlzdEJvdW5kcyhsaXN0LCBpbmRleCkuc2V0KDAsIHZhbHVlKVxuICAgICAgICA6IHNldExpc3RCb3VuZHMobGlzdCwgMCwgaW5kZXggKyAxKS5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGluZGV4ICs9IGxpc3QuX29yaWdpbjtcblxuICB2YXIgbmV3VGFpbCA9IGxpc3QuX3RhaWw7XG4gIHZhciBuZXdSb290ID0gbGlzdC5fcm9vdDtcbiAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZigpO1xuICBpZiAoaW5kZXggPj0gZ2V0VGFpbE9mZnNldChsaXN0Ll9jYXBhY2l0eSkpIHtcbiAgICBuZXdUYWlsID0gdXBkYXRlVk5vZGUobmV3VGFpbCwgbGlzdC5fX293bmVySUQsIDAsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpO1xuICB9IGVsc2Uge1xuICAgIG5ld1Jvb3QgPSB1cGRhdGVWTm9kZShcbiAgICAgIG5ld1Jvb3QsXG4gICAgICBsaXN0Ll9fb3duZXJJRCxcbiAgICAgIGxpc3QuX2xldmVsLFxuICAgICAgaW5kZXgsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcbiAgfVxuXG4gIGlmICghZGlkQWx0ZXIudmFsdWUpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIGlmIChsaXN0Ll9fb3duZXJJRCkge1xuICAgIGxpc3QuX3Jvb3QgPSBuZXdSb290O1xuICAgIGxpc3QuX3RhaWwgPSBuZXdUYWlsO1xuICAgIGxpc3QuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgIGxpc3QuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuICByZXR1cm4gbWFrZUxpc3QobGlzdC5fb3JpZ2luLCBsaXN0Ll9jYXBhY2l0eSwgbGlzdC5fbGV2ZWwsIG5ld1Jvb3QsIG5ld1RhaWwpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVWTm9kZShub2RlLCBvd25lcklELCBsZXZlbCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcikge1xuICB2YXIgaWR4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICB2YXIgbm9kZUhhcyA9IG5vZGUgJiYgaWR4IDwgbm9kZS5hcnJheS5sZW5ndGg7XG4gIGlmICghbm9kZUhhcyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgbmV3Tm9kZTtcblxuICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgdmFyIGxvd2VyTm9kZSA9IG5vZGUgJiYgbm9kZS5hcnJheVtpZHhdO1xuICAgIHZhciBuZXdMb3dlck5vZGUgPSB1cGRhdGVWTm9kZShcbiAgICAgIGxvd2VyTm9kZSxcbiAgICAgIG93bmVySUQsXG4gICAgICBsZXZlbCAtIFNISUZULFxuICAgICAgaW5kZXgsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcbiAgICBpZiAobmV3TG93ZXJOb2RlID09PSBsb3dlck5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBuZXdOb2RlID0gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKTtcbiAgICBuZXdOb2RlLmFycmF5W2lkeF0gPSBuZXdMb3dlck5vZGU7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICBpZiAobm9kZUhhcyAmJiBub2RlLmFycmF5W2lkeF0gPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBpZiAoZGlkQWx0ZXIpIHtcbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICB9XG5cbiAgbmV3Tm9kZSA9IGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCk7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGlkeCA9PT0gbmV3Tm9kZS5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgbmV3Tm9kZS5hcnJheS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdOb2RlLmFycmF5W2lkeF0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gbmV3Tm9kZTtcbn1cblxuZnVuY3Rpb24gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKSB7XG4gIGlmIChvd25lcklEICYmIG5vZGUgJiYgb3duZXJJRCA9PT0gbm9kZS5vd25lcklEKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBWTm9kZShub2RlID8gbm9kZS5hcnJheS5zbGljZSgpIDogW10sIG93bmVySUQpO1xufVxuXG5mdW5jdGlvbiBsaXN0Tm9kZUZvcihsaXN0LCByYXdJbmRleCkge1xuICBpZiAocmF3SW5kZXggPj0gZ2V0VGFpbE9mZnNldChsaXN0Ll9jYXBhY2l0eSkpIHtcbiAgICByZXR1cm4gbGlzdC5fdGFpbDtcbiAgfVxuICBpZiAocmF3SW5kZXggPCAxIDw8IChsaXN0Ll9sZXZlbCArIFNISUZUKSkge1xuICAgIHZhciBub2RlID0gbGlzdC5fcm9vdDtcbiAgICB2YXIgbGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgICB3aGlsZSAobm9kZSAmJiBsZXZlbCA+IDApIHtcbiAgICAgIG5vZGUgPSBub2RlLmFycmF5WyhyYXdJbmRleCA+Pj4gbGV2ZWwpICYgTUFTS107XG4gICAgICBsZXZlbCAtPSBTSElGVDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0TGlzdEJvdW5kcyhsaXN0LCBiZWdpbiwgZW5kKSB7XG4gIC8vIFNhbml0aXplIGJlZ2luICYgZW5kIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9pbnQzMlxuICBpZiAoYmVnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGJlZ2luIHw9IDA7XG4gIH1cbiAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kIHw9IDA7XG4gIH1cbiAgdmFyIG93bmVyID0gbGlzdC5fX293bmVySUQgfHwgbmV3IE93bmVySUQoKTtcbiAgdmFyIG9sZE9yaWdpbiA9IGxpc3QuX29yaWdpbjtcbiAgdmFyIG9sZENhcGFjaXR5ID0gbGlzdC5fY2FwYWNpdHk7XG4gIHZhciBuZXdPcmlnaW4gPSBvbGRPcmlnaW4gKyBiZWdpbjtcbiAgdmFyIG5ld0NhcGFjaXR5ID1cbiAgICBlbmQgPT09IHVuZGVmaW5lZFxuICAgICAgPyBvbGRDYXBhY2l0eVxuICAgICAgOiBlbmQgPCAwXG4gICAgICAgID8gb2xkQ2FwYWNpdHkgKyBlbmRcbiAgICAgICAgOiBvbGRPcmlnaW4gKyBlbmQ7XG4gIGlmIChuZXdPcmlnaW4gPT09IG9sZE9yaWdpbiAmJiBuZXdDYXBhY2l0eSA9PT0gb2xkQ2FwYWNpdHkpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIC8vIElmIGl0J3MgZ29pbmcgdG8gZW5kIGFmdGVyIGl0IHN0YXJ0cywgaXQncyBlbXB0eS5cbiAgaWYgKG5ld09yaWdpbiA+PSBuZXdDYXBhY2l0eSkge1xuICAgIHJldHVybiBsaXN0LmNsZWFyKCk7XG4gIH1cblxuICB2YXIgbmV3TGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgdmFyIG5ld1Jvb3QgPSBsaXN0Ll9yb290O1xuXG4gIC8vIE5ldyBvcmlnaW4gbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICB2YXIgb2Zmc2V0U2hpZnQgPSAwO1xuICB3aGlsZSAobmV3T3JpZ2luICsgb2Zmc2V0U2hpZnQgPCAwKSB7XG4gICAgbmV3Um9vdCA9IG5ldyBWTm9kZShcbiAgICAgIG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbdW5kZWZpbmVkLCBuZXdSb290XSA6IFtdLFxuICAgICAgb3duZXJcbiAgICApO1xuICAgIG5ld0xldmVsICs9IFNISUZUO1xuICAgIG9mZnNldFNoaWZ0ICs9IDEgPDwgbmV3TGV2ZWw7XG4gIH1cbiAgaWYgKG9mZnNldFNoaWZ0KSB7XG4gICAgbmV3T3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgIG9sZE9yaWdpbiArPSBvZmZzZXRTaGlmdDtcbiAgICBuZXdDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgICBvbGRDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgfVxuXG4gIHZhciBvbGRUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChvbGRDYXBhY2l0eSk7XG4gIHZhciBuZXdUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChuZXdDYXBhY2l0eSk7XG5cbiAgLy8gTmV3IHNpemUgbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICB3aGlsZSAobmV3VGFpbE9mZnNldCA+PSAxIDw8IChuZXdMZXZlbCArIFNISUZUKSkge1xuICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUoXG4gICAgICBuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW25ld1Jvb3RdIDogW10sXG4gICAgICBvd25lclxuICAgICk7XG4gICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gIH1cblxuICAvLyBMb2NhdGUgb3IgY3JlYXRlIHRoZSBuZXcgdGFpbC5cbiAgdmFyIG9sZFRhaWwgPSBsaXN0Ll90YWlsO1xuICB2YXIgbmV3VGFpbCA9XG4gICAgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXRcbiAgICAgID8gbGlzdE5vZGVGb3IobGlzdCwgbmV3Q2FwYWNpdHkgLSAxKVxuICAgICAgOiBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldFxuICAgICAgICA/IG5ldyBWTm9kZShbXSwgb3duZXIpXG4gICAgICAgIDogb2xkVGFpbDtcblxuICAvLyBNZXJnZSBUYWlsIGludG8gdHJlZS5cbiAgaWYgKFxuICAgIG9sZFRhaWwgJiZcbiAgICBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldCAmJlxuICAgIG5ld09yaWdpbiA8IG9sZENhcGFjaXR5ICYmXG4gICAgb2xkVGFpbC5hcnJheS5sZW5ndGhcbiAgKSB7XG4gICAgbmV3Um9vdCA9IGVkaXRhYmxlVk5vZGUobmV3Um9vdCwgb3duZXIpO1xuICAgIHZhciBub2RlID0gbmV3Um9vdDtcbiAgICBmb3IgKHZhciBsZXZlbCA9IG5ld0xldmVsOyBsZXZlbCA+IFNISUZUOyBsZXZlbCAtPSBTSElGVCkge1xuICAgICAgdmFyIGlkeCA9IChvbGRUYWlsT2Zmc2V0ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbaWR4XSA9IGVkaXRhYmxlVk5vZGUobm9kZS5hcnJheVtpZHhdLCBvd25lcik7XG4gICAgfVxuICAgIG5vZGUuYXJyYXlbKG9sZFRhaWxPZmZzZXQgPj4+IFNISUZUKSAmIE1BU0tdID0gb2xkVGFpbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBzaXplIGhhcyBiZWVuIHJlZHVjZWQsIHRoZXJlJ3MgYSBjaGFuY2UgdGhlIHRhaWwgbmVlZHMgdG8gYmUgdHJpbW1lZC5cbiAgaWYgKG5ld0NhcGFjaXR5IDwgb2xkQ2FwYWNpdHkpIHtcbiAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUFmdGVyKG93bmVyLCAwLCBuZXdDYXBhY2l0eSk7XG4gIH1cblxuICAvLyBJZiB0aGUgbmV3IG9yaWdpbiBpcyB3aXRoaW4gdGhlIHRhaWwsIHRoZW4gd2UgZG8gbm90IG5lZWQgYSByb290LlxuICBpZiAobmV3T3JpZ2luID49IG5ld1RhaWxPZmZzZXQpIHtcbiAgICBuZXdPcmlnaW4gLT0gbmV3VGFpbE9mZnNldDtcbiAgICBuZXdDYXBhY2l0eSAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgIG5ld0xldmVsID0gU0hJRlQ7XG4gICAgbmV3Um9vdCA9IG51bGw7XG4gICAgbmV3VGFpbCA9IG5ld1RhaWwgJiYgbmV3VGFpbC5yZW1vdmVCZWZvcmUob3duZXIsIDAsIG5ld09yaWdpbik7XG5cbiAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSByb290IGhhcyBiZWVuIHRyaW1tZWQsIGdhcmJhZ2UgY29sbGVjdC5cbiAgfSBlbHNlIGlmIChuZXdPcmlnaW4gPiBvbGRPcmlnaW4gfHwgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQpIHtcbiAgICBvZmZzZXRTaGlmdCA9IDA7XG5cbiAgICAvLyBJZGVudGlmeSB0aGUgbmV3IHRvcCByb290IG5vZGUgb2YgdGhlIHN1YnRyZWUgb2YgdGhlIG9sZCByb290LlxuICAgIHdoaWxlIChuZXdSb290KSB7XG4gICAgICB2YXIgYmVnaW5JbmRleCA9IChuZXdPcmlnaW4gPj4+IG5ld0xldmVsKSAmIE1BU0s7XG4gICAgICBpZiAoKGJlZ2luSW5kZXggIT09IG5ld1RhaWxPZmZzZXQgPj4+IG5ld0xldmVsKSAmIE1BU0spIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYmVnaW5JbmRleCkge1xuICAgICAgICBvZmZzZXRTaGlmdCArPSAoMSA8PCBuZXdMZXZlbCkgKiBiZWdpbkluZGV4O1xuICAgICAgfVxuICAgICAgbmV3TGV2ZWwgLT0gU0hJRlQ7XG4gICAgICBuZXdSb290ID0gbmV3Um9vdC5hcnJheVtiZWdpbkluZGV4XTtcbiAgICB9XG5cbiAgICAvLyBUcmltIHRoZSBuZXcgc2lkZXMgb2YgdGhlIG5ldyByb290LlxuICAgIGlmIChuZXdSb290ICYmIG5ld09yaWdpbiA+IG9sZE9yaWdpbikge1xuICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQmVmb3JlKG93bmVyLCBuZXdMZXZlbCwgbmV3T3JpZ2luIC0gb2Zmc2V0U2hpZnQpO1xuICAgIH1cbiAgICBpZiAobmV3Um9vdCAmJiBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQWZ0ZXIoXG4gICAgICAgIG93bmVyLFxuICAgICAgICBuZXdMZXZlbCxcbiAgICAgICAgbmV3VGFpbE9mZnNldCAtIG9mZnNldFNoaWZ0XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0U2hpZnQpIHtcbiAgICAgIG5ld09yaWdpbiAtPSBvZmZzZXRTaGlmdDtcbiAgICAgIG5ld0NhcGFjaXR5IC09IG9mZnNldFNoaWZ0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChsaXN0Ll9fb3duZXJJRCkge1xuICAgIGxpc3Quc2l6ZSA9IG5ld0NhcGFjaXR5IC0gbmV3T3JpZ2luO1xuICAgIGxpc3QuX29yaWdpbiA9IG5ld09yaWdpbjtcbiAgICBsaXN0Ll9jYXBhY2l0eSA9IG5ld0NhcGFjaXR5O1xuICAgIGxpc3QuX2xldmVsID0gbmV3TGV2ZWw7XG4gICAgbGlzdC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgbGlzdC5fdGFpbCA9IG5ld1RhaWw7XG4gICAgbGlzdC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgbGlzdC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIHJldHVybiBtYWtlTGlzdChuZXdPcmlnaW4sIG5ld0NhcGFjaXR5LCBuZXdMZXZlbCwgbmV3Um9vdCwgbmV3VGFpbCk7XG59XG5cbmZ1bmN0aW9uIGdldFRhaWxPZmZzZXQoc2l6ZSkge1xuICByZXR1cm4gc2l6ZSA8IFNJWkUgPyAwIDogKChzaXplIC0gMSkgPj4+IFNISUZUKSA8PCBTSElGVDtcbn1cblxudmFyIE9yZGVyZWRNYXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChNYXAkJDEpIHtcbiAgZnVuY3Rpb24gT3JkZXJlZE1hcCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGVtcHR5T3JkZXJlZE1hcCgpXG4gICAgICA6IGlzT3JkZXJlZE1hcCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5T3JkZXJlZE1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gbWFwLnNldChrLCB2KTsgfSk7XG4gICAgICAgICAgfSk7XG4gIH1cblxuICBpZiAoIE1hcCQkMSApIE9yZGVyZWRNYXAuX19wcm90b19fID0gTWFwJCQxO1xuICBPcmRlcmVkTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hcCQkMSAmJiBNYXAkJDEucHJvdG90eXBlICk7XG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JkZXJlZE1hcDtcblxuICBPcmRlcmVkTWFwLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ09yZGVyZWRNYXAgeycsICd9Jyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGssIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbWFwLmdldChrKTtcbiAgICByZXR1cm4gaW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2xpc3QuZ2V0KGluZGV4KVsxXSA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgdGhpcy5fbGlzdC5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eU9yZGVyZWRNYXAoKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGssIHYpIHtcbiAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCB2KTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGspIHtcbiAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCBOT1RfU0VUKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24gd2FzQWx0ZXJlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC53YXNBbHRlcmVkKCkgfHwgdGhpcy5fbGlzdC53YXNBbHRlcmVkKCk7XG4gIH07XG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX2xpc3QuX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeSAmJiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMSk7IH0sXG4gICAgICByZXZlcnNlXG4gICAgKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHJldHVybiB0aGlzLl9saXN0LmZyb21FbnRyeVNlcSgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgdmFyIG5ld0xpc3QgPSB0aGlzLl9saXN0Ll9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eU9yZGVyZWRNYXAoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgIHRoaXMuX2xpc3QgPSBuZXdMaXN0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgfTtcblxuICByZXR1cm4gT3JkZXJlZE1hcDtcbn0oTWFwKSk7XG5cbk9yZGVyZWRNYXAuaXNPcmRlcmVkTWFwID0gaXNPcmRlcmVkTWFwO1xuXG5PcmRlcmVkTWFwLnByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuT3JkZXJlZE1hcC5wcm90b3R5cGVbREVMRVRFXSA9IE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZTtcblxuZnVuY3Rpb24gbWFrZU9yZGVyZWRNYXAobWFwLCBsaXN0LCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBvbWFwID0gT2JqZWN0LmNyZWF0ZShPcmRlcmVkTWFwLnByb3RvdHlwZSk7XG4gIG9tYXAuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgb21hcC5fbWFwID0gbWFwO1xuICBvbWFwLl9saXN0ID0gbGlzdDtcbiAgb21hcC5fX293bmVySUQgPSBvd25lcklEO1xuICBvbWFwLl9faGFzaCA9IGhhc2g7XG4gIHJldHVybiBvbWFwO1xufVxuXG52YXIgRU1QVFlfT1JERVJFRF9NQVA7XG5mdW5jdGlvbiBlbXB0eU9yZGVyZWRNYXAoKSB7XG4gIHJldHVybiAoXG4gICAgRU1QVFlfT1JERVJFRF9NQVAgfHxcbiAgICAoRU1QVFlfT1JERVJFRF9NQVAgPSBtYWtlT3JkZXJlZE1hcChlbXB0eU1hcCgpLCBlbXB0eUxpc3QoKSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9yZGVyZWRNYXAob21hcCwgaywgdikge1xuICB2YXIgbWFwID0gb21hcC5fbWFwO1xuICB2YXIgbGlzdCA9IG9tYXAuX2xpc3Q7XG4gIHZhciBpID0gbWFwLmdldChrKTtcbiAgdmFyIGhhcyA9IGkgIT09IHVuZGVmaW5lZDtcbiAgdmFyIG5ld01hcDtcbiAgdmFyIG5ld0xpc3Q7XG4gIGlmICh2ID09PSBOT1RfU0VUKSB7XG4gICAgLy8gcmVtb3ZlZFxuICAgIGlmICghaGFzKSB7XG4gICAgICByZXR1cm4gb21hcDtcbiAgICB9XG4gICAgaWYgKGxpc3Quc2l6ZSA+PSBTSVpFICYmIGxpc3Quc2l6ZSA+PSBtYXAuc2l6ZSAqIDIpIHtcbiAgICAgIG5ld0xpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAoZW50cnksIGlkeCkgeyByZXR1cm4gZW50cnkgIT09IHVuZGVmaW5lZCAmJiBpICE9PSBpZHg7IH0pO1xuICAgICAgbmV3TWFwID0gbmV3TGlzdFxuICAgICAgICAudG9LZXllZFNlcSgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeVswXTsgfSlcbiAgICAgICAgLmZsaXAoKVxuICAgICAgICAudG9NYXAoKTtcbiAgICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgICAgICBuZXdNYXAuX19vd25lcklEID0gbmV3TGlzdC5fX293bmVySUQgPSBvbWFwLl9fb3duZXJJRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3TWFwID0gbWFwLnJlbW92ZShrKTtcbiAgICAgIG5ld0xpc3QgPSBpID09PSBsaXN0LnNpemUgLSAxID8gbGlzdC5wb3AoKSA6IGxpc3Quc2V0KGksIHVuZGVmaW5lZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhcykge1xuICAgIGlmICh2ID09PSBsaXN0LmdldChpKVsxXSkge1xuICAgICAgcmV0dXJuIG9tYXA7XG4gICAgfVxuICAgIG5ld01hcCA9IG1hcDtcbiAgICBuZXdMaXN0ID0gbGlzdC5zZXQoaSwgW2ssIHZdKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdNYXAgPSBtYXAuc2V0KGssIGxpc3Quc2l6ZSk7XG4gICAgbmV3TGlzdCA9IGxpc3Quc2V0KGxpc3Quc2l6ZSwgW2ssIHZdKTtcbiAgfVxuICBpZiAob21hcC5fX293bmVySUQpIHtcbiAgICBvbWFwLnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICBvbWFwLl9tYXAgPSBuZXdNYXA7XG4gICAgb21hcC5fbGlzdCA9IG5ld0xpc3Q7XG4gICAgb21hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG9tYXA7XG4gIH1cbiAgcmV0dXJuIG1ha2VPcmRlcmVkTWFwKG5ld01hcCwgbmV3TGlzdCk7XG59XG5cbnZhciBJU19TVEFDS19TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9TVEFDS19fQEAnO1xuXG5mdW5jdGlvbiBpc1N0YWNrKG1heWJlU3RhY2spIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVTdGFjayAmJiBtYXliZVN0YWNrW0lTX1NUQUNLX1NZTUJPTF0pO1xufVxuXG52YXIgU3RhY2sgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkQ29sbGVjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBTdGFjayh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGVtcHR5U3RhY2soKVxuICAgICAgOiBpc1N0YWNrKHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogZW1wdHlTdGFjaygpLnB1c2hBbGwodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkQ29sbGVjdGlvbiQkMSApIFN0YWNrLl9fcHJvdG9fXyA9IEluZGV4ZWRDb2xsZWN0aW9uJCQxO1xuICBTdGFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkQ29sbGVjdGlvbiQkMSAmJiBJbmRleGVkQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgU3RhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhY2s7XG5cbiAgU3RhY2sub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgU3RhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1N0YWNrIFsnLCAnXScpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgU3RhY2sucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICB3aGlsZSAoaGVhZCAmJiBpbmRleC0tKSB7XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gaGVhZCA/IGhlYWQudmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIHBlZWsgKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkICYmIHRoaXMuX2hlYWQudmFsdWU7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICBTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplICsgYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgZm9yICh2YXIgaWkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgaGVhZCA9IHtcbiAgICAgICAgdmFsdWU6IGFyZ3VtZW50cyQxW2lpXSxcbiAgICAgICAgbmV4dDogaGVhZCxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUucHVzaEFsbCA9IGZ1bmN0aW9uIHB1c2hBbGwgKGl0ZXIpIHtcbiAgICBpdGVyID0gSW5kZXhlZENvbGxlY3Rpb24kJDEoaXRlcik7XG4gICAgaWYgKGl0ZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgaXNTdGFjayhpdGVyKSkge1xuICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgfVxuICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgIGl0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgbmV3U2l6ZSsrO1xuICAgICAgaGVhZCA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBuZXh0OiBoZWFkLFxuICAgICAgfTtcbiAgICB9LCAvKiByZXZlcnNlICovIHRydWUpO1xuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gcG9wICgpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHlTdGFjaygpO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgIHZhciByZXNvbHZlZEVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgIGlmIChyZXNvbHZlZEVuZCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAvLyBzdXBlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgIHJldHVybiBJbmRleGVkQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB9XG4gICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgLSByZXNvbHZlZEJlZ2luO1xuICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICB3aGlsZSAocmVzb2x2ZWRCZWdpbi0tKSB7XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cbiAgU3RhY2sucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVN0YWNrKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlU3RhY2sodGhpcy5zaXplLCB0aGlzLl9oZWFkLCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXlTZXEodGhpcy50b0FycmF5KCkpLl9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZuKHYsIGssIHRoaXMkMSk7IH0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChmbihub2RlLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5U2VxKHRoaXMudG9BcnJheSgpKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0YWNrO1xufShJbmRleGVkQ29sbGVjdGlvbikpO1xuXG5TdGFjay5pc1N0YWNrID0gaXNTdGFjaztcblxudmFyIFN0YWNrUHJvdG90eXBlID0gU3RhY2sucHJvdG90eXBlO1xuU3RhY2tQcm90b3R5cGVbSVNfU1RBQ0tfU1lNQk9MXSA9IHRydWU7XG5TdGFja1Byb3RvdHlwZS5zaGlmdCA9IFN0YWNrUHJvdG90eXBlLnBvcDtcblN0YWNrUHJvdG90eXBlLnVuc2hpZnQgPSBTdGFja1Byb3RvdHlwZS5wdXNoO1xuU3RhY2tQcm90b3R5cGUudW5zaGlmdEFsbCA9IFN0YWNrUHJvdG90eXBlLnB1c2hBbGw7XG5TdGFja1Byb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcblN0YWNrUHJvdG90eXBlLndhc0FsdGVyZWQgPSB3YXNBbHRlcmVkO1xuU3RhY2tQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcblN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gU3RhY2tQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuU3RhY2tQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGFycikge1xuICByZXR1cm4gcmVzdWx0LnVuc2hpZnQoYXJyKTtcbn07XG5TdGFja1Byb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VTdGFjayhzaXplLCBoZWFkLCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKFN0YWNrUHJvdG90eXBlKTtcbiAgbWFwLnNpemUgPSBzaXplO1xuICBtYXAuX2hlYWQgPSBoZWFkO1xuICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgbWFwLl9faGFzaCA9IGhhc2g7XG4gIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIEVNUFRZX1NUQUNLO1xuZnVuY3Rpb24gZW1wdHlTdGFjaygpIHtcbiAgcmV0dXJuIEVNUFRZX1NUQUNLIHx8IChFTVBUWV9TVEFDSyA9IG1ha2VTdGFjaygwKSk7XG59XG5cbnZhciBJU19TRVRfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfU0VUX19AQCc7XG5cbmZ1bmN0aW9uIGlzU2V0KG1heWJlU2V0KSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlU2V0ICYmIG1heWJlU2V0W0lTX1NFVF9TWU1CT0xdKTtcbn1cblxuZnVuY3Rpb24gaXNPcmRlcmVkU2V0KG1heWJlT3JkZXJlZFNldCkge1xuICByZXR1cm4gaXNTZXQobWF5YmVPcmRlcmVkU2V0KSAmJiBpc09yZGVyZWQobWF5YmVPcmRlcmVkU2V0KTtcbn1cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICAhaXNDb2xsZWN0aW9uKGIpIHx8XG4gICAgKGEuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGIuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGEuc2l6ZSAhPT0gYi5zaXplKSB8fFxuICAgIChhLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBiLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBhLl9faGFzaCAhPT0gYi5fX2hhc2gpIHx8XG4gICAgaXNLZXllZChhKSAhPT0gaXNLZXllZChiKSB8fFxuICAgIGlzSW5kZXhlZChhKSAhPT0gaXNJbmRleGVkKGIpIHx8XG4gICAgaXNPcmRlcmVkKGEpICE9PSBpc09yZGVyZWQoYilcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuc2l6ZSA9PT0gMCAmJiBiLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBub3RBc3NvY2lhdGl2ZSA9ICFpc0Fzc29jaWF0aXZlKGEpO1xuXG4gIGlmIChpc09yZGVyZWQoYSkpIHtcbiAgICB2YXIgZW50cmllcyA9IGEuZW50cmllcygpO1xuICAgIHJldHVybiAoXG4gICAgICBiLmV2ZXJ5KGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXMubmV4dCgpLnZhbHVlO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgaXMoZW50cnlbMV0sIHYpICYmIChub3RBc3NvY2lhdGl2ZSB8fCBpcyhlbnRyeVswXSwgaykpO1xuICAgICAgfSkgJiYgZW50cmllcy5uZXh0KCkuZG9uZVxuICAgICk7XG4gIH1cblxuICB2YXIgZmxpcHBlZCA9IGZhbHNlO1xuXG4gIGlmIChhLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChiLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBhLmNhY2hlUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGEuY2FjaGVSZXN1bHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgICB2YXIgXyA9IGE7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSBfO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhbGxFcXVhbCA9IHRydWU7XG4gIHZhciBiU2l6ZSA9IGIuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgaWYgKFxuICAgICAgbm90QXNzb2NpYXRpdmVcbiAgICAgICAgPyAhYS5oYXModilcbiAgICAgICAgOiBmbGlwcGVkXG4gICAgICAgICAgPyAhaXModiwgYS5nZXQoaywgTk9UX1NFVCkpXG4gICAgICAgICAgOiAhaXMoYS5nZXQoaywgTk9UX1NFVCksIHYpXG4gICAgKSB7XG4gICAgICBhbGxFcXVhbCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGFsbEVxdWFsICYmIGEuc2l6ZSA9PT0gYlNpemU7XG59XG5cbi8qKlxuICogQ29udHJpYnV0ZXMgYWRkaXRpb25hbCBtZXRob2RzIHRvIGEgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gbWl4aW4oY3RvciwgbWV0aG9kcykge1xuICB2YXIga2V5Q29waWVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGN0b3IucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gIH07XG4gIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2goa2V5Q29waWVyKTtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJlxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICByZXR1cm4gY3Rvcjtcbn1cblxuZnVuY3Rpb24gdG9KUyh2YWx1ZSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKCFpc0NvbGxlY3Rpb24odmFsdWUpKSB7XG4gICAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlID0gU2VxKHZhbHVlKTtcbiAgfVxuICBpZiAoaXNLZXllZCh2YWx1ZSkpIHtcbiAgICB2YXIgcmVzdWx0JDEgPSB7fTtcbiAgICB2YWx1ZS5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIHJlc3VsdCQxW2tdID0gdG9KUyh2KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0JDE7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YWx1ZS5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHtcbiAgICByZXN1bHQucHVzaCh0b0pTKHYpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBTZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXRDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIFNldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGVtcHR5U2V0KClcbiAgICAgIDogaXNTZXQodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBlbXB0eVNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBTZXRDb2xsZWN0aW9uJCQxKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHNldC5hZGQodik7IH0pO1xuICAgICAgICAgIH0pO1xuICB9XG5cbiAgaWYgKCBTZXRDb2xsZWN0aW9uJCQxICkgU2V0Ll9fcHJvdG9fXyA9IFNldENvbGxlY3Rpb24kJDE7XG4gIFNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXRDb2xsZWN0aW9uJCQxICYmIFNldENvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIFNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXQ7XG5cbiAgU2V0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uIGZyb21LZXlzICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzKEtleWVkQ29sbGVjdGlvbih2YWx1ZSkua2V5U2VxKCkpO1xuICB9O1xuXG4gIFNldC5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QgKHNldHMpIHtcbiAgICBzZXRzID0gQ29sbGVjdGlvbihzZXRzKS50b0FycmF5KCk7XG4gICAgcmV0dXJuIHNldHMubGVuZ3RoXG4gICAgICA/IFNldFByb3RvdHlwZS5pbnRlcnNlY3QuYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgOiBlbXB0eVNldCgpO1xuICB9O1xuXG4gIFNldC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uIChzZXRzKSB7XG4gICAgc2V0cyA9IENvbGxlY3Rpb24oc2V0cykudG9BcnJheSgpO1xuICAgIHJldHVybiBzZXRzLmxlbmd0aFxuICAgICAgPyBTZXRQcm90b3R5cGUudW5pb24uYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgOiBlbXB0eVNldCgpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2V0IHsnLCAnfScpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXModmFsdWUpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSkpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICh2YWx1ZSkge1xuICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnJlbW92ZSh2YWx1ZSkpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuY2xlYXIoKSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIFNldC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZW1vdmVzID0gW107XG4gICAgdmFyIGFkZHMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgbWFwcGVkID0gbWFwcGVyLmNhbGwoY29udGV4dCwgdmFsdWUsIHZhbHVlLCB0aGlzJDEpO1xuICAgICAgaWYgKG1hcHBlZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmVtb3Zlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgYWRkcy5wdXNoKG1hcHBlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICByZW1vdmVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzZXQucmVtb3ZlKHZhbHVlKTsgfSk7XG4gICAgICBhZGRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzZXQuYWRkKHZhbHVlKTsgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uICgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIGl0ZXJzID0gaXRlcnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNpemUgIT09IDA7IH0pO1xuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaXplID09PSAwICYmICF0aGlzLl9fb3duZXJJRCAmJiBpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKGl0ZXJzWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIFNldENvbGxlY3Rpb24kJDEoaXRlcnNbaWldKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc2V0LmFkZCh2YWx1ZSk7IH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gaW50ZXJzZWN0ICgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpdGVycyA9IGl0ZXJzLm1hcChmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gU2V0Q29sbGVjdGlvbiQkMShpdGVyKTsgfSk7XG4gICAgdmFyIHRvUmVtb3ZlID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKCFpdGVycy5ldmVyeShmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSk7IH0pKSB7XG4gICAgICAgIHRvUmVtb3ZlLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgdG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0LnJlbW92ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3QgKCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBTZXRDb2xsZWN0aW9uJCQxKGl0ZXIpOyB9KTtcbiAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoaXRlcnMuc29tZShmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSk7IH0pKSB7XG4gICAgICAgIHRvUmVtb3ZlLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgdG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0LnJlbW92ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiBzb3J0IChjb21wYXJhdG9yKSB7XG4gICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgcmV0dXJuIE9yZGVyZWRTZXQoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24gc29ydEJ5IChtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbiB3YXNBbHRlcmVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl9tYXAuX19pdGVyYXRlKGZ1bmN0aW9uIChrKSB7IHJldHVybiBmbihrLCBrLCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZW1wdHkoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX21ha2UobmV3TWFwLCBvd25lcklEKTtcbiAgfTtcblxuICByZXR1cm4gU2V0O1xufShTZXRDb2xsZWN0aW9uKSk7XG5cblNldC5pc1NldCA9IGlzU2V0O1xuXG52YXIgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcblNldFByb3RvdHlwZVtJU19TRVRfU1lNQk9MXSA9IHRydWU7XG5TZXRQcm90b3R5cGVbREVMRVRFXSA9IFNldFByb3RvdHlwZS5yZW1vdmU7XG5TZXRQcm90b3R5cGUubWVyZ2UgPSBTZXRQcm90b3R5cGUuY29uY2F0ID0gU2V0UHJvdG90eXBlLnVuaW9uO1xuU2V0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuU2V0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5TZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBTZXRQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBhcnIpIHtcbiAgcmV0dXJuIHJlc3VsdC5hZGQoYXJyKTtcbn07XG5TZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG59O1xuXG5TZXRQcm90b3R5cGUuX19lbXB0eSA9IGVtcHR5U2V0O1xuU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VTZXQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZVNldChzZXQsIG5ld01hcCkge1xuICBpZiAoc2V0Ll9fb3duZXJJRCkge1xuICAgIHNldC5zaXplID0gbmV3TWFwLnNpemU7XG4gICAgc2V0Ll9tYXAgPSBuZXdNYXA7XG4gICAgcmV0dXJuIHNldDtcbiAgfVxuICByZXR1cm4gbmV3TWFwID09PSBzZXQuX21hcFxuICAgID8gc2V0XG4gICAgOiBuZXdNYXAuc2l6ZSA9PT0gMFxuICAgICAgPyBzZXQuX19lbXB0eSgpXG4gICAgICA6IHNldC5fX21ha2UobmV3TWFwKTtcbn1cblxuZnVuY3Rpb24gbWFrZVNldChtYXAsIG93bmVySUQpIHtcbiAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoU2V0UHJvdG90eXBlKTtcbiAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gIHNldC5fbWFwID0gbWFwO1xuICBzZXQuX19vd25lcklEID0gb3duZXJJRDtcbiAgcmV0dXJuIHNldDtcbn1cblxudmFyIEVNUFRZX1NFVDtcbmZ1bmN0aW9uIGVtcHR5U2V0KCkge1xuICByZXR1cm4gRU1QVFlfU0VUIHx8IChFTVBUWV9TRVQgPSBtYWtlU2V0KGVtcHR5TWFwKCkpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGF6eSBzZXEgb2YgbnVtcyBmcm9tIHN0YXJ0IChpbmNsdXNpdmUpIHRvIGVuZFxuICogKGV4Y2x1c2l2ZSksIGJ5IHN0ZXAsIHdoZXJlIHN0YXJ0IGRlZmF1bHRzIHRvIDAsIHN0ZXAgdG8gMSwgYW5kIGVuZCB0b1xuICogaW5maW5pdHkuIFdoZW4gc3RhcnQgaXMgZXF1YWwgdG8gZW5kLCByZXR1cm5zIGVtcHR5IGxpc3QuXG4gKi9cbnZhciBSYW5nZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEkJDEpIHtcbiAgZnVuY3Rpb24gUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCk7XG4gICAgfVxuICAgIGludmFyaWFudChzdGVwICE9PSAwLCAnQ2Fubm90IHN0ZXAgYSBSYW5nZSBieSAwJyk7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gSW5maW5pdHk7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAxIDogTWF0aC5hYnMoc3RlcCk7XG4gICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gLXN0ZXA7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kID0gZW5kO1xuICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIHRoaXMuc2l6ZSA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCAtIDEpICsgMSk7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKEVNUFRZX1JBTkdFKSB7XG4gICAgICAgIHJldHVybiBFTVBUWV9SQU5HRTtcbiAgICAgIH1cbiAgICAgIEVNUFRZX1JBTkdFID0gdGhpcztcbiAgICB9XG4gIH1cblxuICBpZiAoIEluZGV4ZWRTZXEkJDEgKSBSYW5nZS5fX3Byb3RvX18gPSBJbmRleGVkU2VxJCQxO1xuICBSYW5nZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxJCQxICYmIEluZGV4ZWRTZXEkJDEucHJvdG90eXBlICk7XG4gIFJhbmdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhbmdlO1xuXG4gIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1JhbmdlIFtdJztcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgICdSYW5nZSBbICcgK1xuICAgICAgdGhpcy5fc3RhcnQgK1xuICAgICAgJy4uLicgK1xuICAgICAgdGhpcy5fZW5kICtcbiAgICAgICh0aGlzLl9zdGVwICE9PSAxID8gJyBieSAnICsgdGhpcy5fc3RlcCA6ICcnKSArXG4gICAgICAnIF0nXG4gICAgKTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpXG4gICAgICA/IHRoaXMuX3N0YXJ0ICsgd3JhcEluZGV4KHRoaXMsIGluZGV4KSAqIHRoaXMuX3N0ZXBcbiAgICAgIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHNlYXJjaFZhbHVlKSB7XG4gICAgdmFyIHBvc3NpYmxlSW5kZXggPSAoc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydCkgLyB0aGlzLl9zdGVwO1xuICAgIHJldHVybiAoXG4gICAgICBwb3NzaWJsZUluZGV4ID49IDAgJiZcbiAgICAgIHBvc3NpYmxlSW5kZXggPCB0aGlzLnNpemUgJiZcbiAgICAgIHBvc3NpYmxlSW5kZXggPT09IE1hdGguZmxvb3IocG9zc2libGVJbmRleClcbiAgICApO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgIGVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgIGlmIChlbmQgPD0gYmVnaW4pIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoMCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmFuZ2UoXG4gICAgICB0aGlzLmdldChiZWdpbiwgdGhpcy5fZW5kKSxcbiAgICAgIHRoaXMuZ2V0KGVuZCwgdGhpcy5fZW5kKSxcbiAgICAgIHRoaXMuX3N0ZXBcbiAgICApO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICB2YXIgb2Zmc2V0VmFsdWUgPSBzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGlmIChvZmZzZXRWYWx1ZSAlIHRoaXMuX3N0ZXAgPT09IDApIHtcbiAgICAgIHZhciBpbmRleCA9IG9mZnNldFZhbHVlIC8gdGhpcy5fc3RlcDtcbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoVmFsdWUpO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgIHZhciB2YWx1ZSA9IHJldmVyc2UgPyB0aGlzLl9zdGFydCArIChzaXplIC0gMSkgKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICBpZiAoZm4odmFsdWUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgKHNpemUgLSAxKSAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgdiA9IHZhbHVlO1xuICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB2KTtcbiAgICB9KTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJhbmdlXG4gICAgICA/IHRoaXMuX3N0YXJ0ID09PSBvdGhlci5fc3RhcnQgJiZcbiAgICAgICAgICB0aGlzLl9lbmQgPT09IG90aGVyLl9lbmQgJiZcbiAgICAgICAgICB0aGlzLl9zdGVwID09PSBvdGhlci5fc3RlcFxuICAgICAgOiBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuICB9O1xuXG4gIHJldHVybiBSYW5nZTtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgRU1QVFlfUkFOR0U7XG5cbmZ1bmN0aW9uIGdldEluKGNvbGxlY3Rpb24sIHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKSB7XG4gIHZhciBrZXlQYXRoID0gY29lcmNlS2V5UGF0aChzZWFyY2hLZXlQYXRoKTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSAhPT0ga2V5UGF0aC5sZW5ndGgpIHtcbiAgICBjb2xsZWN0aW9uID0gZ2V0KGNvbGxlY3Rpb24sIGtleVBhdGhbaSsrXSwgTk9UX1NFVCk7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT09IE5PVF9TRVQpIHtcbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIGdldEluJDEoc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpIHtcbiAgcmV0dXJuIGdldEluKHRoaXMsIHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaGFzSW4oY29sbGVjdGlvbiwga2V5UGF0aCkge1xuICByZXR1cm4gZ2V0SW4oY29sbGVjdGlvbiwga2V5UGF0aCwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG59XG5cbmZ1bmN0aW9uIGhhc0luJDEoc2VhcmNoS2V5UGF0aCkge1xuICByZXR1cm4gaGFzSW4odGhpcywgc2VhcmNoS2V5UGF0aCk7XG59XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICB2YXIgb2JqZWN0ID0ge307XG4gIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgb2JqZWN0W2tdID0gdjtcbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8vIE5vdGU6IGFsbCBvZiB0aGVzZSBtZXRob2RzIGFyZSBkZXByZWNhdGVkLlxuQ29sbGVjdGlvbi5pc0l0ZXJhYmxlID0gaXNDb2xsZWN0aW9uO1xuQ29sbGVjdGlvbi5pc0tleWVkID0gaXNLZXllZDtcbkNvbGxlY3Rpb24uaXNJbmRleGVkID0gaXNJbmRleGVkO1xuQ29sbGVjdGlvbi5pc0Fzc29jaWF0aXZlID0gaXNBc3NvY2lhdGl2ZTtcbkNvbGxlY3Rpb24uaXNPcmRlcmVkID0gaXNPcmRlcmVkO1xuXG5Db2xsZWN0aW9uLkl0ZXJhdG9yID0gSXRlcmF0b3I7XG5cbm1peGluKENvbGxlY3Rpb24sIHtcbiAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHRoaXMuc2l6ZSB8fCAwKTtcbiAgICB2YXIgdXNlVHVwbGVzID0gaXNLZXllZCh0aGlzKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIC8vIEtleWVkIGNvbGxlY3Rpb25zIHByb2R1Y2UgYW4gYXJyYXkgb2YgdHVwbGVzLlxuICAgICAgYXJyYXlbaSsrXSA9IHVzZVR1cGxlcyA/IFtrLCB2XSA6IHY7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuXG4gIHRvSW5kZXhlZFNlcTogZnVuY3Rpb24gdG9JbmRleGVkU2VxKCkge1xuICAgIHJldHVybiBuZXcgVG9JbmRleGVkU2VxdWVuY2UodGhpcyk7XG4gIH0sXG5cbiAgdG9KUzogZnVuY3Rpb24gdG9KUyQxKCkge1xuICAgIHJldHVybiB0b0pTKHRoaXMpO1xuICB9LFxuXG4gIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uIHRvS2V5ZWRTZXEoKSB7XG4gICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgdHJ1ZSk7XG4gIH0sXG5cbiAgdG9NYXA6IGZ1bmN0aW9uIHRvTWFwKCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcbiAgfSxcblxuICB0b09iamVjdDogdG9PYmplY3QsXG5cbiAgdG9PcmRlcmVkTWFwOiBmdW5jdGlvbiB0b09yZGVyZWRNYXAoKSB7XG4gICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBPcmRlcmVkTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcbiAgfSxcblxuICB0b09yZGVyZWRTZXQ6IGZ1bmN0aW9uIHRvT3JkZXJlZFNldCgpIHtcbiAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgcmV0dXJuIE9yZGVyZWRTZXQoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICB9LFxuXG4gIHRvU2V0OiBmdW5jdGlvbiB0b1NldCgpIHtcbiAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgcmV0dXJuIFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gIH0sXG5cbiAgdG9TZXRTZXE6IGZ1bmN0aW9uIHRvU2V0U2VxKCkge1xuICAgIHJldHVybiBuZXcgVG9TZXRTZXF1ZW5jZSh0aGlzKTtcbiAgfSxcblxuICB0b1NlcTogZnVuY3Rpb24gdG9TZXEoKSB7XG4gICAgcmV0dXJuIGlzSW5kZXhlZCh0aGlzKVxuICAgICAgPyB0aGlzLnRvSW5kZXhlZFNlcSgpXG4gICAgICA6IGlzS2V5ZWQodGhpcylcbiAgICAgICAgPyB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgICA6IHRoaXMudG9TZXRTZXEoKTtcbiAgfSxcblxuICB0b1N0YWNrOiBmdW5jdGlvbiB0b1N0YWNrKCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gU3RhY2soaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICB9LFxuXG4gIHRvTGlzdDogZnVuY3Rpb24gdG9MaXN0KCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gTGlzdChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gIH0sXG5cbiAgLy8gIyMjIENvbW1vbiBKYXZhU2NyaXB0IG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcblxuICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbQ29sbGVjdGlvbl0nO1xuICB9LFxuXG4gIF9fdG9TdHJpbmc6IGZ1bmN0aW9uIF9fdG9TdHJpbmcoaGVhZCwgdGFpbCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIGhlYWQgK1xuICAgICAgJyAnICtcbiAgICAgIHRoaXMudG9TZXEoKVxuICAgICAgICAubWFwKHRoaXMuX190b1N0cmluZ01hcHBlcilcbiAgICAgICAgLmpvaW4oJywgJykgK1xuICAgICAgJyAnICtcbiAgICAgIHRhaWxcbiAgICApO1xuICB9LFxuXG4gIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgdmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIHZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGNvbmNhdEZhY3RvcnkodGhpcywgdmFsdWVzKSk7XG4gIH0sXG5cbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSk7IH0pO1xuICB9LFxuXG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMpO1xuICB9LFxuXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfSxcblxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgfSxcblxuICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG4gIH0sXG5cbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChzaWRlRWZmZWN0LCBjb250ZXh0KSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdGUoY29udGV4dCA/IHNpZGVFZmZlY3QuYmluZChjb250ZXh0KSA6IHNpZGVFZmZlY3QpO1xuICB9LFxuXG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/ICcnICsgc2VwYXJhdG9yIDogJywnO1xuICAgIHZhciBqb2luZWQgPSAnJztcbiAgICB2YXIgaXNGaXJzdCA9IHRydWU7XG4gICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlzRmlyc3QgPyAoaXNGaXJzdCA9IGZhbHNlKSA6IChqb2luZWQgKz0gc2VwYXJhdG9yKTtcbiAgICAgIGpvaW5lZCArPSB2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCA/IHYudG9TdHJpbmcoKSA6ICcnO1xuICAgIH0pO1xuICAgIHJldHVybiBqb2luZWQ7XG4gIH0sXG5cbiAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfS0VZUyk7XG4gIH0sXG5cbiAgbWFwOiBmdW5jdGlvbiBtYXAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gIH0sXG5cbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UkMShyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlZHVjZShcbiAgICAgIHRoaXMsXG4gICAgICByZWR1Y2VyLFxuICAgICAgaW5pdGlhbFJlZHVjdGlvbixcbiAgICAgIGNvbnRleHQsXG4gICAgICBhcmd1bWVudHMubGVuZ3RoIDwgMixcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgfSxcblxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQocmVkdWNlciwgaW5pdGlhbFJlZHVjdGlvbiwgY29udGV4dCkge1xuICAgIHJldHVybiByZWR1Y2UoXG4gICAgICB0aGlzLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGluaXRpYWxSZWR1Y3Rpb24sXG4gICAgICBjb250ZXh0LFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDIsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfSxcblxuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKSk7XG4gIH0sXG5cbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIHRydWUpKTtcbiAgfSxcblxuICBzb21lOiBmdW5jdGlvbiBzb21lKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiAhdGhpcy5ldmVyeShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gIH0sXG5cbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgfSxcblxuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTKTtcbiAgfSxcblxuICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICBidXRMYXN0OiBmdW5jdGlvbiBidXRMYXN0KCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIC0xKTtcbiAgfSxcblxuICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/IHRoaXMuc2l6ZSA9PT0gMCA6ICF0aGlzLnNvbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gIH0sXG5cbiAgY291bnQ6IGZ1bmN0aW9uIGNvdW50KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBlbnN1cmVTaXplKFxuICAgICAgcHJlZGljYXRlID8gdGhpcy50b1NlcSgpLmZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIDogdGhpc1xuICAgICk7XG4gIH0sXG5cbiAgY291bnRCeTogZnVuY3Rpb24gY291bnRCeShncm91cGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvdW50QnlGYWN0b3J5KHRoaXMsIGdyb3VwZXIsIGNvbnRleHQpO1xuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIGRlZXBFcXVhbCh0aGlzLCBvdGhlcik7XG4gIH0sXG5cbiAgZW50cnlTZXE6IGZ1bmN0aW9uIGVudHJ5U2VxKCkge1xuICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICBpZiAoY29sbGVjdGlvbi5fY2FjaGUpIHtcbiAgICAgIC8vIFdlIGNhY2hlIGFzIGFuIGVudHJpZXMgYXJyYXksIHNvIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgY2FjaGUhXG4gICAgICByZXR1cm4gbmV3IEFycmF5U2VxKGNvbGxlY3Rpb24uX2NhY2hlKTtcbiAgICB9XG4gICAgdmFyIGVudHJpZXNTZXF1ZW5jZSA9IGNvbGxlY3Rpb25cbiAgICAgIC50b1NlcSgpXG4gICAgICAubWFwKGVudHJ5TWFwcGVyKVxuICAgICAgLnRvSW5kZXhlZFNlcSgpO1xuICAgIGVudHJpZXNTZXF1ZW5jZS5mcm9tRW50cnlTZXEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uLnRvU2VxKCk7IH07XG4gICAgcmV0dXJuIGVudHJpZXNTZXF1ZW5jZTtcbiAgfSxcblxuICBmaWx0ZXJOb3Q6IGZ1bmN0aW9uIGZpbHRlck5vdChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICB9LFxuXG4gIGZpbmRFbnRyeTogZnVuY3Rpb24gZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgZm91bmQgPSBub3RTZXRWYWx1ZTtcbiAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgIGZvdW5kID0gW2ssIHZdO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9LFxuXG4gIGZpbmRLZXk6IGZ1bmN0aW9uIGZpbmRLZXkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gIH0sXG5cbiAgZmluZExhc3Q6IGZ1bmN0aW9uIGZpbmRMYXN0KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGZpbmRMYXN0RW50cnk6IGZ1bmN0aW9uIGZpbmRMYXN0RW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBmaW5kTGFzdEtleTogZnVuY3Rpb24gZmluZExhc3RLZXkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmluZEtleShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICB9LFxuXG4gIGZpcnN0OiBmdW5jdGlvbiBmaXJzdChub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmQocmV0dXJuVHJ1ZSwgbnVsbCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGZsYXRNYXA6IGZ1bmN0aW9uIGZsYXRNYXAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXRNYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCkpO1xuICB9LFxuXG4gIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oZGVwdGgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIHRydWUpKTtcbiAgfSxcblxuICBmcm9tRW50cnlTZXE6IGZ1bmN0aW9uIGZyb21FbnRyeVNlcSgpIHtcbiAgICByZXR1cm4gbmV3IEZyb21FbnRyaWVzU2VxdWVuY2UodGhpcyk7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoc2VhcmNoS2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmQoZnVuY3Rpb24gKF8sIGtleSkgeyByZXR1cm4gaXMoa2V5LCBzZWFyY2hLZXkpOyB9LCB1bmRlZmluZWQsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBnZXRJbjogZ2V0SW4kMSxcblxuICBncm91cEJ5OiBmdW5jdGlvbiBncm91cEJ5KGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZ3JvdXBCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiBoYXMoc2VhcmNoS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlYXJjaEtleSwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG4gIH0sXG5cbiAgaGFzSW46IGhhc0luJDEsXG5cbiAgaXNTdWJzZXQ6IGZ1bmN0aW9uIGlzU3Vic2V0KGl0ZXIpIHtcbiAgICBpdGVyID0gdHlwZW9mIGl0ZXIuaW5jbHVkZXMgPT09ICdmdW5jdGlvbicgPyBpdGVyIDogQ29sbGVjdGlvbihpdGVyKTtcbiAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpOyB9KTtcbiAgfSxcblxuICBpc1N1cGVyc2V0OiBmdW5jdGlvbiBpc1N1cGVyc2V0KGl0ZXIpIHtcbiAgICBpdGVyID0gdHlwZW9mIGl0ZXIuaXNTdWJzZXQgPT09ICdmdW5jdGlvbicgPyBpdGVyIDogQ29sbGVjdGlvbihpdGVyKTtcbiAgICByZXR1cm4gaXRlci5pc1N1YnNldCh0aGlzKTtcbiAgfSxcblxuICBrZXlPZjogZnVuY3Rpb24ga2V5T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kS2V5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXModmFsdWUsIHNlYXJjaFZhbHVlKTsgfSk7XG4gIH0sXG5cbiAga2V5U2VxOiBmdW5jdGlvbiBrZXlTZXEoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TZXEoKVxuICAgICAgLm1hcChrZXlNYXBwZXIpXG4gICAgICAudG9JbmRleGVkU2VxKCk7XG4gIH0sXG5cbiAgbGFzdDogZnVuY3Rpb24gbGFzdChub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRvU2VxKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maXJzdChub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgbGFzdEtleU9mOiBmdW5jdGlvbiBsYXN0S2V5T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gIH0sXG5cbiAgbWF4OiBmdW5jdGlvbiBtYXgoY29tcGFyYXRvcikge1xuICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpO1xuICB9LFxuXG4gIG1heEJ5OiBmdW5jdGlvbiBtYXhCeShtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpO1xuICB9LFxuXG4gIG1pbjogZnVuY3Rpb24gbWluKGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbWF4RmFjdG9yeShcbiAgICAgIHRoaXMsXG4gICAgICBjb21wYXJhdG9yID8gbmVnKGNvbXBhcmF0b3IpIDogZGVmYXVsdE5lZ0NvbXBhcmF0b3JcbiAgICApO1xuICB9LFxuXG4gIG1pbkJ5OiBmdW5jdGlvbiBtaW5CeShtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbWF4RmFjdG9yeShcbiAgICAgIHRoaXMsXG4gICAgICBjb21wYXJhdG9yID8gbmVnKGNvbXBhcmF0b3IpIDogZGVmYXVsdE5lZ0NvbXBhcmF0b3IsXG4gICAgICBtYXBwZXJcbiAgICApO1xuICB9LFxuXG4gIHJlc3Q6IGZ1bmN0aW9uIHJlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoMSk7XG4gIH0sXG5cbiAgc2tpcDogZnVuY3Rpb24gc2tpcChhbW91bnQpIHtcbiAgICByZXR1cm4gYW1vdW50ID09PSAwID8gdGhpcyA6IHRoaXMuc2xpY2UoTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gIH0sXG5cbiAgc2tpcExhc3Q6IGZ1bmN0aW9uIHNraXBMYXN0KGFtb3VudCkge1xuICAgIHJldHVybiBhbW91bnQgPT09IDAgPyB0aGlzIDogdGhpcy5zbGljZSgwLCAtTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gIH0sXG5cbiAgc2tpcFdoaWxlOiBmdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNraXBXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCB0cnVlKSk7XG4gIH0sXG5cbiAgc2tpcFVudGlsOiBmdW5jdGlvbiBza2lwVW50aWwocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2tpcFdoaWxlKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgfSxcblxuICBzb3J0Qnk6IGZ1bmN0aW9uIHNvcnRCeShtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gIH0sXG5cbiAgdGFrZTogZnVuY3Rpb24gdGFrZShhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgwLCBNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgfSxcblxuICB0YWtlTGFzdDogZnVuY3Rpb24gdGFrZUxhc3QoYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoLU1hdGgubWF4KDAsIGFtb3VudCkpO1xuICB9LFxuXG4gIHRha2VXaGlsZTogZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCB0YWtlV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCkpO1xuICB9LFxuXG4gIHRha2VVbnRpbDogZnVuY3Rpb24gdGFrZVVudGlsKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnRha2VXaGlsZShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZm4pIHtcbiAgICByZXR1cm4gZm4odGhpcyk7XG4gIH0sXG5cbiAgdmFsdWVTZXE6IGZ1bmN0aW9uIHZhbHVlU2VxKCkge1xuICAgIHJldHVybiB0aGlzLnRvSW5kZXhlZFNlcSgpO1xuICB9LFxuXG4gIC8vICMjIyBIYXNoYWJsZSBPYmplY3RcblxuICBoYXNoQ29kZTogZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19oYXNoIHx8ICh0aGlzLl9faGFzaCA9IGhhc2hDb2xsZWN0aW9uKHRoaXMpKTtcbiAgfSxcblxuICAvLyAjIyMgSW50ZXJuYWxcblxuICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGUoZm4sIHJldmVyc2UpXG5cbiAgLy8gYWJzdHJhY3QgX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKVxufSk7XG5cbnZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbi5wcm90b3R5cGU7XG5Db2xsZWN0aW9uUHJvdG90eXBlW0lTX0NPTExFQ1RJT05fU1lNQk9MXSA9IHRydWU7XG5Db2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBDb2xsZWN0aW9uUHJvdG90eXBlLnZhbHVlcztcbkNvbGxlY3Rpb25Qcm90b3R5cGUudG9KU09OID0gQ29sbGVjdGlvblByb3RvdHlwZS50b0FycmF5O1xuQ29sbGVjdGlvblByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gcXVvdGVTdHJpbmc7XG5Db2xsZWN0aW9uUHJvdG90eXBlLmluc3BlY3QgPSBDb2xsZWN0aW9uUHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG59O1xuQ29sbGVjdGlvblByb3RvdHlwZS5jaGFpbiA9IENvbGxlY3Rpb25Qcm90b3R5cGUuZmxhdE1hcDtcbkNvbGxlY3Rpb25Qcm90b3R5cGUuY29udGFpbnMgPSBDb2xsZWN0aW9uUHJvdG90eXBlLmluY2x1ZGVzO1xuXG5taXhpbihLZXllZENvbGxlY3Rpb24sIHtcbiAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgZmxpcDogZnVuY3Rpb24gZmxpcCgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmxpcEZhY3RvcnkodGhpcykpO1xuICB9LFxuXG4gIG1hcEVudHJpZXM6IGZ1bmN0aW9uIG1hcEVudHJpZXMobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMudG9TZXEoKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXBwZXIuY2FsbChjb250ZXh0LCBbaywgdl0sIGl0ZXJhdGlvbnMrKywgdGhpcyQxKTsgfSlcbiAgICAgICAgLmZyb21FbnRyeVNlcSgpXG4gICAgKTtcbiAgfSxcblxuICBtYXBLZXlzOiBmdW5jdGlvbiBtYXBLZXlzKG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMudG9TZXEoKVxuICAgICAgICAuZmxpcCgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGssIHYpIHsgcmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIGssIHYsIHRoaXMkMSk7IH0pXG4gICAgICAgIC5mbGlwKClcbiAgICApO1xuICB9LFxufSk7XG5cbnZhciBLZXllZENvbGxlY3Rpb25Qcm90b3R5cGUgPSBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlO1xuS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lTX0tFWUVEX1NZTUJPTF0gPSB0cnVlO1xuS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBDb2xsZWN0aW9uUHJvdG90eXBlLmVudHJpZXM7XG5LZXllZENvbGxlY3Rpb25Qcm90b3R5cGUudG9KU09OID0gdG9PYmplY3Q7XG5LZXllZENvbGxlY3Rpb25Qcm90b3R5cGUuX190b1N0cmluZ01hcHBlciA9IGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBxdW90ZVN0cmluZyhrKSArICc6ICcgKyBxdW90ZVN0cmluZyh2KTsgfTtcblxubWl4aW4oSW5kZXhlZENvbGxlY3Rpb24sIHtcbiAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICB0b0tleWVkU2VxOiBmdW5jdGlvbiB0b0tleWVkU2VxKCkge1xuICAgIHJldHVybiBuZXcgVG9LZXllZFNlcXVlbmNlKHRoaXMsIGZhbHNlKTtcbiAgfSxcblxuICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZpbHRlckZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCBmYWxzZSkpO1xuICB9LFxuXG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMF0gOiAtMTtcbiAgfSxcblxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaFZhbHVlKSB7XG4gICAgdmFyIGtleSA9IHRoaXMua2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/IC0xIDoga2V5O1xuICB9LFxuXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hWYWx1ZSkge1xuICAgIHZhciBrZXkgPSB0aGlzLmxhc3RLZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gIH0sXG5cbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgcmV2ZXJzZUZhY3RvcnkodGhpcywgZmFsc2UpKTtcbiAgfSxcblxuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgZmFsc2UpKTtcbiAgfSxcblxuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShpbmRleCwgcmVtb3ZlTnVtIC8qLCAuLi52YWx1ZXMqLykge1xuICAgIHZhciBudW1BcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZW1vdmVOdW0gPSBNYXRoLm1heChyZW1vdmVOdW0gfHwgMCwgMCk7XG4gICAgaWYgKG51bUFyZ3MgPT09IDAgfHwgKG51bUFyZ3MgPT09IDIgJiYgIXJlbW92ZU51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBJZiBpbmRleCBpcyBuZWdhdGl2ZSwgaXQgc2hvdWxkIHJlc29sdmUgcmVsYXRpdmUgdG8gdGhlIHNpemUgb2YgdGhlXG4gICAgLy8gY29sbGVjdGlvbi4gSG93ZXZlciBzaXplIG1heSBiZSBleHBlbnNpdmUgdG8gY29tcHV0ZSBpZiBub3QgY2FjaGVkLCBzb1xuICAgIC8vIG9ubHkgY2FsbCBjb3VudCgpIGlmIHRoZSBudW1iZXIgaXMgaW4gZmFjdCBuZWdhdGl2ZS5cbiAgICBpbmRleCA9IHJlc29sdmVCZWdpbihpbmRleCwgaW5kZXggPCAwID8gdGhpcy5jb3VudCgpIDogdGhpcy5zaXplKTtcbiAgICB2YXIgc3BsaWNlZCA9IHRoaXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgIHJldHVybiByZWlmeShcbiAgICAgIHRoaXMsXG4gICAgICBudW1BcmdzID09PSAxXG4gICAgICAgID8gc3BsaWNlZFxuICAgICAgICA6IHNwbGljZWQuY29uY2F0KGFyckNvcHkoYXJndW1lbnRzLCAyKSwgdGhpcy5zbGljZShpbmRleCArIHJlbW92ZU51bSkpXG4gICAgKTtcbiAgfSxcblxuICAvLyAjIyMgTW9yZSBjb2xsZWN0aW9uIG1ldGhvZHNcblxuICBmaW5kTGFzdEluZGV4OiBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZExhc3RFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzBdIDogLTE7XG4gIH0sXG5cbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KDAsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKGRlcHRoKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXR0ZW5GYWN0b3J5KHRoaXMsIGRlcHRoLCBmYWxzZSkpO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gZ2V0KGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPCAwIHx8XG4gICAgICAodGhpcy5zaXplID09PSBJbmZpbml0eSB8fCAodGhpcy5zaXplICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPiB0aGlzLnNpemUpKVxuICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgOiB0aGlzLmZpbmQoZnVuY3Rpb24gKF8sIGtleSkgeyByZXR1cm4ga2V5ID09PSBpbmRleDsgfSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiBoYXMoaW5kZXgpIHtcbiAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgcmV0dXJuIChcbiAgICAgIGluZGV4ID49IDAgJiZcbiAgICAgICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHwgaW5kZXggPCB0aGlzLnNpemVcbiAgICAgICAgOiB0aGlzLmluZGV4T2YoaW5kZXgpICE9PSAtMSlcbiAgICApO1xuICB9LFxuXG4gIGludGVycG9zZTogZnVuY3Rpb24gaW50ZXJwb3NlKHNlcGFyYXRvcikge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcnBvc2VGYWN0b3J5KHRoaXMsIHNlcGFyYXRvcikpO1xuICB9LFxuXG4gIGludGVybGVhdmU6IGZ1bmN0aW9uIGludGVybGVhdmUoLyouLi5jb2xsZWN0aW9ucyovKSB7XG4gICAgdmFyIGNvbGxlY3Rpb25zID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgIHZhciB6aXBwZWQgPSB6aXBXaXRoRmFjdG9yeSh0aGlzLnRvU2VxKCksIEluZGV4ZWRTZXEub2YsIGNvbGxlY3Rpb25zKTtcbiAgICB2YXIgaW50ZXJsZWF2ZWQgPSB6aXBwZWQuZmxhdHRlbih0cnVlKTtcbiAgICBpZiAoemlwcGVkLnNpemUpIHtcbiAgICAgIGludGVybGVhdmVkLnNpemUgPSB6aXBwZWQuc2l6ZSAqIGNvbGxlY3Rpb25zLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGludGVybGVhdmVkKTtcbiAgfSxcblxuICBrZXlTZXE6IGZ1bmN0aW9uIGtleVNlcSgpIHtcbiAgICByZXR1cm4gUmFuZ2UoMCwgdGhpcy5zaXplKTtcbiAgfSxcblxuICBsYXN0OiBmdW5jdGlvbiBsYXN0KG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KC0xLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgc2tpcFdoaWxlOiBmdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNraXBXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCBmYWxzZSkpO1xuICB9LFxuXG4gIHppcDogZnVuY3Rpb24gemlwKC8qLCAuLi5jb2xsZWN0aW9ucyAqLykge1xuICAgIHZhciBjb2xsZWN0aW9ucyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgZGVmYXVsdFppcHBlciwgY29sbGVjdGlvbnMpKTtcbiAgfSxcblxuICB6aXBBbGw6IGZ1bmN0aW9uIHppcEFsbCgvKiwgLi4uY29sbGVjdGlvbnMgKi8pIHtcbiAgICB2YXIgY29sbGVjdGlvbnMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIGRlZmF1bHRaaXBwZXIsIGNvbGxlY3Rpb25zLCB0cnVlKSk7XG4gIH0sXG5cbiAgemlwV2l0aDogZnVuY3Rpb24gemlwV2l0aCh6aXBwZXIgLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgdmFyIGNvbGxlY3Rpb25zID0gYXJyQ29weShhcmd1bWVudHMpO1xuICAgIGNvbGxlY3Rpb25zWzBdID0gdGhpcztcbiAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgemlwcGVyLCBjb2xsZWN0aW9ucykpO1xuICB9LFxufSk7XG5cbnZhciBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZSA9IEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZTtcbkluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lTX0lOREVYRURfU1lNQk9MXSA9IHRydWU7XG5JbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuXG5taXhpbihTZXRDb2xsZWN0aW9uLCB7XG4gIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICBnZXQ6IGZ1bmN0aW9uIGdldCh2YWx1ZSwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpID8gdmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgfSxcblxuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXModmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpO1xuICB9LFxuXG4gIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlU2VxKCk7XG4gIH0sXG59KTtcblxuU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuaGFzID0gQ29sbGVjdGlvblByb3RvdHlwZS5pbmNsdWRlcztcblNldENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnRhaW5zID0gU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuaW5jbHVkZXM7XG5cbi8vIE1peGluIHN1YmNsYXNzZXNcblxubWl4aW4oS2V5ZWRTZXEsIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUpO1xubWl4aW4oSW5kZXhlZFNlcSwgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlKTtcbm1peGluKFNldFNlcSwgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUpO1xuXG4vLyAjcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIHJlZHVjZXIsIHJlZHVjdGlvbiwgY29udGV4dCwgdXNlRmlyc3QsIHJldmVyc2UpIHtcbiAgYXNzZXJ0Tm90SW5maW5pdGUoY29sbGVjdGlvbi5zaXplKTtcbiAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICBpZiAodXNlRmlyc3QpIHtcbiAgICAgIHVzZUZpcnN0ID0gZmFsc2U7XG4gICAgICByZWR1Y3Rpb24gPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWR1Y3Rpb24gPSByZWR1Y2VyLmNhbGwoY29udGV4dCwgcmVkdWN0aW9uLCB2LCBrLCBjKTtcbiAgICB9XG4gIH0sIHJldmVyc2UpO1xuICByZXR1cm4gcmVkdWN0aW9uO1xufVxuXG5mdW5jdGlvbiBrZXlNYXBwZXIodiwgaykge1xuICByZXR1cm4gaztcbn1cblxuZnVuY3Rpb24gZW50cnlNYXBwZXIodiwgaykge1xuICByZXR1cm4gW2ssIHZdO1xufVxuXG5mdW5jdGlvbiBub3QocHJlZGljYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBuZWcocHJlZGljYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gLXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0WmlwcGVyKCkge1xuICByZXR1cm4gYXJyQ29weShhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0TmVnQ29tcGFyYXRvcihhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IDEgOiBhID4gYiA/IC0xIDogMDtcbn1cblxuZnVuY3Rpb24gaGFzaENvbGxlY3Rpb24oY29sbGVjdGlvbikge1xuICBpZiAoY29sbGVjdGlvbi5zaXplID09PSBJbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBvcmRlcmVkID0gaXNPcmRlcmVkKGNvbGxlY3Rpb24pO1xuICB2YXIga2V5ZWQgPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICB2YXIgaCA9IG9yZGVyZWQgPyAxIDogMDtcbiAgdmFyIHNpemUgPSBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICBrZXllZFxuICAgICAgPyBvcmRlcmVkXG4gICAgICAgID8gZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgIGggPSAoMzEgKiBoICsgaGFzaE1lcmdlKGhhc2godiksIGhhc2goaykpKSB8IDA7XG4gICAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICBoID0gKGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkpIHwgMDtcbiAgICAgICAgICB9XG4gICAgICA6IG9yZGVyZWRcbiAgICAgICAgPyBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaCA9ICgzMSAqIGggKyBoYXNoKHYpKSB8IDA7XG4gICAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBoID0gKGggKyBoYXNoKHYpKSB8IDA7XG4gICAgICAgICAgfVxuICApO1xuICByZXR1cm4gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKTtcbn1cblxuZnVuY3Rpb24gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKSB7XG4gIGggPSBpbXVsKGgsIDB4Y2M5ZTJkNTEpO1xuICBoID0gaW11bCgoaCA8PCAxNSkgfCAoaCA+Pj4gLTE1KSwgMHgxYjg3MzU5Myk7XG4gIGggPSBpbXVsKChoIDw8IDEzKSB8IChoID4+PiAtMTMpLCA1KTtcbiAgaCA9ICgoaCArIDB4ZTY1NDZiNjQpIHwgMCkgXiBzaXplO1xuICBoID0gaW11bChoIF4gKGggPj4+IDE2KSwgMHg4NWViY2E2Yik7XG4gIGggPSBpbXVsKGggXiAoaCA+Pj4gMTMpLCAweGMyYjJhZTM1KTtcbiAgaCA9IHNtaShoIF4gKGggPj4+IDE2KSk7XG4gIHJldHVybiBoO1xufVxuXG5mdW5jdGlvbiBoYXNoTWVyZ2UoYSwgYikge1xuICByZXR1cm4gKGEgXiAoYiArIDB4OWUzNzc5YjkgKyAoYSA8PCA2KSArIChhID4+IDIpKSkgfCAwOyAvLyBpbnRcbn1cblxudmFyIE9yZGVyZWRTZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXQkJDEpIHtcbiAgZnVuY3Rpb24gT3JkZXJlZFNldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGVtcHR5T3JkZXJlZFNldCgpXG4gICAgICA6IGlzT3JkZXJlZFNldCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5T3JkZXJlZFNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBTZXRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHNldC5hZGQodik7IH0pO1xuICAgICAgICAgIH0pO1xuICB9XG5cbiAgaWYgKCBTZXQkJDEgKSBPcmRlcmVkU2V0Ll9fcHJvdG9fXyA9IFNldCQkMTtcbiAgT3JkZXJlZFNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXQkJDEgJiYgU2V0JCQxLnByb3RvdHlwZSApO1xuICBPcmRlcmVkU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9yZGVyZWRTZXQ7XG5cbiAgT3JkZXJlZFNldC5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgfTtcblxuICBPcmRlcmVkU2V0LmZyb21LZXlzID0gZnVuY3Rpb24gZnJvbUtleXMgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMoS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKS5rZXlTZXEoKSk7XG4gIH07XG5cbiAgT3JkZXJlZFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZFNldCB7JywgJ30nKTtcbiAgfTtcblxuICByZXR1cm4gT3JkZXJlZFNldDtcbn0oU2V0KSk7XG5cbk9yZGVyZWRTZXQuaXNPcmRlcmVkU2V0ID0gaXNPcmRlcmVkU2V0O1xuXG52YXIgT3JkZXJlZFNldFByb3RvdHlwZSA9IE9yZGVyZWRTZXQucHJvdG90eXBlO1xuT3JkZXJlZFNldFByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuT3JkZXJlZFNldFByb3RvdHlwZS56aXAgPSBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZS56aXA7XG5PcmRlcmVkU2V0UHJvdG90eXBlLnppcFdpdGggPSBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZS56aXBXaXRoO1xuXG5PcmRlcmVkU2V0UHJvdG90eXBlLl9fZW1wdHkgPSBlbXB0eU9yZGVyZWRTZXQ7XG5PcmRlcmVkU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VPcmRlcmVkU2V0O1xuXG5mdW5jdGlvbiBtYWtlT3JkZXJlZFNldChtYXAsIG93bmVySUQpIHtcbiAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZFNldFByb3RvdHlwZSk7XG4gIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICBzZXQuX21hcCA9IG1hcDtcbiAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gIHJldHVybiBzZXQ7XG59XG5cbnZhciBFTVBUWV9PUkRFUkVEX1NFVDtcbmZ1bmN0aW9uIGVtcHR5T3JkZXJlZFNldCgpIHtcbiAgcmV0dXJuIChcbiAgICBFTVBUWV9PUkRFUkVEX1NFVCB8fCAoRU1QVFlfT1JERVJFRF9TRVQgPSBtYWtlT3JkZXJlZFNldChlbXB0eU9yZGVyZWRNYXAoKSkpXG4gICk7XG59XG5cbnZhciBSZWNvcmQgPSBmdW5jdGlvbiBSZWNvcmQoZGVmYXVsdFZhbHVlcywgbmFtZSkge1xuICB2YXIgaGFzSW5pdGlhbGl6ZWQ7XG5cbiAgdmFyIFJlY29yZFR5cGUgPSBmdW5jdGlvbiBSZWNvcmQodmFsdWVzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkge1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlY29yZFR5cGUpKSB7XG4gICAgICByZXR1cm4gbmV3IFJlY29yZFR5cGUodmFsdWVzKTtcbiAgICB9XG4gICAgaWYgKCFoYXNJbml0aWFsaXplZCkge1xuICAgICAgaGFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0VmFsdWVzKTtcbiAgICAgIHZhciBpbmRpY2VzID0gKFJlY29yZFR5cGVQcm90b3R5cGUuX2luZGljZXMgPSB7fSk7XG4gICAgICAvLyBEZXByZWNhdGVkOiBsZWZ0IHRvIGF0dGVtcHQgbm90IHRvIGJyZWFrIGFueSBleHRlcm5hbCBjb2RlIHdoaWNoXG4gICAgICAvLyByZWxpZXMgb24gYSAuX25hbWUgcHJvcGVydHkgZXhpc3Rpbmcgb24gcmVjb3JkIGluc3RhbmNlcy5cbiAgICAgIC8vIFVzZSBSZWNvcmQuZ2V0RGVzY3JpcHRpdmVOYW1lKCkgaW5zdGVhZFxuICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fbmFtZSA9IG5hbWU7XG4gICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9rZXlzID0ga2V5cztcbiAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX2RlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VmFsdWVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IGtleXNbaV07XG4gICAgICAgIGluZGljZXNbcHJvcE5hbWVdID0gaTtcbiAgICAgICAgaWYgKFJlY29yZFR5cGVQcm90b3R5cGVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgIHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICdDYW5ub3QgZGVmaW5lICcgK1xuICAgICAgICAgICAgICAgIHJlY29yZE5hbWUodGhpcykgK1xuICAgICAgICAgICAgICAgICcgd2l0aCBwcm9wZXJ0eSBcIicgK1xuICAgICAgICAgICAgICAgIHByb3BOYW1lICtcbiAgICAgICAgICAgICAgICAnXCIgc2luY2UgdGhhdCBwcm9wZXJ0eSBuYW1lIGlzIHBhcnQgb2YgdGhlIFJlY29yZCBBUEkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQcm9wKFJlY29yZFR5cGVQcm90b3R5cGUsIHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9fb3duZXJJRCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZXMgPSBMaXN0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobCkge1xuICAgICAgbC5zZXRTaXplKHRoaXMkMS5fa2V5cy5sZW5ndGgpO1xuICAgICAgS2V5ZWRDb2xsZWN0aW9uKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuICAgICAgICBsLnNldCh0aGlzJDEuX2luZGljZXNba10sIHYgPT09IHRoaXMkMS5fZGVmYXVsdFZhbHVlc1trXSA/IHVuZGVmaW5lZCA6IHYpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIFJlY29yZFR5cGVQcm90b3R5cGUgPSAoUmVjb3JkVHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFxuICAgIFJlY29yZFByb3RvdHlwZVxuICApKTtcbiAgUmVjb3JkVHlwZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY29yZFR5cGU7XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBSZWNvcmRUeXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgfVxuXG4gIHJldHVybiBSZWNvcmRUeXBlO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIHN0ciA9IHJlY29yZE5hbWUodGhpcykgKyAnIHsgJztcbiAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICB2YXIgaztcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSAhPT0gbDsgaSsrKSB7XG4gICAgayA9IGtleXNbaV07XG4gICAgc3RyICs9IChpID8gJywgJyA6ICcnKSArIGsgKyAnOiAnICsgcXVvdGVTdHJpbmcodGhpcy5nZXQoaykpO1xuICB9XG4gIHJldHVybiBzdHIgKyAnIH0nO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcyA9PT0gb3RoZXIgfHxcbiAgICAob3RoZXIgJiZcbiAgICAgIHRoaXMuX2tleXMgPT09IG90aGVyLl9rZXlzICYmXG4gICAgICByZWNvcmRTZXEodGhpcykuZXF1YWxzKHJlY29yZFNlcShvdGhlcikpKVxuICApO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlICgpIHtcbiAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5oYXNoQ29kZSgpO1xufTtcblxuLy8gQHByYWdtYSBBY2Nlc3NcblxuUmVjb3JkLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGspIHtcbiAgcmV0dXJuIHRoaXMuX2luZGljZXMuaGFzT3duUHJvcGVydHkoayk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgaWYgKCF0aGlzLmhhcyhrKSkge1xuICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgfVxuICB2YXIgaW5kZXggPSB0aGlzLl9pbmRpY2VzW2tdO1xuICB2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZXMuZ2V0KGluZGV4KTtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB0aGlzLl9kZWZhdWx0VmFsdWVzW2tdIDogdmFsdWU7XG59O1xuXG4vLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG5SZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICBpZiAodGhpcy5oYXMoaykpIHtcbiAgICB2YXIgbmV3VmFsdWVzID0gdGhpcy5fdmFsdWVzLnNldChcbiAgICAgIHRoaXMuX2luZGljZXNba10sXG4gICAgICB2ID09PSB0aGlzLl9kZWZhdWx0VmFsdWVzW2tdID8gdW5kZWZpbmVkIDogdlxuICAgICk7XG4gICAgaWYgKG5ld1ZhbHVlcyAhPT0gdGhpcy5fdmFsdWVzICYmICF0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3VmFsdWVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICByZXR1cm4gdGhpcy5zZXQoayk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICB2YXIgbmV3VmFsdWVzID0gdGhpcy5fdmFsdWVzLmNsZWFyKCkuc2V0U2l6ZSh0aGlzLl9rZXlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzLl9fb3duZXJJRCA/IHRoaXMgOiBtYWtlUmVjb3JkKHRoaXMsIG5ld1ZhbHVlcyk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbiB3YXNBbHRlcmVkICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ZhbHVlcy53YXNBbHRlcmVkKCk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLnRvU2VxID0gZnVuY3Rpb24gdG9TZXEgKCkge1xuICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS50b0pTID0gZnVuY3Rpb24gdG9KUyQxICgpIHtcbiAgcmV0dXJuIHRvSlModGhpcyk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgbmV3VmFsdWVzID0gdGhpcy5fdmFsdWVzLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gIGlmICghb3duZXJJRCkge1xuICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLl92YWx1ZXMgPSBuZXdWYWx1ZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3VmFsdWVzLCBvd25lcklEKTtcbn07XG5cblJlY29yZC5pc1JlY29yZCA9IGlzUmVjb3JkO1xuUmVjb3JkLmdldERlc2NyaXB0aXZlTmFtZSA9IHJlY29yZE5hbWU7XG52YXIgUmVjb3JkUHJvdG90eXBlID0gUmVjb3JkLnByb3RvdHlwZTtcblJlY29yZFByb3RvdHlwZVtJU19SRUNPUkRfU1lNQk9MXSA9IHRydWU7XG5SZWNvcmRQcm90b3R5cGVbREVMRVRFXSA9IFJlY29yZFByb3RvdHlwZS5yZW1vdmU7XG5SZWNvcmRQcm90b3R5cGUuZGVsZXRlSW4gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlSW4gPSBkZWxldGVJbjtcblJlY29yZFByb3RvdHlwZS5nZXRJbiA9IGdldEluJDE7XG5SZWNvcmRQcm90b3R5cGUuaGFzSW4gPSBDb2xsZWN0aW9uUHJvdG90eXBlLmhhc0luO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlID0gbWVyZ2U7XG5SZWNvcmRQcm90b3R5cGUubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcCQxO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBtZXJnZURlZXBXaXRoJDE7XG5SZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBtZXJnZURlZXBJbjtcblJlY29yZFByb3RvdHlwZS5zZXRJbiA9IHNldEluJDE7XG5SZWNvcmRQcm90b3R5cGUudXBkYXRlID0gdXBkYXRlJDE7XG5SZWNvcmRQcm90b3R5cGUudXBkYXRlSW4gPSB1cGRhdGVJbiQxO1xuUmVjb3JkUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuUmVjb3JkUHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcblJlY29yZFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuUmVjb3JkUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBSZWNvcmRQcm90b3R5cGUuZW50cmllcztcblJlY29yZFByb3RvdHlwZS50b0pTT04gPSBSZWNvcmRQcm90b3R5cGUudG9PYmplY3QgPVxuICBDb2xsZWN0aW9uUHJvdG90eXBlLnRvT2JqZWN0O1xuUmVjb3JkUHJvdG90eXBlLmluc3BlY3QgPSBSZWNvcmRQcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VSZWNvcmQobGlrZVJlY29yZCwgdmFsdWVzLCBvd25lcklEKSB7XG4gIHZhciByZWNvcmQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihsaWtlUmVjb3JkKSk7XG4gIHJlY29yZC5fdmFsdWVzID0gdmFsdWVzO1xuICByZWNvcmQuX19vd25lcklEID0gb3duZXJJRDtcbiAgcmV0dXJuIHJlY29yZDtcbn1cblxuZnVuY3Rpb24gcmVjb3JkTmFtZShyZWNvcmQpIHtcbiAgcmV0dXJuIHJlY29yZC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCByZWNvcmQuY29uc3RydWN0b3IubmFtZSB8fCAnUmVjb3JkJztcbn1cblxuZnVuY3Rpb24gcmVjb3JkU2VxKHJlY29yZCkge1xuICByZXR1cm4ga2V5ZWRTZXFGcm9tVmFsdWUocmVjb3JkLl9rZXlzLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gW2ssIHJlY29yZC5nZXQoayldOyB9KSk7XG59XG5cbmZ1bmN0aW9uIHNldFByb3AocHJvdG90eXBlLCBuYW1lKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuX19vd25lcklELCAnQ2Fubm90IHNldCBvbiBhbiBpbW11dGFibGUgcmVjb3JkLicpO1xuICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBmYWlsZWQuIFByb2JhYmx5IElFOC5cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBsYXp5IFNlcSBvZiBgdmFsdWVgIHJlcGVhdGVkIGB0aW1lc2AgdGltZXMuIFdoZW4gYHRpbWVzYCBpc1xuICogdW5kZWZpbmVkLCByZXR1cm5zIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mIGB2YWx1ZWAuXG4gKi9cbnZhciBSZXBlYXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxJCQxKSB7XG4gIGZ1bmN0aW9uIFJlcGVhdCh2YWx1ZSwgdGltZXMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVwZWF0KSkge1xuICAgICAgcmV0dXJuIG5ldyBSZXBlYXQodmFsdWUsIHRpbWVzKTtcbiAgICB9XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnNpemUgPSB0aW1lcyA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiBNYXRoLm1heCgwLCB0aW1lcyk7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKEVNUFRZX1JFUEVBVCkge1xuICAgICAgICByZXR1cm4gRU1QVFlfUkVQRUFUO1xuICAgICAgfVxuICAgICAgRU1QVFlfUkVQRUFUID0gdGhpcztcbiAgICB9XG4gIH1cblxuICBpZiAoIEluZGV4ZWRTZXEkJDEgKSBSZXBlYXQuX19wcm90b19fID0gSW5kZXhlZFNlcSQkMTtcbiAgUmVwZWF0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEkJDEgJiYgSW5kZXhlZFNlcSQkMS5wcm90b3R5cGUgKTtcbiAgUmVwZWF0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGVhdDtcblxuICBSZXBlYXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiAnUmVwZWF0IFtdJztcbiAgICB9XG4gICAgcmV0dXJuICdSZXBlYXQgWyAnICsgdGhpcy5fdmFsdWUgKyAnICcgKyB0aGlzLnNpemUgKyAnIHRpbWVzIF0nO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID8gdGhpcy5fdmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHNlYXJjaFZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSk7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgcmV0dXJuIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSlcbiAgICAgID8gdGhpc1xuICAgICAgOiBuZXcgUmVwZWF0KFxuICAgICAgICAgIHRoaXMuX3ZhbHVlLFxuICAgICAgICAgIHJlc29sdmVFbmQoZW5kLCBzaXplKSAtIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSlcbiAgICAgICAgKTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgaWYgKGZuKHRoaXMuX3ZhbHVlLCByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihcbiAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGkgPT09IHNpemVcbiAgICAgICAgICA/IGl0ZXJhdG9yRG9uZSgpXG4gICAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzJDEuX3ZhbHVlKTsgfVxuICAgICk7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmVwZWF0XG4gICAgICA/IGlzKHRoaXMuX3ZhbHVlLCBvdGhlci5fdmFsdWUpXG4gICAgICA6IGRlZXBFcXVhbChvdGhlcik7XG4gIH07XG5cbiAgcmV0dXJuIFJlcGVhdDtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgRU1QVFlfUkVQRUFUO1xuXG5mdW5jdGlvbiBmcm9tSlModmFsdWUsIGNvbnZlcnRlcikge1xuICByZXR1cm4gZnJvbUpTV2l0aChcbiAgICBbXSxcbiAgICBjb252ZXJ0ZXIgfHwgZGVmYXVsdENvbnZlcnRlcixcbiAgICB2YWx1ZSxcbiAgICAnJyxcbiAgICBjb252ZXJ0ZXIgJiYgY29udmVydGVyLmxlbmd0aCA+IDIgPyBbXSA6IHVuZGVmaW5lZCxcbiAgICB7ICcnOiB2YWx1ZSB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGZyb21KU1dpdGgoc3RhY2ssIGNvbnZlcnRlciwgdmFsdWUsIGtleSwga2V5UGF0aCwgcGFyZW50VmFsdWUpIHtcbiAgdmFyIHRvU2VxID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICA/IEluZGV4ZWRTZXFcbiAgICA6IGlzUGxhaW5PYmoodmFsdWUpXG4gICAgICA/IEtleWVkU2VxXG4gICAgICA6IG51bGw7XG4gIGlmICh0b1NlcSkge1xuICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGNpcmN1bGFyIHN0cnVjdHVyZSB0byBJbW11dGFibGUnKTtcbiAgICB9XG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAga2V5UGF0aCAmJiBrZXkgIT09ICcnICYmIGtleVBhdGgucHVzaChrZXkpO1xuICAgIHZhciBjb252ZXJ0ZWQgPSBjb252ZXJ0ZXIuY2FsbChcbiAgICAgIHBhcmVudFZhbHVlLFxuICAgICAga2V5LFxuICAgICAgdG9TZXEodmFsdWUpLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZnJvbUpTV2l0aChzdGFjaywgY29udmVydGVyLCB2LCBrLCBrZXlQYXRoLCB2YWx1ZSk7IH1cbiAgICAgICksXG4gICAgICBrZXlQYXRoICYmIGtleVBhdGguc2xpY2UoKVxuICAgICk7XG4gICAgc3RhY2sucG9wKCk7XG4gICAga2V5UGF0aCAmJiBrZXlQYXRoLnBvcCgpO1xuICAgIHJldHVybiBjb252ZXJ0ZWQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udmVydGVyKGssIHYpIHtcbiAgcmV0dXJuIGlzS2V5ZWQodikgPyB2LnRvTWFwKCkgOiB2LnRvTGlzdCgpO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiNC4wLjAtcmMuMTFcIjtcblxudmFyIEltbXV0YWJsZSA9IHtcbiAgdmVyc2lvbjogdmVyc2lvbixcblxuICBDb2xsZWN0aW9uOiBDb2xsZWN0aW9uLFxuICAvLyBOb3RlOiBJdGVyYWJsZSBpcyBkZXByZWNhdGVkXG4gIEl0ZXJhYmxlOiBDb2xsZWN0aW9uLFxuXG4gIFNlcTogU2VxLFxuICBNYXA6IE1hcCxcbiAgT3JkZXJlZE1hcDogT3JkZXJlZE1hcCxcbiAgTGlzdDogTGlzdCxcbiAgU3RhY2s6IFN0YWNrLFxuICBTZXQ6IFNldCxcbiAgT3JkZXJlZFNldDogT3JkZXJlZFNldCxcblxuICBSZWNvcmQ6IFJlY29yZCxcbiAgUmFuZ2U6IFJhbmdlLFxuICBSZXBlYXQ6IFJlcGVhdCxcblxuICBpczogaXMsXG4gIGZyb21KUzogZnJvbUpTLFxuICBoYXNoOiBoYXNoLFxuXG4gIGlzSW1tdXRhYmxlOiBpc0ltbXV0YWJsZSxcbiAgaXNDb2xsZWN0aW9uOiBpc0NvbGxlY3Rpb24sXG4gIGlzS2V5ZWQ6IGlzS2V5ZWQsXG4gIGlzSW5kZXhlZDogaXNJbmRleGVkLFxuICBpc0Fzc29jaWF0aXZlOiBpc0Fzc29jaWF0aXZlLFxuICBpc09yZGVyZWQ6IGlzT3JkZXJlZCxcbiAgaXNWYWx1ZU9iamVjdDogaXNWYWx1ZU9iamVjdCxcbiAgaXNTZXE6IGlzU2VxLFxuICBpc0xpc3Q6IGlzTGlzdCxcbiAgaXNNYXA6IGlzTWFwLFxuICBpc09yZGVyZWRNYXA6IGlzT3JkZXJlZE1hcCxcbiAgaXNTdGFjazogaXNTdGFjayxcbiAgaXNTZXQ6IGlzU2V0LFxuICBpc09yZGVyZWRTZXQ6IGlzT3JkZXJlZFNldCxcbiAgaXNSZWNvcmQ6IGlzUmVjb3JkLFxuXG4gIGdldDogZ2V0LFxuICBnZXRJbjogZ2V0SW4sXG4gIGhhczogaGFzLFxuICBoYXNJbjogaGFzSW4sXG4gIG1lcmdlOiBtZXJnZSQxLFxuICBtZXJnZURlZXA6IG1lcmdlRGVlcCxcbiAgbWVyZ2VXaXRoOiBtZXJnZVdpdGgkMSxcbiAgbWVyZ2VEZWVwV2l0aDogbWVyZ2VEZWVwV2l0aCxcbiAgcmVtb3ZlOiByZW1vdmUsXG4gIHJlbW92ZUluOiByZW1vdmVJbixcbiAgc2V0OiBzZXQsXG4gIHNldEluOiBzZXRJbixcbiAgdXBkYXRlOiB1cGRhdGUsXG4gIHVwZGF0ZUluOiB1cGRhdGVJbixcbn07XG5cbi8vIE5vdGU6IEl0ZXJhYmxlIGlzIGRlcHJlY2F0ZWRcbnZhciBJdGVyYWJsZSA9IENvbGxlY3Rpb247XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoSW1tdXRhYmxlKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC1jYXB0dXJlL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC1jYXB0dXJlL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmNvbnN0IG1pbmltYXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIG1pbmltYXRjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9taW5pbWF0Y2guanNcIilcbmNvbnN0IHNwbGl0UmUgPSAvKFshPysqQF1cXChbXildK1xcKXxcXCp7MSwyfXxcXD8pL1xuY29uc3QgZW5kV2l0aE5lZ1JlID0gLyFcXChbXildK1xcKSQvXG5cbmNsYXNzIENhcHR1cmUge1xuXHRjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5wYXR0ZXJuID0gcGF0dGVyblxuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblx0fVxuXG5cdG1ha2VSZSgpIHtcblx0XHRpZiAoIXRoaXMucmVnZXhwICYmIHRoaXMucmVnZXhwICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5yZWdleHAgPSBtYWtlUmUodGhpcy5wYXR0ZXJuLCB0aGlzLm9wdGlvbnMpXG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnJlZ2V4cFxuXHR9XG5cblx0Y2FwdHVyZShwYXRoKSB7XG5cdFx0bGV0IHJlc3VsdCA9IGZhbHNlXG5cdFx0bGV0IG1hdGNoID0gcGF0aC5tYXRjaCh0aGlzLm1ha2VSZSgpKVxuXHRcdGlmIChtYXRjaCkge1xuXHRcdFx0bWF0Y2ggPSBtYXRjaC5maWx0ZXIoaXNEZWYpXG5cdFx0XHRyZXN1bHQgPSBtYXRjaFsxXSB8fCBtYXRjaFswXVxuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMubm90cmltICYmIHJlc3VsdCAhPT0gXCIvXCIpIHtcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL15cXC98XFwvJC9nLCBcIlwiKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cbn1cblxuZnVuY3Rpb24gc3BsaXQocGF0dGVybikge1xuXHRjb25zdCBwYXJ0cyA9IHBhdHRlcm4uc3BsaXQoc3BsaXRSZSlcblx0aWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdHJldHVybiBbXCJcIiwgcGFydHNbMF0sIFwiXCJdXG5cdH1cblx0cmV0dXJuIFtwYXJ0c1swXSwgcGFydHMuc2xpY2UoMSwgLTEpLmpvaW4oXCJcIiksIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXVxufVxuXG5jb25zdCBub25lZ2F0ZSA9IHtub25lZ2F0ZTogdHJ1ZX1cblxuZnVuY3Rpb24gX21ha2VSZShwYXR0ZXJuLCBvcHRpb25zKSB7XG5cdGNvbnN0IGZsYWdzID0gb3B0aW9ucyAmJiBvcHRpb25zLm5vY2FzZSA/IFwiaVwiIDogXCJcIlxuXHRjb25zdCBzdWJwYXR0ZXJucyA9IG1pbmltYXRjaC5icmFjZUV4cGFuZChwYXR0ZXJuLCBvcHRpb25zKVxuXHRjb25zdCBleHByZXNzaW9ucyA9IHN1YnBhdHRlcm5zLm1hcChzdWJwYXR0ZXJuID0+IHtcblx0XHRjb25zdCBwYXJ0cyA9IHNwbGl0KHN1YnBhdHRlcm4pXG5cdFx0Y29uc3QgbGVmdCA9IHBhcnRzWzBdXG5cdFx0Y29uc3QgbWlkZGxlID0gcGFydHNbMV1cblx0XHRjb25zdCByaWdodCA9IHBhcnRzWzJdXG5cdFx0Y29uc3Qgb3B0cyA9IGxlZnQgPyBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBub25lZ2F0ZSkgOiBvcHRpb25zXG5cdFx0Y29uc3QgcmUgPSBtaW5pbWF0Y2gubWFrZVJlKG1pZGRsZSwgb3B0cylcblx0XHRsZXQgY2FwdHVyZSA9IHJlLnNvdXJjZS5zbGljZSg0LCAtMilcblx0XHRpZiAoZW5kV2l0aE5lZ1JlLnRlc3QobWlkZGxlKSkge1xuXHRcdFx0Y2FwdHVyZSA9IGNhcHR1cmUucmVwbGFjZSgvXFwpXFwkXFwpL2csXG5cdFx0XHRcdFwiKD9cIiArIChyaWdodC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiPVwiIDogXCIhXCIpICsgXCIvKSkpXCJcblx0XHRcdClcblx0XHR9XG5cdFx0cmV0dXJuIHJlZ0V4cEVzY2FwZShsZWZ0KSArIFwiKFwiICsgY2FwdHVyZSArIFwiKVwiICsgcmVnRXhwRXNjYXBlKHJpZ2h0KVxuXHR9KVxuXHRyZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIGV4cHJlc3Npb25zLmpvaW4oXCJ8XCIpICsgXCIpJFwiLCBmbGFncylcbn1cblxuZnVuY3Rpb24gbWFrZVJlKHBhdHRlcm4sIG9wdGlvbnMpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gX21ha2VSZShwYXR0ZXJuLCBvcHRpb25zKVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuZnVuY3Rpb24gbWF0Y2gobGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuXHRjb25zdCBjYXAgPSBuZXcgQ2FwdHVyZShwYXR0ZXJuLCBvcHRpb25zKVxuXHRjb25zdCByZXN1bHQgPSBbXVxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBwYXRoID0gbGlzdFtpXVxuXHRcdGNvbnN0IG1hdGNoID0gY2FwLmNhcHR1cmUocGF0aClcblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdHJlc3VsdC5wdXNoKFtwYXRoLCBtYXRjaF0pXG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXRoLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2FwdHVyZShwYXR0ZXJuLCBvcHRpb25zKS5jYXB0dXJlKHBhdGgpXG59XG5cbk9iamVjdC5hc3NpZ24obW9kdWxlLmV4cG9ydHMsIHtcblx0Q2FwdHVyZSxcblx0c3BsaXQsXG5cdG1ha2VSZSxcblx0bWF0Y2gsXG59KVxuXG5mdW5jdGlvbiBpc0RlZih2KSB7XG5cdHJldHVybiB2ICE9PSB1bmRlZmluZWRcbn1cblxuLy8gcHJpdmF0ZSBmdW5jdGlvbiBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL21pbmltYXRjaFxuZnVuY3Rpb24gcmVnRXhwRXNjYXBlKHMpIHtcblx0cmV0dXJuIHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpXG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9taW5pbWF0Y2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbmltYXRjaFxubWluaW1hdGNoLk1pbmltYXRjaCA9IE1pbmltYXRjaFxuXG52YXIgcGF0aCA9IHsgc2VwOiAnLycgfVxudHJ5IHtcbiAgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHBhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanNcIilcbn0gY2F0Y2ggKGVyKSB7fVxuXG52YXIgR0xPQlNUQVIgPSBtaW5pbWF0Y2guR0xPQlNUQVIgPSBNaW5pbWF0Y2guR0xPQlNUQVIgPSB7fVxudmFyIGV4cGFuZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGJyYWNlLWV4cGFuc2lvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2JyYWNlLWV4cGFuc2lvbi9pbmRleC5qc1wiKVxuXG52YXIgcGxUeXBlcyA9IHtcbiAgJyEnOiB7IG9wZW46ICcoPzooPyEoPzonLCBjbG9zZTogJykpW14vXSo/KSd9LFxuICAnPyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKT8nIH0sXG4gICcrJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKycgfSxcbiAgJyonOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJykqJyB9LFxuICAnQCc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKScgfVxufVxuXG4vLyBhbnkgc2luZ2xlIHRoaW5nIG90aGVyIHRoYW4gL1xuLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgLyB3aGVuIHVzaW5nIG5ldyBSZWdFeHAoKVxudmFyIHFtYXJrID0gJ1teL10nXG5cbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG52YXIgc3RhciA9IHFtYXJrICsgJyo/J1xuXG4vLyAqKiB3aGVuIGRvdHMgYXJlIGFsbG93ZWQuICBBbnl0aGluZyBnb2VzLCBleGNlcHQgLi4gYW5kIC5cbi8vIG5vdCAoXiBvciAvIGZvbGxvd2VkIGJ5IG9uZSBvciB0d28gZG90cyBmb2xsb3dlZCBieSAkIG9yIC8pLFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG52YXIgdHdvU3RhckRvdCA9ICcoPzooPyEoPzpcXFxcXFwvfF4pKD86XFxcXC57MSwyfSkoJHxcXFxcXFwvKSkuKSo/J1xuXG4vLyBub3QgYSBeIG9yIC8gZm9sbG93ZWQgYnkgYSBkb3QsXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbnZhciB0d29TdGFyTm9Eb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKVxcXFwuKS4pKj8nXG5cbi8vIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVzY2FwZWQgaW4gUmVnRXhwLlxudmFyIHJlU3BlY2lhbHMgPSBjaGFyU2V0KCcoKS4qe30rP1tdXiRcXFxcIScpXG5cbi8vIFwiYWJjXCIgLT4geyBhOnRydWUsIGI6dHJ1ZSwgYzp0cnVlIH1cbmZ1bmN0aW9uIGNoYXJTZXQgKHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoJycpLnJlZHVjZShmdW5jdGlvbiAoc2V0LCBjKSB7XG4gICAgc2V0W2NdID0gdHJ1ZVxuICAgIHJldHVybiBzZXRcbiAgfSwge30pXG59XG5cbi8vIG5vcm1hbGl6ZXMgc2xhc2hlcy5cbnZhciBzbGFzaFNwbGl0ID0gL1xcLysvXG5cbm1pbmltYXRjaC5maWx0ZXIgPSBmaWx0ZXJcbmZ1bmN0aW9uIGZpbHRlciAocGF0dGVybiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICByZXR1cm4gZnVuY3Rpb24gKHAsIGksIGxpc3QpIHtcbiAgICByZXR1cm4gbWluaW1hdGNoKHAsIHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0IChhLCBiKSB7XG4gIGEgPSBhIHx8IHt9XG4gIGIgPSBiIHx8IHt9XG4gIHZhciB0ID0ge31cbiAgT2JqZWN0LmtleXMoYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHRba10gPSBiW2tdXG4gIH0pXG4gIE9iamVjdC5rZXlzKGEpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB0W2tdID0gYVtrXVxuICB9KVxuICByZXR1cm4gdFxufVxuXG5taW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmIHx8ICFPYmplY3Qua2V5cyhkZWYpLmxlbmd0aCkgcmV0dXJuIG1pbmltYXRjaFxuXG4gIHZhciBvcmlnID0gbWluaW1hdGNoXG5cbiAgdmFyIG0gPSBmdW5jdGlvbiBtaW5pbWF0Y2ggKHAsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5taW5pbWF0Y2gocCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLk1pbmltYXRjaCA9IGZ1bmN0aW9uIE1pbmltYXRjaCAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgb3JpZy5NaW5pbWF0Y2gocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICByZXR1cm4gbVxufVxuXG5NaW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmIHx8ICFPYmplY3Qua2V5cyhkZWYpLmxlbmd0aCkgcmV0dXJuIE1pbmltYXRjaFxuICByZXR1cm4gbWluaW1hdGNoLmRlZmF1bHRzKGRlZikuTWluaW1hdGNoXG59XG5cbmZ1bmN0aW9uIG1pbmltYXRjaCAocCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2xvYiBwYXR0ZXJuIHN0cmluZyByZXF1aXJlZCcpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIC8vIHNob3J0Y3V0OiBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFwiXCIgb25seSBtYXRjaGVzIFwiXCJcbiAgaWYgKHBhdHRlcm4udHJpbSgpID09PSAnJykgcmV0dXJuIHAgPT09ICcnXG5cbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWF0Y2gocClcbn1cblxuZnVuY3Rpb24gTWluaW1hdGNoIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpKSB7XG4gICAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnbG9iIHBhdHRlcm4gc3RyaW5nIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG4gIHBhdHRlcm4gPSBwYXR0ZXJuLnRyaW0oKVxuXG4gIC8vIHdpbmRvd3Mgc3VwcG9ydDogbmVlZCB0byB1c2UgLywgbm90IFxcXG4gIGlmIChwYXRoLnNlcCAhPT0gJy8nKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLnNldCA9IFtdXG4gIHRoaXMucGF0dGVybiA9IHBhdHRlcm5cbiAgdGhpcy5yZWdleHAgPSBudWxsXG4gIHRoaXMubmVnYXRlID0gZmFsc2VcbiAgdGhpcy5jb21tZW50ID0gZmFsc2VcbiAgdGhpcy5lbXB0eSA9IGZhbHNlXG5cbiAgLy8gbWFrZSB0aGUgc2V0IG9mIHJlZ2V4cHMgZXRjLlxuICB0aGlzLm1ha2UoKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge31cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlID0gbWFrZVxuZnVuY3Rpb24gbWFrZSAoKSB7XG4gIC8vIGRvbid0IGRvIGl0IG1vcmUgdGhhbiBvbmNlLlxuICBpZiAodGhpcy5fbWFkZSkgcmV0dXJuXG5cbiAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyBlbXB0eSBwYXR0ZXJucyBhbmQgY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgdGhpcy5jb21tZW50ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9XG4gIGlmICghcGF0dGVybikge1xuICAgIHRoaXMuZW1wdHkgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBzdGVwIDE6IGZpZ3VyZSBvdXQgbmVnYXRpb24sIGV0Yy5cbiAgdGhpcy5wYXJzZU5lZ2F0ZSgpXG5cbiAgLy8gc3RlcCAyOiBleHBhbmQgYnJhY2VzXG4gIHZhciBzZXQgPSB0aGlzLmdsb2JTZXQgPSB0aGlzLmJyYWNlRXhwYW5kKClcblxuICBpZiAob3B0aW9ucy5kZWJ1ZykgdGhpcy5kZWJ1ZyA9IGNvbnNvbGUuZXJyb3JcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZiBwYXRoLXBvcnRpb25cbiAgLy8gbWF0Y2hpbmcgcGF0dGVybnMuXG4gIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gIHNldCA9IHRoaXMuZ2xvYlBhcnRzID0gc2V0Lm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnNwbGl0KHNsYXNoU3BsaXQpXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBnbG9iIC0tPiByZWdleHBzXG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24gKHMsIHNpLCBzZXQpIHtcbiAgICByZXR1cm4gcy5tYXAodGhpcy5wYXJzZSwgdGhpcylcbiAgfSwgdGhpcylcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuaW5kZXhPZihmYWxzZSkgPT09IC0xXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICB0aGlzLnNldCA9IHNldFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlTmVnYXRlID0gcGFyc2VOZWdhdGVcbmZ1bmN0aW9uIHBhcnNlTmVnYXRlICgpIHtcbiAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5cbiAgdmFyIG5lZ2F0ZSA9IGZhbHNlXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gIHZhciBuZWdhdGVPZmZzZXQgPSAwXG5cbiAgaWYgKG9wdGlvbnMubm9uZWdhdGUpIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0dGVybi5sZW5ndGhcbiAgICA7IGkgPCBsICYmIHBhdHRlcm4uY2hhckF0KGkpID09PSAnISdcbiAgICA7IGkrKykge1xuICAgIG5lZ2F0ZSA9ICFuZWdhdGVcbiAgICBuZWdhdGVPZmZzZXQrK1xuICB9XG5cbiAgaWYgKG5lZ2F0ZU9mZnNldCkgdGhpcy5wYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIobmVnYXRlT2Zmc2V0KVxuICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZVxufVxuXG4vLyBCcmFjZSBleHBhbnNpb246XG4vLyBhe2IsY31kIC0+IGFiZCBhY2Rcbi8vIGF7Yix9YyAtPiBhYmMgYWNcbi8vIGF7MC4uM31kIC0+IGEwZCBhMWQgYTJkIGEzZFxuLy8gYXtiLGN7ZCxlfWZ9ZyAtPiBhYmcgYWNkZmcgYWNlZmdcbi8vIGF7YixjfWR7ZSxmfWcgLT4gYWJkZWcgYWNkZWcgYWJkZWcgYWJkZmdcbi8vXG4vLyBJbnZhbGlkIHNldHMgYXJlIG5vdCBleHBhbmRlZC5cbi8vIGF7Mi4ufWIgLT4gYXsyLi59YlxuLy8gYXtifWMgLT4gYXtifWNcbm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBicmFjZUV4cGFuZChwYXR0ZXJuLCBvcHRpb25zKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmJyYWNlRXhwYW5kID0gYnJhY2VFeHBhbmRcblxuZnVuY3Rpb24gYnJhY2VFeHBhbmQgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuICB9XG5cbiAgcGF0dGVybiA9IHR5cGVvZiBwYXR0ZXJuID09PSAndW5kZWZpbmVkJ1xuICAgID8gdGhpcy5wYXR0ZXJuIDogcGF0dGVyblxuXG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmRlZmluZWQgcGF0dGVybicpXG4gIH1cblxuICBpZiAob3B0aW9ucy5ub2JyYWNlIHx8XG4gICAgIXBhdHRlcm4ubWF0Y2goL1xcey4qXFx9LykpIHtcbiAgICAvLyBzaG9ydGN1dC4gbm8gbmVlZCB0byBleHBhbmQuXG4gICAgcmV0dXJuIFtwYXR0ZXJuXVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuZChwYXR0ZXJuKVxufVxuXG4vLyBwYXJzZSBhIGNvbXBvbmVudCBvZiB0aGUgZXhwYW5kZWQgc2V0LlxuLy8gQXQgdGhpcyBwb2ludCwgbm8gcGF0dGVybiBtYXkgY29udGFpbiBcIi9cIiBpbiBpdFxuLy8gc28gd2UncmUgZ29pbmcgdG8gcmV0dXJuIGEgMmQgYXJyYXksIHdoZXJlIGVhY2ggZW50cnkgaXMgdGhlIGZ1bGxcbi8vIHBhdHRlcm4sIHNwbGl0IG9uICcvJywgYW5kIHRoZW4gdHVybmVkIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24uXG4vLyBBIHJlZ2V4cCBpcyBtYWRlIGF0IHRoZSBlbmQgd2hpY2ggam9pbnMgZWFjaCBhcnJheSB3aXRoIGFuXG4vLyBlc2NhcGVkIC8sIGFuZCBhbm90aGVyIGZ1bGwgb25lIHdoaWNoIGpvaW5zIGVhY2ggcmVnZXhwIHdpdGggfC5cbi8vXG4vLyBGb2xsb3dpbmcgdGhlIGxlYWQgb2YgQmFzaCA0LjEsIG5vdGUgdGhhdCBcIioqXCIgb25seSBoYXMgc3BlY2lhbCBtZWFuaW5nXG4vLyB3aGVuIGl0IGlzIHRoZSAqb25seSogdGhpbmcgaW4gYSBwYXRoIHBvcnRpb24uICBPdGhlcndpc2UsIGFueSBzZXJpZXNcbi8vIG9mICogaXMgZXF1aXZhbGVudCB0byBhIHNpbmdsZSAqLiAgR2xvYnN0YXIgYmVoYXZpb3IgaXMgZW5hYmxlZCBieVxuLy8gZGVmYXVsdCwgYW5kIGNhbiBiZSBkaXNhYmxlZCBieSBzZXR0aW5nIG9wdGlvbnMubm9nbG9ic3Rhci5cbk1pbmltYXRjaC5wcm90b3R5cGUucGFyc2UgPSBwYXJzZVxudmFyIFNVQlBBUlNFID0ge31cbmZ1bmN0aW9uIHBhcnNlIChwYXR0ZXJuLCBpc1N1Yikge1xuICBpZiAocGF0dGVybi5sZW5ndGggPiAxMDI0ICogNjQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXR0ZXJuIGlzIHRvbyBsb25nJylcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gc2hvcnRjdXRzXG4gIGlmICghb3B0aW9ucy5ub2dsb2JzdGFyICYmIHBhdHRlcm4gPT09ICcqKicpIHJldHVybiBHTE9CU1RBUlxuICBpZiAocGF0dGVybiA9PT0gJycpIHJldHVybiAnJ1xuXG4gIHZhciByZSA9ICcnXG4gIHZhciBoYXNNYWdpYyA9ICEhb3B0aW9ucy5ub2Nhc2VcbiAgdmFyIGVzY2FwaW5nID0gZmFsc2VcbiAgLy8gPyA9PiBvbmUgc2luZ2xlIGNoYXJhY3RlclxuICB2YXIgcGF0dGVybkxpc3RTdGFjayA9IFtdXG4gIHZhciBuZWdhdGl2ZUxpc3RzID0gW11cbiAgdmFyIHN0YXRlQ2hhclxuICB2YXIgaW5DbGFzcyA9IGZhbHNlXG4gIHZhciByZUNsYXNzU3RhcnQgPSAtMVxuICB2YXIgY2xhc3NTdGFydCA9IC0xXG4gIC8vIC4gYW5kIC4uIG5ldmVyIG1hdGNoIGFueXRoaW5nIHRoYXQgZG9lc24ndCBzdGFydCB3aXRoIC4sXG4gIC8vIGV2ZW4gd2hlbiBvcHRpb25zLmRvdCBpcyBzZXQuXG4gIHZhciBwYXR0ZXJuU3RhcnQgPSBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy4nID8gJycgLy8gYW55dGhpbmdcbiAgLy8gbm90IChzdGFydCBvciAvIGZvbGxvd2VkIGJ5IC4gb3IgLi4gZm9sbG93ZWQgYnkgLyBvciBlbmQpXG4gIDogb3B0aW9ucy5kb3QgPyAnKD8hKD86XnxcXFxcXFwvKVxcXFwuezEsMn0oPzokfFxcXFxcXC8pKSdcbiAgOiAnKD8hXFxcXC4pJ1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmdW5jdGlvbiBjbGVhclN0YXRlQ2hhciAoKSB7XG4gICAgaWYgKHN0YXRlQ2hhcikge1xuICAgICAgLy8gd2UgaGFkIHNvbWUgc3RhdGUtdHJhY2tpbmcgY2hhcmFjdGVyXG4gICAgICAvLyB0aGF0IHdhc24ndCBjb25zdW1lZCBieSB0aGlzIHBhc3MuXG4gICAgICBzd2l0Y2ggKHN0YXRlQ2hhcikge1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICByZSArPSBzdGFyXG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIHJlICs9IHFtYXJrXG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgc3RhdGVDaGFyXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBzZWxmLmRlYnVnKCdjbGVhclN0YXRlQ2hhciAlaiAlaicsIHN0YXRlQ2hhciwgcmUpXG4gICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aCwgY1xuICAgIDsgKGkgPCBsZW4pICYmIChjID0gcGF0dGVybi5jaGFyQXQoaSkpXG4gICAgOyBpKyspIHtcbiAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAvLyBza2lwIG92ZXIgYW55IHRoYXQgYXJlIGVzY2FwZWQuXG4gICAgaWYgKGVzY2FwaW5nICYmIHJlU3BlY2lhbHNbY10pIHtcbiAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgc3dpdGNoIChjKSB7XG4gICAgICBjYXNlICcvJzpcbiAgICAgICAgLy8gY29tcGxldGVseSBub3QgYWxsb3dlZCwgZXZlbiBlc2NhcGVkLlxuICAgICAgICAvLyBTaG91bGQgYWxyZWFkeSBiZSBwYXRoLXNwbGl0IGJ5IG5vdy5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIGVzY2FwaW5nID0gdHJ1ZVxuICAgICAgY29udGludWVcblxuICAgICAgLy8gdGhlIHZhcmlvdXMgc3RhdGVDaGFyIHZhbHVlc1xuICAgICAgLy8gZm9yIHRoZSBcImV4dGdsb2JcIiBzdHVmZi5cbiAgICAgIGNhc2UgJz8nOlxuICAgICAgY2FzZSAnKic6XG4gICAgICBjYXNlICcrJzpcbiAgICAgIGNhc2UgJ0AnOlxuICAgICAgY2FzZSAnISc6XG4gICAgICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWogPC0tIHN0YXRlQ2hhcicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgICAgIC8vIGFsbCBvZiB0aG9zZSBhcmUgbGl0ZXJhbHMgaW5zaWRlIGEgY2xhc3MsIGV4Y2VwdCB0aGF0XG4gICAgICAgIC8vIHRoZSBnbG9iIFshYV0gbWVhbnMgW15hXSBpbiByZWdleHBcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKCcgIGluIGNsYXNzJylcbiAgICAgICAgICBpZiAoYyA9PT0gJyEnICYmIGkgPT09IGNsYXNzU3RhcnQgKyAxKSBjID0gJ14nXG4gICAgICAgICAgcmUgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdGF0ZUNoYXIsIHRoZW4gaXQgbWVhbnNcbiAgICAgICAgLy8gdGhhdCB0aGVyZSB3YXMgc29tZXRoaW5nIGxpa2UgKiogb3IgKz8gaW4gdGhlcmUuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc3RhdGVDaGFyLCB0aGVuIHByb2NlZWQgd2l0aCB0aGlzIG9uZS5cbiAgICAgICAgc2VsZi5kZWJ1ZygnY2FsbCBjbGVhclN0YXRlQ2hhciAlaicsIHN0YXRlQ2hhcilcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBzdGF0ZUNoYXIgPSBjXG4gICAgICAgIC8vIGlmIGV4dGdsb2IgaXMgZGlzYWJsZWQsIHRoZW4gKyhhc2RmfGZvbykgaXNuJ3QgYSB0aGluZy5cbiAgICAgICAgLy8ganVzdCBjbGVhciB0aGUgc3RhdGVjaGFyICpub3cqLCByYXRoZXIgdGhhbiBldmVuIGRpdmluZyBpbnRvXG4gICAgICAgIC8vIHRoZSBwYXR0ZXJuTGlzdCBzdHVmZi5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9leHQpIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJygnOlxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICcoJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlQ2hhcikge1xuICAgICAgICAgIHJlICs9ICdcXFxcKCdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBzdGF0ZUNoYXIsXG4gICAgICAgICAgc3RhcnQ6IGkgLSAxLFxuICAgICAgICAgIHJlU3RhcnQ6IHJlLmxlbmd0aCxcbiAgICAgICAgICBvcGVuOiBwbFR5cGVzW3N0YXRlQ2hhcl0ub3BlbixcbiAgICAgICAgICBjbG9zZTogcGxUeXBlc1tzdGF0ZUNoYXJdLmNsb3NlXG4gICAgICAgIH0pXG4gICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICByZSArPSBzdGF0ZUNoYXIgPT09ICchJyA/ICcoPzooPyEoPzonIDogJyg/OidcbiAgICAgICAgdGhpcy5kZWJ1ZygncGxUeXBlICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJyknOlxuICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGF0dGVybkxpc3RTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCknXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIHZhciBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKClcbiAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgIC8vIFRoZSBvdGhlcnMgYXJlICg/OjxwYXR0ZXJuPik8dHlwZT5cbiAgICAgICAgcmUgKz0gcGwuY2xvc2VcbiAgICAgICAgaWYgKHBsLnR5cGUgPT09ICchJykge1xuICAgICAgICAgIG5lZ2F0aXZlTGlzdHMucHVzaChwbClcbiAgICAgICAgfVxuICAgICAgICBwbC5yZUVuZCA9IHJlLmxlbmd0aFxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGlmIChpbkNsYXNzIHx8ICFwYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCB8fCBlc2NhcGluZykge1xuICAgICAgICAgIHJlICs9ICdcXFxcfCdcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgcmUgKz0gJ3wnXG4gICAgICBjb250aW51ZVxuXG4gICAgICAvLyB0aGVzZSBhcmUgbW9zdGx5IHRoZSBzYW1lIGluIHJlZ2V4cCBhbmQgZ2xvYlxuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlLXRyYWNraW5nIGNoYXIgYmVmb3JlIHRoZSBbXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaW5DbGFzcyA9IHRydWVcbiAgICAgICAgY2xhc3NTdGFydCA9IGlcbiAgICAgICAgcmVDbGFzc1N0YXJ0ID0gcmUubGVuZ3RoXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJ10nOlxuICAgICAgICAvLyAgYSByaWdodCBicmFja2V0IHNoYWxsIGxvc2UgaXRzIHNwZWNpYWxcbiAgICAgICAgLy8gIG1lYW5pbmcgYW5kIHJlcHJlc2VudCBpdHNlbGYgaW5cbiAgICAgICAgLy8gIGEgYnJhY2tldCBleHByZXNzaW9uIGlmIGl0IG9jY3Vyc1xuICAgICAgICAvLyAgZmlyc3QgaW4gdGhlIGxpc3QuICAtLSBQT1NJWC4yIDIuOC4zLjJcbiAgICAgICAgaWYgKGkgPT09IGNsYXNzU3RhcnQgKyAxIHx8ICFpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAgICAgICAvLyBcIlt6LWFdXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFt6LWFcXF1cIlxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIC8vIHNwbGl0IHdoZXJlIHRoZSBsYXN0IFsgd2FzLCBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIGFuIGludmFsaWQgcmUuIGlmIHNvLCByZS13YWxrIHRoZSBjb250ZW50cyBvZiB0aGVcbiAgICAgICAgICAvLyB3b3VsZC1iZSBjbGFzcyB0byByZS10cmFuc2xhdGUgYW55IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAgIC8vIHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXNcbiAgICAgICAgICAvLyBUT0RPOiBJdCB3b3VsZCBwcm9iYWJseSBiZSBmYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoaXNcbiAgICAgICAgICAvLyB3aXRob3V0IGEgdHJ5L2NhdGNoIGFuZCBhIG5ldyBSZWdFeHAsIGJ1dCBpdCdzIHRyaWNreVxuICAgICAgICAgIC8vIHRvIGRvIHNhZmVseS4gIEZvciBub3csIHRoaXMgaXMgc2FmZSBhbmQgd29ya3MuXG4gICAgICAgICAgdmFyIGNzID0gcGF0dGVybi5zdWJzdHJpbmcoY2xhc3NTdGFydCArIDEsIGkpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlZ0V4cCgnWycgKyBjcyArICddJylcbiAgICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgICAgLy8gbm90IGEgdmFsaWQgY2xhc3MhXG4gICAgICAgICAgICB2YXIgc3AgPSB0aGlzLnBhcnNlKGNzLCBTVUJQQVJTRSlcbiAgICAgICAgICAgIHJlID0gcmUuc3Vic3RyKDAsIHJlQ2xhc3NTdGFydCkgKyAnXFxcXFsnICsgc3BbMF0gKyAnXFxcXF0nXG4gICAgICAgICAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gICAgICAgICAgICBpbkNsYXNzID0gZmFsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluaXNoIHVwIHRoZSBjbGFzcy5cbiAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGluQ2xhc3MgPSBmYWxzZVxuICAgICAgICByZSArPSBjXG4gICAgICBjb250aW51ZVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZSBjaGFyIHRoYXQgd2Fzbid0IGNvbnN1bWVkXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICBpZiAoZXNjYXBpbmcpIHtcbiAgICAgICAgICAvLyBubyBuZWVkXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICB9IGVsc2UgaWYgKHJlU3BlY2lhbHNbY11cbiAgICAgICAgICAmJiAhKGMgPT09ICdeJyAmJiBpbkNsYXNzKSkge1xuICAgICAgICAgIHJlICs9ICdcXFxcJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmUgKz0gY1xuXG4gICAgfSAvLyBzd2l0Y2hcbiAgfSAvLyBmb3JcblxuICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgbGVmdCBhIGNsYXNzIG9wZW4uXG4gIC8vIFwiW2FiY1wiIGlzIHZhbGlkLCBlcXVpdmFsZW50IHRvIFwiXFxbYWJjXCJcbiAgaWYgKGluQ2xhc3MpIHtcbiAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgYW5kIGVzY2FwZSBpdFxuICAgIC8vIHRoaXMgaXMgYSBodWdlIHBpdGEuICBXZSBub3cgaGF2ZSB0byByZS13YWxrXG4gICAgLy8gdGhlIGNvbnRlbnRzIG9mIHRoZSB3b3VsZC1iZSBjbGFzcyB0byByZS10cmFuc2xhdGVcbiAgICAvLyBhbnkgY2hhcmFjdGVycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXNcbiAgICBjcyA9IHBhdHRlcm4uc3Vic3RyKGNsYXNzU3RhcnQgKyAxKVxuICAgIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgcmUgPSByZS5zdWJzdHIoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXVxuICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgc3BbMV1cbiAgfVxuXG4gIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBoYWQgYSArKCB0aGluZyBhdCB0aGUgKmVuZCpcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIC8vIGVhY2ggcGF0dGVybiBsaXN0IHN0YWNrIGFkZHMgMyBjaGFycywgYW5kIHdlIG5lZWQgdG8gZ28gdGhyb3VnaFxuICAvLyBhbmQgZXNjYXBlIGFueSB8IGNoYXJzIHRoYXQgd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pcyBmb3IgdGhlIHJlZ2V4cC5cbiAgLy8gR28gdGhyb3VnaCBhbmQgZXNjYXBlIHRoZW0sIHRha2luZyBjYXJlIG5vdCB0byBkb3VibGUtZXNjYXBlIGFueVxuICAvLyB8IGNoYXJzIHRoYXQgd2VyZSBhbHJlYWR5IGVzY2FwZWQuXG4gIGZvciAocGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpOyBwbDsgcGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpKSB7XG4gICAgdmFyIHRhaWwgPSByZS5zbGljZShwbC5yZVN0YXJ0ICsgcGwub3Blbi5sZW5ndGgpXG4gICAgdGhpcy5kZWJ1Zygnc2V0dGluZyB0YWlsJywgcmUsIHBsKVxuICAgIC8vIG1heWJlIHNvbWUgZXZlbiBudW1iZXIgb2YgXFwsIHRoZW4gbWF5YmUgMSBcXCwgZm9sbG93ZWQgYnkgYSB8XG4gICAgdGFpbCA9IHRhaWwucmVwbGFjZSgvKCg/OlxcXFx7Mn0pezAsNjR9KShcXFxcPylcXHwvZywgZnVuY3Rpb24gKF8sICQxLCAkMikge1xuICAgICAgaWYgKCEkMikge1xuICAgICAgICAvLyB0aGUgfCBpc24ndCBhbHJlYWR5IGVzY2FwZWQsIHNvIGVzY2FwZSBpdC5cbiAgICAgICAgJDIgPSAnXFxcXCdcbiAgICAgIH1cblxuICAgICAgLy8gbmVlZCB0byBlc2NhcGUgYWxsIHRob3NlIHNsYXNoZXMgKmFnYWluKiwgd2l0aG91dCBlc2NhcGluZyB0aGVcbiAgICAgIC8vIG9uZSB0aGF0IHdlIG5lZWQgZm9yIGVzY2FwaW5nIHRoZSB8IGNoYXJhY3Rlci4gIEFzIGl0IHdvcmtzIG91dCxcbiAgICAgIC8vIGVzY2FwaW5nIGFuIGV2ZW4gbnVtYmVyIG9mIHNsYXNoZXMgY2FuIGJlIGRvbmUgYnkgc2ltcGx5IHJlcGVhdGluZ1xuICAgICAgLy8gaXQgZXhhY3RseSBhZnRlciBpdHNlbGYuICBUaGF0J3Mgd2h5IHRoaXMgdHJpY2sgd29ya3MuXG4gICAgICAvL1xuICAgICAgLy8gSSBhbSBzb3JyeSB0aGF0IHlvdSBoYXZlIHRvIHNlZSB0aGlzLlxuICAgICAgcmV0dXJuICQxICsgJDEgKyAkMiArICd8J1xuICAgIH0pXG5cbiAgICB0aGlzLmRlYnVnKCd0YWlsPSVqXFxuICAgJXMnLCB0YWlsLCB0YWlsLCBwbCwgcmUpXG4gICAgdmFyIHQgPSBwbC50eXBlID09PSAnKicgPyBzdGFyXG4gICAgICA6IHBsLnR5cGUgPT09ICc/JyA/IHFtYXJrXG4gICAgICA6ICdcXFxcJyArIHBsLnR5cGVcblxuICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgIHJlID0gcmUuc2xpY2UoMCwgcGwucmVTdGFydCkgKyB0ICsgJ1xcXFwoJyArIHRhaWxcbiAgfVxuXG4gIC8vIGhhbmRsZSB0cmFpbGluZyB0aGluZ3MgdGhhdCBvbmx5IG1hdHRlciBhdCB0aGUgdmVyeSBlbmQuXG4gIGNsZWFyU3RhdGVDaGFyKClcbiAgaWYgKGVzY2FwaW5nKSB7XG4gICAgLy8gdHJhaWxpbmcgXFxcXFxuICAgIHJlICs9ICdcXFxcXFxcXCdcbiAgfVxuXG4gIC8vIG9ubHkgbmVlZCB0byBhcHBseSB0aGUgbm9kb3Qgc3RhcnQgaWYgdGhlIHJlIHN0YXJ0cyB3aXRoXG4gIC8vIHNvbWV0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGNhcHR1cmUgYSBkb3RcbiAgdmFyIGFkZFBhdHRlcm5TdGFydCA9IGZhbHNlXG4gIHN3aXRjaCAocmUuY2hhckF0KDApKSB7XG4gICAgY2FzZSAnLic6XG4gICAgY2FzZSAnWyc6XG4gICAgY2FzZSAnKCc6IGFkZFBhdHRlcm5TdGFydCA9IHRydWVcbiAgfVxuXG4gIC8vIEhhY2sgdG8gd29yayBhcm91bmQgbGFjayBvZiBuZWdhdGl2ZSBsb29rYmVoaW5kIGluIEpTXG4gIC8vIEEgcGF0dGVybiBsaWtlOiAqLiEoeCkuISh5fHopIG5lZWRzIHRvIGVuc3VyZSB0aGF0IGEgbmFtZVxuICAvLyBsaWtlICdhLnh5ei55eicgZG9lc24ndCBtYXRjaC4gIFNvLCB0aGUgZmlyc3QgbmVnYXRpdmVcbiAgLy8gbG9va2FoZWFkLCBoYXMgdG8gbG9vayBBTEwgdGhlIHdheSBhaGVhZCwgdG8gdGhlIGVuZCBvZlxuICAvLyB0aGUgcGF0dGVybi5cbiAgZm9yICh2YXIgbiA9IG5lZ2F0aXZlTGlzdHMubGVuZ3RoIC0gMTsgbiA+IC0xOyBuLS0pIHtcbiAgICB2YXIgbmwgPSBuZWdhdGl2ZUxpc3RzW25dXG5cbiAgICB2YXIgbmxCZWZvcmUgPSByZS5zbGljZSgwLCBubC5yZVN0YXJ0KVxuICAgIHZhciBubEZpcnN0ID0gcmUuc2xpY2UobmwucmVTdGFydCwgbmwucmVFbmQgLSA4KVxuICAgIHZhciBubExhc3QgPSByZS5zbGljZShubC5yZUVuZCAtIDgsIG5sLnJlRW5kKVxuICAgIHZhciBubEFmdGVyID0gcmUuc2xpY2UobmwucmVFbmQpXG5cbiAgICBubExhc3QgKz0gbmxBZnRlclxuXG4gICAgLy8gSGFuZGxlIG5lc3RlZCBzdHVmZiBsaWtlICooKi5qc3whKCouanNvbikpLCB3aGVyZSBvcGVuIHBhcmVuc1xuICAgIC8vIG1lYW4gdGhhdCB3ZSBzaG91bGQgKm5vdCogaW5jbHVkZSB0aGUgKSBpbiB0aGUgYml0IHRoYXQgaXMgY29uc2lkZXJlZFxuICAgIC8vIFwiYWZ0ZXJcIiB0aGUgbmVnYXRlZCBzZWN0aW9uLlxuICAgIHZhciBvcGVuUGFyZW5zQmVmb3JlID0gbmxCZWZvcmUuc3BsaXQoJygnKS5sZW5ndGggLSAxXG4gICAgdmFyIGNsZWFuQWZ0ZXIgPSBubEFmdGVyXG4gICAgZm9yIChpID0gMDsgaSA8IG9wZW5QYXJlbnNCZWZvcmU7IGkrKykge1xuICAgICAgY2xlYW5BZnRlciA9IGNsZWFuQWZ0ZXIucmVwbGFjZSgvXFwpWysqP10/LywgJycpXG4gICAgfVxuICAgIG5sQWZ0ZXIgPSBjbGVhbkFmdGVyXG5cbiAgICB2YXIgZG9sbGFyID0gJydcbiAgICBpZiAobmxBZnRlciA9PT0gJycgJiYgaXNTdWIgIT09IFNVQlBBUlNFKSB7XG4gICAgICBkb2xsYXIgPSAnJCdcbiAgICB9XG4gICAgdmFyIG5ld1JlID0gbmxCZWZvcmUgKyBubEZpcnN0ICsgbmxBZnRlciArIGRvbGxhciArIG5sTGFzdFxuICAgIHJlID0gbmV3UmVcbiAgfVxuXG4gIC8vIGlmIHRoZSByZSBpcyBub3QgXCJcIiBhdCB0aGlzIHBvaW50LCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gIC8vIGl0IGRvZXNuJ3QgbWF0Y2ggYWdhaW5zdCBhbiBlbXB0eSBwYXRoIHBhcnQuXG4gIC8vIE90aGVyd2lzZSBhLyogd2lsbCBtYXRjaCBhLywgd2hpY2ggaXQgc2hvdWxkIG5vdC5cbiAgaWYgKHJlICE9PSAnJyAmJiBoYXNNYWdpYykge1xuICAgIHJlID0gJyg/PS4pJyArIHJlXG4gIH1cblxuICBpZiAoYWRkUGF0dGVyblN0YXJ0KSB7XG4gICAgcmUgPSBwYXR0ZXJuU3RhcnQgKyByZVxuICB9XG5cbiAgLy8gcGFyc2luZyBqdXN0IGEgcGllY2Ugb2YgYSBsYXJnZXIgcGF0dGVybi5cbiAgaWYgKGlzU3ViID09PSBTVUJQQVJTRSkge1xuICAgIHJldHVybiBbcmUsIGhhc01hZ2ljXVxuICB9XG5cbiAgLy8gc2tpcCB0aGUgcmVnZXhwIGZvciBub24tbWFnaWNhbCBwYXR0ZXJuc1xuICAvLyB1bmVzY2FwZSBhbnl0aGluZyBpbiBpdCwgdGhvdWdoLCBzbyB0aGF0IGl0J2xsIGJlXG4gIC8vIGFuIGV4YWN0IG1hdGNoIGFnYWluc3QgYSBmaWxlIGV0Yy5cbiAgaWYgKCFoYXNNYWdpYykge1xuICAgIHJldHVybiBnbG9iVW5lc2NhcGUocGF0dGVybilcbiAgfVxuXG4gIHZhciBmbGFncyA9IG9wdGlvbnMubm9jYXNlID8gJ2knIDogJydcbiAgdHJ5IHtcbiAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cCgnXicgKyByZSArICckJywgZmxhZ3MpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgLy8gSWYgaXQgd2FzIGFuIGludmFsaWQgcmVndWxhciBleHByZXNzaW9uLCB0aGVuIGl0IGNhbid0IG1hdGNoXG4gICAgLy8gYW55dGhpbmcuICBUaGlzIHRyaWNrIGxvb2tzIGZvciBhIGNoYXJhY3RlciBhZnRlciB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHN0cmluZywgd2hpY2ggaXMgb2YgY291cnNlIGltcG9zc2libGUsIGV4Y2VwdCBpbiBtdWx0aS1saW5lXG4gICAgLy8gbW9kZSwgYnV0IGl0J3Mgbm90IGEgL20gcmVnZXguXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJyQuJylcbiAgfVxuXG4gIHJlZ0V4cC5fZ2xvYiA9IHBhdHRlcm5cbiAgcmVnRXhwLl9zcmMgPSByZVxuXG4gIHJldHVybiByZWdFeHBcbn1cblxubWluaW1hdGNoLm1ha2VSZSA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMgfHwge30pLm1ha2VSZSgpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUubWFrZVJlID0gbWFrZVJlXG5mdW5jdGlvbiBtYWtlUmUgKCkge1xuICBpZiAodGhpcy5yZWdleHAgfHwgdGhpcy5yZWdleHAgPT09IGZhbHNlKSByZXR1cm4gdGhpcy5yZWdleHBcblxuICAvLyBhdCB0aGlzIHBvaW50LCB0aGlzLnNldCBpcyBhIDJkIGFycmF5IG9mIHBhcnRpYWxcbiAgLy8gcGF0dGVybiBzdHJpbmdzLCBvciBcIioqXCIuXG4gIC8vXG4gIC8vIEl0J3MgYmV0dGVyIHRvIHVzZSAubWF0Y2goKS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkbid0XG4gIC8vIGJlIHVzZWQsIHJlYWxseSwgYnV0IGl0J3MgcHJldHR5IGNvbnZlbmllbnQgc29tZXRpbWVzLFxuICAvLyB3aGVuIHlvdSBqdXN0IHdhbnQgdG8gd29yayB3aXRoIGEgcmVnZXguXG4gIHZhciBzZXQgPSB0aGlzLnNldFxuXG4gIGlmICghc2V0Lmxlbmd0aCkge1xuICAgIHRoaXMucmVnZXhwID0gZmFsc2VcbiAgICByZXR1cm4gdGhpcy5yZWdleHBcbiAgfVxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIHZhciB0d29TdGFyID0gb3B0aW9ucy5ub2dsb2JzdGFyID8gc3RhclxuICAgIDogb3B0aW9ucy5kb3QgPyB0d29TdGFyRG90XG4gICAgOiB0d29TdGFyTm9Eb3RcbiAgdmFyIGZsYWdzID0gb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJ1xuXG4gIHZhciByZSA9IHNldC5tYXAoZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gcGF0dGVybi5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAocCA9PT0gR0xPQlNUQVIpID8gdHdvU3RhclxuICAgICAgOiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSA/IHJlZ0V4cEVzY2FwZShwKVxuICAgICAgOiBwLl9zcmNcbiAgICB9KS5qb2luKCdcXFxcXFwvJylcbiAgfSkuam9pbignfCcpXG5cbiAgLy8gbXVzdCBtYXRjaCBlbnRpcmUgcGF0dGVyblxuICAvLyBlbmRpbmcgaW4gYSAqIG9yICoqIHdpbGwgbWFrZSBpdCBsZXNzIHN0cmljdC5cbiAgcmUgPSAnXig/OicgKyByZSArICcpJCdcblxuICAvLyBjYW4gbWF0Y2ggYW55dGhpbmcsIGFzIGxvbmcgYXMgaXQncyBub3QgdGhpcy5cbiAgaWYgKHRoaXMubmVnYXRlKSByZSA9ICdeKD8hJyArIHJlICsgJykuKiQnXG5cbiAgdHJ5IHtcbiAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmUsIGZsYWdzKVxuICB9IGNhdGNoIChleCkge1xuICAgIHRoaXMucmVnZXhwID0gZmFsc2VcbiAgfVxuICByZXR1cm4gdGhpcy5yZWdleHBcbn1cblxubWluaW1hdGNoLm1hdGNoID0gZnVuY3Rpb24gKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIG1tID0gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKVxuICBsaXN0ID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gbW0ubWF0Y2goZilcbiAgfSlcbiAgaWYgKG1tLm9wdGlvbnMubm9udWxsICYmICFsaXN0Lmxlbmd0aCkge1xuICAgIGxpc3QucHVzaChwYXR0ZXJuKVxuICB9XG4gIHJldHVybiBsaXN0XG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUubWF0Y2ggPSBtYXRjaFxuZnVuY3Rpb24gbWF0Y2ggKGYsIHBhcnRpYWwpIHtcbiAgdGhpcy5kZWJ1ZygnbWF0Y2gnLCBmLCB0aGlzLnBhdHRlcm4pXG4gIC8vIHNob3J0LWNpcmN1aXQgaW4gdGhlIGNhc2Ugb2YgYnVzdGVkIHRoaW5ncy5cbiAgLy8gY29tbWVudHMsIGV0Yy5cbiAgaWYgKHRoaXMuY29tbWVudCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0aGlzLmVtcHR5KSByZXR1cm4gZiA9PT0gJydcblxuICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHJldHVybiB0cnVlXG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyB3aW5kb3dzOiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKHBhdGguc2VwICE9PSAnLycpIHtcbiAgICBmID0gZi5zcGxpdChwYXRoLnNlcCkuam9pbignLycpXG4gIH1cblxuICAvLyB0cmVhdCB0aGUgdGVzdCBwYXRoIGFzIGEgc2V0IG9mIHBhdGhwYXJ0cy5cbiAgZiA9IGYuc3BsaXQoc2xhc2hTcGxpdClcbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGYpXG5cbiAgLy8ganVzdCBPTkUgb2YgdGhlIHBhdHRlcm4gc2V0cyBpbiB0aGlzLnNldCBuZWVkcyB0byBtYXRjaFxuICAvLyBpbiBvcmRlciBmb3IgaXQgdG8gYmUgdmFsaWQuICBJZiBuZWdhdGluZywgdGhlbiBqdXN0IG9uZVxuICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAvLyBFaXRoZXIgd2F5LCByZXR1cm4gb24gdGhlIGZpcnN0IGhpdC5cblxuICB2YXIgc2V0ID0gdGhpcy5zZXRcbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzZXQnLCBzZXQpXG5cbiAgLy8gRmluZCB0aGUgYmFzZW5hbWUgb2YgdGhlIHBhdGggYnkgbG9va2luZyBmb3IgdGhlIGxhc3Qgbm9uLWVtcHR5IHNlZ21lbnRcbiAgdmFyIGZpbGVuYW1lXG4gIHZhciBpXG4gIGZvciAoaSA9IGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBmaWxlbmFtZSA9IGZbaV1cbiAgICBpZiAoZmlsZW5hbWUpIGJyZWFrXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBzZXRbaV1cbiAgICB2YXIgZmlsZSA9IGZcbiAgICBpZiAob3B0aW9ucy5tYXRjaEJhc2UgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZpbGUgPSBbZmlsZW5hbWVdXG4gICAgfVxuICAgIHZhciBoaXQgPSB0aGlzLm1hdGNoT25lKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpXG4gICAgaWYgKGhpdCkge1xuICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiAhdGhpcy5uZWdhdGVcbiAgICB9XG4gIH1cblxuICAvLyBkaWRuJ3QgZ2V0IGFueSBoaXRzLiAgdGhpcyBpcyBzdWNjZXNzIGlmIGl0J3MgYSBuZWdhdGl2ZVxuICAvLyBwYXR0ZXJuLCBmYWlsdXJlIG90aGVyd2lzZS5cbiAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiB0aGlzLm5lZ2F0ZVxufVxuXG4vLyBzZXQgcGFydGlhbCB0byB0cnVlIHRvIHRlc3QgaWYsIGZvciBleGFtcGxlLFxuLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4vLyBQYXJ0aWFsIG1lYW5zLCBpZiB5b3UgcnVuIG91dCBvZiBmaWxlIGJlZm9yZSB5b3UgcnVuXG4vLyBvdXQgb2YgcGF0dGVybiwgdGhlbiB0aGF0J3MgZmluZSwgYXMgbG9uZyBhcyBhbGxcbi8vIHRoZSBwYXJ0cyBtYXRjaC5cbk1pbmltYXRjaC5wcm90b3R5cGUubWF0Y2hPbmUgPSBmdW5jdGlvbiAoZmlsZSwgcGF0dGVybiwgcGFydGlhbCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIHRoaXMuZGVidWcoJ21hdGNoT25lJyxcbiAgICB7ICd0aGlzJzogdGhpcywgZmlsZTogZmlsZSwgcGF0dGVybjogcGF0dGVybiB9KVxuXG4gIHRoaXMuZGVidWcoJ21hdGNoT25lJywgZmlsZS5sZW5ndGgsIHBhdHRlcm4ubGVuZ3RoKVxuXG4gIGZvciAodmFyIGZpID0gMCxcbiAgICAgIHBpID0gMCxcbiAgICAgIGZsID0gZmlsZS5sZW5ndGgsXG4gICAgICBwbCA9IHBhdHRlcm4ubGVuZ3RoXG4gICAgICA7IChmaSA8IGZsKSAmJiAocGkgPCBwbClcbiAgICAgIDsgZmkrKywgcGkrKykge1xuICAgIHRoaXMuZGVidWcoJ21hdGNoT25lIGxvb3AnKVxuICAgIHZhciBwID0gcGF0dGVybltwaV1cbiAgICB2YXIgZiA9IGZpbGVbZmldXG5cbiAgICB0aGlzLmRlYnVnKHBhdHRlcm4sIHAsIGYpXG5cbiAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAvLyBzb21lIGludmFsaWQgcmVnZXhwIHN0dWZmIGluIHRoZSBzZXQuXG4gICAgaWYgKHAgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcblxuICAgIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgdGhpcy5kZWJ1ZygnR0xPQlNUQVInLCBbcGF0dGVybiwgcCwgZl0pXG5cbiAgICAgIC8vIFwiKipcIlxuICAgICAgLy8gYS8qKi9iLyoqL2Mgd291bGQgbWF0Y2ggdGhlIGZvbGxvd2luZzpcbiAgICAgIC8vIGEvYi94L3kvei9jXG4gICAgICAvLyBhL3gveS96L2IvY1xuICAgICAgLy8gYS9iL3gvYi94L2NcbiAgICAgIC8vIGEvYi9jXG4gICAgICAvLyBUbyBkbyB0aGlzLCB0YWtlIHRoZSByZXN0IG9mIHRoZSBwYXR0ZXJuIGFmdGVyXG4gICAgICAvLyB0aGUgKiosIGFuZCBzZWUgaWYgaXQgd291bGQgbWF0Y2ggdGhlIGZpbGUgcmVtYWluZGVyLlxuICAgICAgLy8gSWYgc28sIHJldHVybiBzdWNjZXNzLlxuICAgICAgLy8gSWYgbm90LCB0aGUgKiogXCJzd2FsbG93c1wiIGEgc2VnbWVudCwgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgIC8vIFRoaXMgaXMgcmVjdXJzaXZlbHkgYXdmdWwuXG4gICAgICAvL1xuICAgICAgLy8gYS8qKi9iLyoqL2MgbWF0Y2hpbmcgYS9iL3gveS96L2NcbiAgICAgIC8vIC0gYSBtYXRjaGVzIGFcbiAgICAgIC8vIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAtIG1hdGNoT25lKGIveC95L3ovYywgYi8qKi9jKVxuICAgICAgLy8gICAgIC0gYiBtYXRjaGVzIGJcbiAgICAgIC8vICAgICAtIGRvdWJsZXN0YXJcbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeC95L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeS96L2MsIGMpIC0+IG5vXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKHovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoYywgYykgeWVzLCBoaXRcbiAgICAgIHZhciBmciA9IGZpXG4gICAgICB2YXIgcHIgPSBwaSArIDFcbiAgICAgIGlmIChwciA9PT0gcGwpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZygnKiogYXQgdGhlIGVuZCcpXG4gICAgICAgIC8vIGEgKiogYXQgdGhlIGVuZCB3aWxsIGp1c3Qgc3dhbGxvdyB0aGUgcmVzdC5cbiAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAvLyBob3dldmVyLCBpdCB3aWxsIG5vdCBzd2FsbG93IC8ueCwgdW5sZXNzXG4gICAgICAgIC8vIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgICAgICAgLy8gLiBhbmQgLi4gYXJlICpuZXZlciogbWF0Y2hlZCBieSAqKiwgZm9yIGV4cGxvc2l2ZWx5XG4gICAgICAgIC8vIGV4cG9uZW50aWFsIHJlYXNvbnMuXG4gICAgICAgIGZvciAoOyBmaSA8IGZsOyBmaSsrKSB7XG4gICAgICAgICAgaWYgKGZpbGVbZmldID09PSAnLicgfHwgZmlsZVtmaV0gPT09ICcuLicgfHxcbiAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgZmlsZVtmaV0uY2hhckF0KDApID09PSAnLicpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICAvLyBvaywgbGV0J3Mgc2VlIGlmIHdlIGNhbiBzd2FsbG93IHdoYXRldmVyIHdlIGNhbi5cbiAgICAgIHdoaWxlIChmciA8IGZsKSB7XG4gICAgICAgIHZhciBzd2FsbG93ZWUgPSBmaWxlW2ZyXVxuXG4gICAgICAgIHRoaXMuZGVidWcoJ1xcbmdsb2JzdGFyIHdoaWxlJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByLCBzd2FsbG93ZWUpXG5cbiAgICAgICAgLy8gWFhYIHJlbW92ZSB0aGlzIHNsaWNlLiAgSnVzdCBwYXNzIHRoZSBzdGFydCBpbmRleC5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2hPbmUoZmlsZS5zbGljZShmciksIHBhdHRlcm4uc2xpY2UocHIpLCBwYXJ0aWFsKSkge1xuICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIGZvdW5kIG1hdGNoIScsIGZyLCBmbCwgc3dhbGxvd2VlKVxuICAgICAgICAgIC8vIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjYW4ndCBzd2FsbG93IFwiLlwiIG9yIFwiLi5cIiBldmVyLlxuICAgICAgICAgIC8vIGNhbiBvbmx5IHN3YWxsb3cgXCIuZm9vXCIgd2hlbiBleHBsaWNpdGx5IGFza2VkLlxuICAgICAgICAgIGlmIChzd2FsbG93ZWUgPT09ICcuJyB8fCBzd2FsbG93ZWUgPT09ICcuLicgfHxcbiAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgc3dhbGxvd2VlLmNoYXJBdCgwKSA9PT0gJy4nKSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZG90IGRldGVjdGVkIScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gKiogc3dhbGxvd3MgYSBzZWdtZW50LCBhbmQgY29udGludWUuXG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgc3dhbGxvdyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZScpXG4gICAgICAgICAgZnIrK1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIG1hdGNoIHdhcyBmb3VuZC5cbiAgICAgIC8vIEhvd2V2ZXIsIGluIHBhcnRpYWwgbW9kZSwgd2UgY2FuJ3Qgc2F5IHRoaXMgaXMgbmVjZXNzYXJpbHkgb3Zlci5cbiAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSAqcGF0dGVybiogbGVmdCwgdGhlblxuICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgLy8gcmFuIG91dCBvZiBmaWxlXG4gICAgICAgIHRoaXMuZGVidWcoJ1xcbj4+PiBubyBtYXRjaCwgcGFydGlhbD8nLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpXG4gICAgICAgIGlmIChmciA9PT0gZmwpIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBzb21ldGhpbmcgb3RoZXIgdGhhbiAqKlxuICAgIC8vIG5vbi1tYWdpYyBwYXR0ZXJucyBqdXN0IGhhdmUgdG8gbWF0Y2ggZXhhY3RseVxuICAgIC8vIHBhdHRlcm5zIHdpdGggbWFnaWMgaGF2ZSBiZWVuIHR1cm5lZCBpbnRvIHJlZ2V4cHMuXG4gICAgdmFyIGhpdFxuICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChvcHRpb25zLm5vY2FzZSkge1xuICAgICAgICBoaXQgPSBmLnRvTG93ZXJDYXNlKCkgPT09IHAudG9Mb3dlckNhc2UoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGl0ID0gZiA9PT0gcFxuICAgICAgfVxuICAgICAgdGhpcy5kZWJ1Zygnc3RyaW5nIG1hdGNoJywgcCwgZiwgaGl0KVxuICAgIH0gZWxzZSB7XG4gICAgICBoaXQgPSBmLm1hdGNoKHApXG4gICAgICB0aGlzLmRlYnVnKCdwYXR0ZXJuIG1hdGNoJywgcCwgZiwgaGl0KVxuICAgIH1cblxuICAgIGlmICghaGl0KSByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIE5vdGU6IGVuZGluZyBpbiAvIG1lYW5zIHRoYXQgd2UnbGwgZ2V0IGEgZmluYWwgXCJcIlxuICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLiAgVGhpcyBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGNvcnJlc3BvbmRpbmcgXCJcIiBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICAvLyBJZiB0aGUgZmlsZSBlbmRzIGluIC8sIHRoZW4gaXQgY2FuIG9ubHkgbWF0Y2ggYVxuICAvLyBhIHBhdHRlcm4gdGhhdCBlbmRzIGluIC8sIHVubGVzcyB0aGUgcGF0dGVybiBqdXN0XG4gIC8vIGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBmb3IgaXQuIEJ1dCwgYS9iLyBzaG91bGQgKm5vdCpcbiAgLy8gbWF0Y2ggXCJhL2IvKlwiLCBldmVuIHRob3VnaCBcIlwiIG1hdGNoZXMgYWdhaW5zdCB0aGVcbiAgLy8gW14vXSo/IHBhdHRlcm4sIGV4Y2VwdCBpbiBwYXJ0aWFsIG1vZGUsIHdoZXJlIGl0IG1pZ2h0XG4gIC8vIHNpbXBseSBub3QgYmUgcmVhY2hlZCB5ZXQuXG4gIC8vIEhvd2V2ZXIsIGEvYi8gc2hvdWxkIHN0aWxsIHNhdGlzZnkgYS8qXG5cbiAgLy8gbm93IGVpdGhlciB3ZSBmZWxsIG9mZiB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLCBvciB3ZSdyZSBkb25lLlxuICBpZiAoZmkgPT09IGZsICYmIHBpID09PSBwbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiBhbmQgZmlsZW5hbWUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyBhbiBleGFjdCBoaXQhXG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChmaSA9PT0gZmwpIHtcbiAgICAvLyByYW4gb3V0IG9mIGZpbGUsIGJ1dCBzdGlsbCBoYWQgcGF0dGVybiBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb2sgaWYgd2UncmUgZG9pbmcgdGhlIG1hdGNoIGFzIHBhcnQgb2ZcbiAgICAvLyBhIGdsb2IgZnMgdHJhdmVyc2FsLlxuICAgIHJldHVybiBwYXJ0aWFsXG4gIH0gZWxzZSBpZiAocGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuLCBzdGlsbCBoYXZlIGZpbGUgbGVmdC5cbiAgICAvLyB0aGlzIGlzIG9ubHkgYWNjZXB0YWJsZSBpZiB3ZSdyZSBvbiB0aGUgdmVyeSBsYXN0XG4gICAgLy8gZW1wdHkgc2VnbWVudCBvZiBhIGZpbGUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgIC8vIGEvKiBzaG91bGQgbWF0Y2ggYS9iL1xuICAgIHZhciBlbXB0eUZpbGVFbmQgPSAoZmkgPT09IGZsIC0gMSkgJiYgKGZpbGVbZmldID09PSAnJylcbiAgICByZXR1cm4gZW1wdHlGaWxlRW5kXG4gIH1cblxuICAvLyBzaG91bGQgYmUgdW5yZWFjaGFibGUuXG4gIHRocm93IG5ldyBFcnJvcignd3RmPycpXG59XG5cbi8vIHJlcGxhY2Ugc3R1ZmYgbGlrZSBcXCogd2l0aCAqXG5mdW5jdGlvbiBnbG9iVW5lc2NhcGUgKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvXFxcXCguKS9nLCAnJDEnKVxufVxuXG5mdW5jdGlvbiByZWdFeHBFc2NhcGUgKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL3Byb2Nlc3MvYnJvd3Nlci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbW1hbmRzIHN5bmMgcmVjdXJzaXZlIF5cXFxcLlxcXFwvLiokXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tbWFuZHMgc3luYyBeXFwuXFwvLiokICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG1hcCA9IHtcblx0XCIuL1wiOiBcIi4vc3JjL2NvbW1hbmRzL2luZGV4LmpzXCIsXG5cdFwiLi9jYXRcIjogXCIuL3NyYy9jb21tYW5kcy9jYXQuanNcIixcblx0XCIuL2NhdC5qc1wiOiBcIi4vc3JjL2NvbW1hbmRzL2NhdC5qc1wiLFxuXHRcIi4vY2RcIjogXCIuL3NyYy9jb21tYW5kcy9jZC5qc1wiLFxuXHRcIi4vY2QuanNcIjogXCIuL3NyYy9jb21tYW5kcy9jZC5qc1wiLFxuXHRcIi4vY2xlYXJcIjogXCIuL3NyYy9jb21tYW5kcy9jbGVhci5qc1wiLFxuXHRcIi4vY2xlYXIuanNcIjogXCIuL3NyYy9jb21tYW5kcy9jbGVhci5qc1wiLFxuXHRcIi4vY3BcIjogXCIuL3NyYy9jb21tYW5kcy9jcC5qc1wiLFxuXHRcIi4vY3AuanNcIjogXCIuL3NyYy9jb21tYW5kcy9jcC5qc1wiLFxuXHRcIi4vZWNob1wiOiBcIi4vc3JjL2NvbW1hbmRzL2VjaG8uanNcIixcblx0XCIuL2VjaG8uanNcIjogXCIuL3NyYy9jb21tYW5kcy9lY2hvLmpzXCIsXG5cdFwiLi9oZWFkXCI6IFwiLi9zcmMvY29tbWFuZHMvaGVhZC5qc1wiLFxuXHRcIi4vaGVhZC5qc1wiOiBcIi4vc3JjL2NvbW1hbmRzL2hlYWQuanNcIixcblx0XCIuL2hpc3RvcnlcIjogXCIuL3NyYy9jb21tYW5kcy9oaXN0b3J5LmpzXCIsXG5cdFwiLi9oaXN0b3J5LmpzXCI6IFwiLi9zcmMvY29tbWFuZHMvaGlzdG9yeS5qc1wiLFxuXHRcIi4vaW5kZXhcIjogXCIuL3NyYy9jb21tYW5kcy9pbmRleC5qc1wiLFxuXHRcIi4vaW5kZXguanNcIjogXCIuL3NyYy9jb21tYW5kcy9pbmRleC5qc1wiLFxuXHRcIi4vbHNcIjogXCIuL3NyYy9jb21tYW5kcy9scy5qc1wiLFxuXHRcIi4vbHMuanNcIjogXCIuL3NyYy9jb21tYW5kcy9scy5qc1wiLFxuXHRcIi4vbWtkaXJcIjogXCIuL3NyYy9jb21tYW5kcy9ta2Rpci5qc1wiLFxuXHRcIi4vbWtkaXIuanNcIjogXCIuL3NyYy9jb21tYW5kcy9ta2Rpci5qc1wiLFxuXHRcIi4vcHJpbnRlbnZcIjogXCIuL3NyYy9jb21tYW5kcy9wcmludGVudi5qc1wiLFxuXHRcIi4vcHJpbnRlbnYuanNcIjogXCIuL3NyYy9jb21tYW5kcy9wcmludGVudi5qc1wiLFxuXHRcIi4vcHdkXCI6IFwiLi9zcmMvY29tbWFuZHMvcHdkLmpzXCIsXG5cdFwiLi9wd2QuanNcIjogXCIuL3NyYy9jb21tYW5kcy9wd2QuanNcIixcblx0XCIuL3JtXCI6IFwiLi9zcmMvY29tbWFuZHMvcm0uanNcIixcblx0XCIuL3JtLmpzXCI6IFwiLi9zcmMvY29tbWFuZHMvcm0uanNcIixcblx0XCIuL3JtZGlyXCI6IFwiLi9zcmMvY29tbWFuZHMvcm1kaXIuanNcIixcblx0XCIuL3JtZGlyLmpzXCI6IFwiLi9zcmMvY29tbWFuZHMvcm1kaXIuanNcIixcblx0XCIuL3RhaWxcIjogXCIuL3NyYy9jb21tYW5kcy90YWlsLmpzXCIsXG5cdFwiLi90YWlsLmpzXCI6IFwiLi9zcmMvY29tbWFuZHMvdGFpbC5qc1wiLFxuXHRcIi4vdG91Y2hcIjogXCIuL3NyYy9jb21tYW5kcy90b3VjaC5qc1wiLFxuXHRcIi4vdG91Y2guanNcIjogXCIuL3NyYy9jb21tYW5kcy90b3VjaC5qc1wiLFxuXHRcIi4vdXRpbC9faGVhZF90YWlsX3V0aWxcIjogXCIuL3NyYy9jb21tYW5kcy91dGlsL19oZWFkX3RhaWxfdXRpbC5qc1wiLFxuXHRcIi4vdXRpbC9faGVhZF90YWlsX3V0aWwuanNcIjogXCIuL3NyYy9jb21tYW5kcy91dGlsL19oZWFkX3RhaWxfdXRpbC5qc1wiLFxuXHRcIi4vd2hvYW1pXCI6IFwiLi9zcmMvY29tbWFuZHMvd2hvYW1pLmpzXCIsXG5cdFwiLi93aG9hbWkuanNcIjogXCIuL3NyYy9jb21tYW5kcy93aG9hbWkuanNcIlxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IFwiLi9zcmMvY29tbWFuZHMgc3luYyByZWN1cnNpdmUgXlxcXFwuXFxcXC8uKiRcIjtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tbWFuZHMvY2F0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tYW5kcy9jYXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5vcHREZWYgPSB2b2lkIDA7XG5cbnZhciBfb3B0aW9uUGFyc2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBwYXJzZXIvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3BhcnNlci9vcHRpb24tcGFyc2VyLmpzXCIpKTtcblxudmFyIEZpbGVPcCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMtd2l0aC1wZXJtaXNzaW9ucy9maWxlLW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZmlsZS1vcGVyYXRpb25zLmpzXCIpKTtcblxudmFyIE91dHB1dEZhY3RvcnkgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1vdXRwdXQvb3V0cHV0LWZhY3RvcnkgKi8gXCIuL3NyYy9lbXVsYXRvci1vdXRwdXQvb3V0cHV0LWZhY3RvcnkuanNcIikpO1xuXG52YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS91dGlsICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvdXRpbC5qc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogQ29tYmluZXMgb25lIG9yIG1vcmUgZmlsZXMgdG8gZGlzcGxheSBpbiB0aGUgdGVybWluYWwgb3V0cHV0XG4gKiBVc2FnZTogY2F0IGZpbGUxLnR4dCBmaWxlMi50eHRcbiAqL1xudmFyIGZpbGVUb1RleHRPdXRwdXQgPSBmdW5jdGlvbiBmaWxlVG9UZXh0T3V0cHV0KGZzLCBmaWxlUGF0aCkge1xuICB2YXIgX0ZpbGVPcCRyZWFkRmlsZSA9IEZpbGVPcC5yZWFkRmlsZShmcywgZmlsZVBhdGgpLFxuICAgICAgZXJyID0gX0ZpbGVPcCRyZWFkRmlsZS5lcnIsXG4gICAgICBmaWxlID0gX0ZpbGVPcCRyZWFkRmlsZS5maWxlO1xuXG4gIGlmIChlcnIpIHtcbiAgICByZXR1cm4gT3V0cHV0RmFjdG9yeS5tYWtlRXJyb3JPdXRwdXQoZXJyKTtcbiAgfVxuXG4gIDtcbiAgcmV0dXJuIE91dHB1dEZhY3RvcnkubWFrZVRleHRPdXRwdXQoZmlsZS5nZXQoJ2NvbnRlbnQnKSk7XG59O1xuXG52YXIgb3B0RGVmID0ge307XG5leHBvcnRzLm9wdERlZiA9IG9wdERlZjtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoc3RhdGUsIGNvbW1hbmRPcHRpb25zKSB7XG4gIHZhciBfcGFyc2VPcHRpb25zID0gKDAsIF9vcHRpb25QYXJzZXJbXCJkZWZhdWx0XCJdKShjb21tYW5kT3B0aW9ucywgb3B0RGVmKSxcbiAgICAgIGFyZ3YgPSBfcGFyc2VPcHRpb25zLmFyZ3Y7XG5cbiAgaWYgKGFyZ3YubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIGZpbGVQYXRocyA9IGFyZ3YubWFwKGZ1bmN0aW9uIChwYXRoQXJnKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5yZXNvbHZlUGF0aCkoc3RhdGUsIHBhdGhBcmcpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvdXRwdXRzOiBmaWxlUGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gZmlsZVRvVGV4dE91dHB1dChzdGF0ZS5nZXRGaWxlU3lzdGVtKCksIHBhdGgpO1xuICAgIH0pXG4gIH07XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21tYW5kcy9jZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tYW5kcy9jZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMub3B0RGVmID0gdm9pZCAwO1xuXG52YXIgX29wdGlvblBhcnNlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcGFyc2VyL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy9wYXJzZXIvb3B0aW9uLXBhcnNlci5qc1wiKSk7XG5cbnZhciBEaXJlY3RvcnlPcCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMtd2l0aC1wZXJtaXNzaW9ucy9kaXJlY3Rvcnktb3BlcmF0aW9ucyAqLyBcIi4vc3JjL2ZzL29wZXJhdGlvbnMtd2l0aC1wZXJtaXNzaW9ucy9kaXJlY3Rvcnktb3BlcmF0aW9ucy5qc1wiKSk7XG5cbnZhciBFbnZWYXJpYWJsZVV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMuanNcIikpO1xuXG52YXIgT3V0cHV0RmFjdG9yeSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeSAqLyBcIi4vc3JjL2VtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeS5qc1wiKSk7XG5cbnZhciBfZnNFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL2ZzLWVycm9yICovIFwiLi9zcmMvZnMvZnMtZXJyb3IuanNcIik7XG5cbnZhciBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL3V0aWwgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS91dGlsLmpzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IHRvIGFub3RoZXIgZGlyZWN0b3J5XG4gKiBVc2FnZTogY2QgL25ld0RpcmVjdG9yeVxuICovXG52YXIgdXBkYXRlU3RhdGVDd2QgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZUN3ZChzdGF0ZSwgbmV3Q3dkUGF0aCkge1xuICByZXR1cm4gRW52VmFyaWFibGVVdGlsLnNldEVudmlyb25tZW50VmFyaWFibGUoc3RhdGUuZ2V0RW52VmFyaWFibGVzKCksICdjd2QnLCBuZXdDd2RQYXRoKTtcbn07XG5cbnZhciBvcHREZWYgPSB7fTtcbmV4cG9ydHMub3B0RGVmID0gb3B0RGVmO1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChzdGF0ZSwgY29tbWFuZE9wdGlvbnMpIHtcbiAgdmFyIF9wYXJzZU9wdGlvbnMgPSAoMCwgX29wdGlvblBhcnNlcltcImRlZmF1bHRcIl0pKGNvbW1hbmRPcHRpb25zLCBvcHREZWYpLFxuICAgICAgYXJndiA9IF9wYXJzZU9wdGlvbnMuYXJndjtcblxuICB2YXIgbmV3Q3dkUGF0aCA9IGFyZ3ZbMF0gPyAoMCwgX3V0aWwucmVzb2x2ZVBhdGgpKHN0YXRlLCBhcmd2WzBdKSA6ICcvJztcblxuICBpZiAoIURpcmVjdG9yeU9wLmhhc0RpcmVjdG9yeShzdGF0ZS5nZXRGaWxlU3lzdGVtKCksIG5ld0N3ZFBhdGgpKSB7XG4gICAgdmFyIG5ld0N3ZFBhdGhEb2VzTm90RXhpc3RFcnIgPSAoMCwgX2ZzRXJyb3IubWFrZUVycm9yKShfZnNFcnJvci5mc0Vycm9yVHlwZS5OT19TVUNIX0RJUkVDVE9SWSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogT3V0cHV0RmFjdG9yeS5tYWtlRXJyb3JPdXRwdXQobmV3Q3dkUGF0aERvZXNOb3RFeGlzdEVycilcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0ZTogc3RhdGUuc2V0RW52VmFyaWFibGVzKHVwZGF0ZVN0YXRlQ3dkKHN0YXRlLCBuZXdDd2RQYXRoKSlcbiAgfTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbW1hbmRzL2NsZWFyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1hbmRzL2NsZWFyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMub3B0RGVmID0gdm9pZCAwO1xuXG52YXIgX291dHB1dHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9vdXRwdXRzICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvb3V0cHV0cy5qc1wiKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCB0ZXJtaW5hbCBvdXRwdXRcbiAqIFVzYWdlOiBjbGVhclxuICovXG52YXIgb3B0RGVmID0ge307XG5leHBvcnRzLm9wdERlZiA9IG9wdERlZjtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoc3RhdGUsIGNvbW1hbmRPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGU6IHN0YXRlLnNldE91dHB1dHMoKDAsIF9vdXRwdXRzLmNyZWF0ZSkoKSlcbiAgfTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbW1hbmRzL2NwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1hbmRzL2NwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5vcHREZWYgPSB2b2lkIDA7XG5cbnZhciBfb3B0aW9uUGFyc2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBwYXJzZXIvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3BhcnNlci9vcHRpb24tcGFyc2VyLmpzXCIpKTtcblxudmFyIEZpbGVPcCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMtd2l0aC1wZXJtaXNzaW9ucy9maWxlLW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZmlsZS1vcGVyYXRpb25zLmpzXCIpKTtcblxudmFyIERpcmVjdG9yeU9wID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvb3BlcmF0aW9ucy13aXRoLXBlcm1pc3Npb25zL2RpcmVjdG9yeS1vcGVyYXRpb25zICovIFwiLi9zcmMvZnMvb3BlcmF0aW9ucy13aXRoLXBlcm1pc3Npb25zL2RpcmVjdG9yeS1vcGVyYXRpb25zLmpzXCIpKTtcblxudmFyIFBhdGhVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvdXRpbC9wYXRoLXV0aWwgKi8gXCIuL3NyYy9mcy91dGlsL3BhdGgtdXRpbC5qc1wiKSk7XG5cbnZhciBPdXRwdXRGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzXCIpKTtcblxudmFyIEZpbGVVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvdXRpbC9maWxlLXV0aWwgKi8gXCIuL3NyYy9mcy91dGlsL2ZpbGUtdXRpbC5qc1wiKSk7XG5cbnZhciBfZnNFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL2ZzLWVycm9yICovIFwiLi9zcmMvZnMvZnMtZXJyb3IuanNcIik7XG5cbnZhciBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL3V0aWwgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS91dGlsLmpzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBDb3BpZXMgYSBmaWxlL2RpcmVjdG9yeSB0byBhbm90aGVyIGZpbGUvZGlyZWN0b3J5XG4gKiBVc2FnZTogY3AgZmlsZSBuZXctZmlsZVxuICovXG5cbi8qKlxuICogQ29weSBmcm9tIGEgc291cmNlIGZpbGUgaW50byBhIGRpcmVjdG9yeSBvciBhbm90aGVyIGZpbGUuXG4gKlxuICogQSB0cmFpbGluZyBzbGFzaCAvIGNhbiBiZSB1c2VkIGluIHRoZSBkZXN0aW5hdGlvbiB0byBleHBsaWNpdGx5IHN0YXRlIHRoZVxuICogZGVzdGluYXRpb24gaXMgYSBkaXJlY3RvcnkgYW5kIG5vdCBhIGZpbGUuXG4gKiBAcGFyYW0gIHtNYXB9ICAgICBzdGF0ZSAgICAgICAgICAgICAgZW11bGF0b3Igc3RhdGVcbiAqIEBwYXJhbSAge3N0cmluZ30gIHNyY1BhdGggICAgICAgICAgICBzb3VyY2UgZmlsZSBwYXRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBkZXN0UGF0aCAgICAgICAgICAgZGVzdGluYXRpb24gZmlsZSBvciBkZXN0aW5hdGlvbiBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtICB7Qm9vbGVhbn0gaXNUcmFpbGluZ1BhdGhEZXN0IHRydWUgaWYgdGhlIGRlc3RQYXRoIGVuZGVkIGluIGEgL1xuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgIGNwIGNvbW1hbmQgcmV0dXJuIG9iamVjdFxuICovXG52YXIgY29weVNvdXJjZUZpbGUgPSBmdW5jdGlvbiBjb3B5U291cmNlRmlsZShzdGF0ZSwgc3JjUGF0aCwgZGVzdFBhdGgsIGlzVHJhaWxpbmdQYXRoRGVzdCkge1xuICB2YXIgZnMgPSBzdGF0ZS5nZXRGaWxlU3lzdGVtKCk7XG5cbiAgaWYgKGlzVHJhaWxpbmdQYXRoRGVzdCAmJiAhRGlyZWN0b3J5T3AuaGFzRGlyZWN0b3J5KGZzLCBkZXN0UGF0aCkpIHtcbiAgICB2YXIgZGlyQXRUcmFpbGluZ1BhdGhOb25FeGlzdGVudEVyciA9ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLk5PX1NVQ0hfRElSRUNUT1JZKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0OiBPdXRwdXRGYWN0b3J5Lm1ha2VFcnJvck91dHB1dChkaXJBdFRyYWlsaW5nUGF0aE5vbkV4aXN0ZW50RXJyKVxuICAgIH07XG4gIH1cblxuICB2YXIgX0ZpbGVPcCRjb3B5RmlsZSA9IEZpbGVPcC5jb3B5RmlsZShmcywgc3JjUGF0aCwgZGVzdFBhdGgpLFxuICAgICAgY29waWVkRlMgPSBfRmlsZU9wJGNvcHlGaWxlLmZzLFxuICAgICAgZXJyID0gX0ZpbGVPcCRjb3B5RmlsZS5lcnI7XG5cbiAgaWYgKGVycikge1xuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXQ6IE91dHB1dEZhY3RvcnkubWFrZUVycm9yT3V0cHV0KGVycilcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0ZTogc3RhdGUuc2V0RmlsZVN5c3RlbShjb3BpZWRGUylcbiAgfTtcbn07XG4vKipcbiAqIENvcGllcyBhIGRpcmVjdG9yeSBpbnRvIGFub3RoZXIgZGlyZWN0b3J5XG4gKlxuICogV2hlbiB0aGUgZGVzdGluYXRpb24gcGF0aCBleGlzdHMsIGNwIGNvcGllcyB0aGUgc291cmNlIEZPTERFUiBpbnRvIHRoZVxuICogZGVzdGluYXRpb24uXG4gKlxuICogV2hlbiB0aGUgZGVzdGluYXRpb24gRE9FUyBOT1QgZXhpc3QsIGNwIGNvcGllcyB0aGUgc291cmNlIEZJTEVTIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbi5cbiAqIEBwYXJhbSAge01hcH0gICAgc3RhdGUgICAgICBlbXVsYXRvciBzdGF0ZVxuICogQHBhcmFtICB7c3RyaW5nfSBzcmNQYXRoICAgIHNvdXJjZSBkaXJlY3RvcnkgcGF0aCAoY29weSBmcm9tKVxuICogQHBhcmFtICB7c3RyaW5nfSBkZXN0UGF0aCAgIGRlc3RpbmF0aW9uIGRpcmVjdG9yeSBwYXRoIChjb3B5IHRvKVxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgIGNwIGNvbW1hbmQgcmV0dXJuIG9iamVjdFxuICovXG5cblxudmFyIGNvcHlTb3VyY2VEaXJlY3RvcnkgPSBmdW5jdGlvbiBjb3B5U291cmNlRGlyZWN0b3J5KHN0YXRlLCBzcmNQYXRoLCBkZXN0UGF0aCkge1xuICBpZiAoRGlyZWN0b3J5T3AuaGFzRGlyZWN0b3J5KHN0YXRlLmdldEZpbGVTeXN0ZW0oKSwgZGVzdFBhdGgpKSB7XG4gICAgdmFyIGxhc3RQYXRoQ29tcG9uZW50ID0gUGF0aFV0aWwuZ2V0TGFzdFBhdGhQYXJ0KHNyY1BhdGgpOyAvLyBSZW1hcCBkZXN0IHRvIGNvcHkgc291cmNlIEZPTERFUiwgYXMgZGVzdGluYXRpb24gcGF0aCBleGlzdHNcblxuICAgIGlmIChsYXN0UGF0aENvbXBvbmVudCAhPT0gJy8nKSB7XG4gICAgICBkZXN0UGF0aCA9IFwiXCIuY29uY2F0KGRlc3RQYXRoLCBcIi9cIikuY29uY2F0KGxhc3RQYXRoQ29tcG9uZW50KTtcbiAgICB9XG4gIH0gLy8gTWFrZSBkaXJlY3RvcnkgdG8gY29weSBpbnRvLCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcblxuXG4gIGlmICghRGlyZWN0b3J5T3AuaGFzRGlyZWN0b3J5KHN0YXRlLmdldEZpbGVTeXN0ZW0oKSwgZGVzdFBhdGgpKSB7XG4gICAgdmFyIGVtcHR5RGlyID0gRmlsZVV0aWwubWFrZURpcmVjdG9yeSgpO1xuXG4gICAgdmFyIF9EaXJlY3RvcnlPcCRhZGREaXJlYyA9IERpcmVjdG9yeU9wLmFkZERpcmVjdG9yeShzdGF0ZS5nZXRGaWxlU3lzdGVtKCksIGRlc3RQYXRoLCBlbXB0eURpciwgZmFsc2UpLFxuICAgICAgICBfZnMgPSBfRGlyZWN0b3J5T3AkYWRkRGlyZWMuZnMsXG4gICAgICAgIF9lcnIgPSBfRGlyZWN0b3J5T3AkYWRkRGlyZWMuZXJyO1xuXG4gICAgc3RhdGUgPSBzdGF0ZS5zZXRGaWxlU3lzdGVtKF9mcyk7XG5cbiAgICBpZiAoX2Vycikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3V0cHV0OiBPdXRwdXRGYWN0b3J5Lm1ha2VFcnJvck91dHB1dChfZXJyKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgX0RpcmVjdG9yeU9wJGNvcHlEaXJlID0gRGlyZWN0b3J5T3AuY29weURpcmVjdG9yeShzdGF0ZS5nZXRGaWxlU3lzdGVtKCksIHNyY1BhdGgsIGRlc3RQYXRoKSxcbiAgICAgIGZzID0gX0RpcmVjdG9yeU9wJGNvcHlEaXJlLmZzLFxuICAgICAgZXJyID0gX0RpcmVjdG9yeU9wJGNvcHlEaXJlLmVycjtcblxuICBpZiAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogT3V0cHV0RmFjdG9yeS5tYWtlRXJyb3JPdXRwdXQoZXJyKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXRlOiBzdGF0ZS5zZXRGaWxlU3lzdGVtKGZzKVxuICB9O1xufTtcblxudmFyIG9wdERlZiA9IHtcbiAgJy1yLCAtLXJlY3Vyc2l2ZSc6ICcnIC8vIHJlcXVpcmVkIHRvIGNvcHkgZGlyZWN0b3JpZXNcblxufTtcbmV4cG9ydHMub3B0RGVmID0gb3B0RGVmO1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChzdGF0ZSwgY29tbWFuZE9wdGlvbnMpIHtcbiAgdmFyIF9wYXJzZU9wdGlvbnMgPSAoMCwgX29wdGlvblBhcnNlcltcImRlZmF1bHRcIl0pKGNvbW1hbmRPcHRpb25zLCBvcHREZWYpLFxuICAgICAgYXJndiA9IF9wYXJzZU9wdGlvbnMuYXJndixcbiAgICAgIG9wdGlvbnMgPSBfcGFyc2VPcHRpb25zLm9wdGlvbnM7XG5cbiAgaWYgKGFyZ3YubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHZhciBzcmNQYXRoID0gKDAsIF91dGlsLnJlc29sdmVQYXRoKShzdGF0ZSwgYXJndlswXSk7XG4gIHZhciBkZXN0UGF0aCA9ICgwLCBfdXRpbC5yZXNvbHZlUGF0aCkoc3RhdGUsIGFyZ3ZbMV0pO1xuICB2YXIgaXNUcmFpbGluZ0Rlc3RQYXRoID0gUGF0aFV0aWwuaXNUcmFpbGluZ1BhdGgoYXJndlsxXSk7XG5cbiAgaWYgKHNyY1BhdGggPT09IGRlc3RQYXRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogT3V0cHV0RmFjdG9yeS5tYWtlVGV4dE91dHB1dCgnU291cmNlIGFuZCBkZXN0aW5hdGlvbiBhcmUgdGhlIHNhbWUgKG5vdCBjb3BpZWQpLicpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlY3Vyc2l2ZSkge1xuICAgIHJldHVybiBjb3B5U291cmNlRGlyZWN0b3J5KHN0YXRlLCBzcmNQYXRoLCBkZXN0UGF0aCk7XG4gIH1cblxuICByZXR1cm4gY29weVNvdXJjZUZpbGUoc3RhdGUsIHNyY1BhdGgsIGRlc3RQYXRoLCBpc1RyYWlsaW5nRGVzdFBhdGgpO1xufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tbWFuZHMvZWNoby5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1hbmRzL2VjaG8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMub3B0RGVmID0gdm9pZCAwO1xuXG52YXIgT3V0cHV0RmFjdG9yeSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeSAqLyBcIi4vc3JjL2VtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeS5qc1wiKSk7XG5cbnZhciBfZW52aXJvbm1lbnRWYXJpYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMuanNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxuICogUHJpbnRzIGFyZ3VtZW50cyB0byB0ZXh0IG91dHB1dFxuICogVXNhZ2U6IGVjaG8gJ2hlbGxvIHdvcmxkJ1xuICovXG52YXIgVkFSSUFCTEVfR1JPVVBfUkVHRVggPSAvXFwkKFxcdyspL2c7XG52YXIgRE9VQkxFX1NQQUNFX1JFR0VYID0gL1xcc1xccysvZztcblxudmFyIHN1YnN0aXR1dGVFbnZWYXJpYWJsZXMgPSBmdW5jdGlvbiBzdWJzdGl0dXRlRW52VmFyaWFibGVzKGVudmlyb25tZW50VmFyaWFibGVzLCBpbnB1dFN0cikge1xuICByZXR1cm4gaW5wdXRTdHIucmVwbGFjZShWQVJJQUJMRV9HUk9VUF9SRUdFWCwgZnVuY3Rpb24gKG1hdGNoLCB2YXJOYW1lKSB7XG4gICAgcmV0dXJuICgwLCBfZW52aXJvbm1lbnRWYXJpYWJsZXMuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoZW52aXJvbm1lbnRWYXJpYWJsZXMsIHZhck5hbWUpIHx8ICcnO1xuICB9KTtcbn07XG5cbnZhciBvcHREZWYgPSB7fTtcbmV4cG9ydHMub3B0RGVmID0gb3B0RGVmO1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChzdGF0ZSwgY29tbWFuZE9wdGlvbnMpIHtcbiAgdmFyIGlucHV0ID0gY29tbWFuZE9wdGlvbnMuam9pbignICcpO1xuICB2YXIgb3V0cHV0U3RyID0gc3Vic3RpdHV0ZUVudlZhcmlhYmxlcyhzdGF0ZS5nZXRFbnZWYXJpYWJsZXMoKSwgaW5wdXQpO1xuICB2YXIgY2xlYW5TdHIgPSBvdXRwdXRTdHIudHJpbSgpLnJlcGxhY2UoRE9VQkxFX1NQQUNFX1JFR0VYLCAnICcpO1xuICByZXR1cm4ge1xuICAgIG91dHB1dDogT3V0cHV0RmFjdG9yeS5tYWtlVGV4dE91dHB1dChjbGVhblN0cilcbiAgfTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbW1hbmRzL2hlYWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tYW5kcy9oZWFkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBleHBvcnRzLm9wdERlZiA9IHZvaWQgMDtcblxudmFyIF9vcHRpb25QYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIHBhcnNlci9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvcGFyc2VyL29wdGlvbi1wYXJzZXIuanNcIikpO1xuXG52YXIgT3V0cHV0RmFjdG9yeSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeSAqLyBcIi4vc3JjL2VtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeS5qc1wiKSk7XG5cbnZhciBfaGVhZF90YWlsX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb21tYW5kcy91dGlsL19oZWFkX3RhaWxfdXRpbC5qcyAqLyBcIi4vc3JjL2NvbW1hbmRzL3V0aWwvX2hlYWRfdGFpbF91dGlsLmpzXCIpO1xuXG52YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS91dGlsICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvdXRpbC5qc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogUHJpbnRzIHRoZSBmaXJzdCBuIGxpbmVzIG9mIGEgZmlsZVxuICogVXNhZ2U6IGhlYWQgLW4gNSBmaWxlLnR4dFxuICovXG52YXIgb3B0RGVmID0ge1xuICAnLW4sIC0tbGluZXMnOiAnPGNvdW50Pidcbn07XG5leHBvcnRzLm9wdERlZiA9IG9wdERlZjtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoc3RhdGUsIGNvbW1hbmRPcHRpb25zKSB7XG4gIHZhciBfcGFyc2VPcHRpb25zID0gKDAsIF9vcHRpb25QYXJzZXJbXCJkZWZhdWx0XCJdKShjb21tYW5kT3B0aW9ucywgb3B0RGVmKSxcbiAgICAgIGFyZ3YgPSBfcGFyc2VPcHRpb25zLmFyZ3YsXG4gICAgICBvcHRpb25zID0gX3BhcnNlT3B0aW9ucy5vcHRpb25zO1xuXG4gIGlmIChhcmd2Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHZhciBmaWxlUGF0aCA9ICgwLCBfdXRpbC5yZXNvbHZlUGF0aCkoc3RhdGUsIGFyZ3ZbMF0pO1xuXG4gIHZhciBoZWFkVHJpbW1pbmdGbiA9IGZ1bmN0aW9uIGhlYWRUcmltbWluZ0ZuKGxpbmVzLCBsaW5lQ291bnQpIHtcbiAgICByZXR1cm4gbGluZXMuc2xpY2UoMCwgbGluZUNvdW50KTtcbiAgfTtcblxuICB2YXIgX3RyaW1GaWxlQ29udGVudCA9ICgwLCBfaGVhZF90YWlsX3V0aWwudHJpbUZpbGVDb250ZW50KShzdGF0ZS5nZXRGaWxlU3lzdGVtKCksIGZpbGVQYXRoLCBvcHRpb25zLCBoZWFkVHJpbW1pbmdGbiksXG4gICAgICBjb250ZW50ID0gX3RyaW1GaWxlQ29udGVudC5jb250ZW50LFxuICAgICAgZXJyID0gX3RyaW1GaWxlQ29udGVudC5lcnI7XG5cbiAgaWYgKGVycikge1xuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXQ6IE91dHB1dEZhY3RvcnkubWFrZUVycm9yT3V0cHV0KGVycilcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRwdXQ6IE91dHB1dEZhY3RvcnkubWFrZVRleHRPdXRwdXQoY29udGVudClcbiAgfTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbW1hbmRzL2hpc3RvcnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tYW5kcy9oaXN0b3J5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBleHBvcnRzLm9wdERlZiA9IHZvaWQgMDtcblxudmFyIF9vcHRpb25QYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIHBhcnNlci9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvcGFyc2VyL29wdGlvbi1wYXJzZXIuanNcIikpO1xuXG52YXIgT3V0cHV0RmFjdG9yeSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeSAqLyBcIi4vc3JjL2VtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeS5qc1wiKSk7XG5cbnZhciBfaGlzdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL2hpc3RvcnkgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9oaXN0b3J5LmpzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBMaXN0cyBvciBjbGVhcnMgY29tbWFuZHMgZXhlY3V0ZWQgaW4gdGhlIHRlcm1pbmFsXG4gKiBVc2FnZTogaGlzdG9yeSAtY1xuICovXG52YXIgY2xlYXJTdGF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjbGVhclN0YXRlSGlzdG9yeShzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuc2V0SGlzdG9yeSgoMCwgX2hpc3RvcnkuY3JlYXRlKSgpKTtcbn07XG5cbnZhciBzdHJpbmdpZnlTdGF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBzdHJpbmdpZnlTdGF0ZUhpc3Rvcnkoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmdldEhpc3RvcnkoKS5qb2luKCdcXG4nKTtcbn07XG5cbnZhciBvcHREZWYgPSB7XG4gICctYywgLS1jbGVhcic6ICcnIC8vIHJlbW92ZSBoaXN0b3J5IGVudHJpZXNcblxufTtcbmV4cG9ydHMub3B0RGVmID0gb3B0RGVmO1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChzdGF0ZSwgY29tbWFuZE9wdGlvbnMpIHtcbiAgdmFyIF9wYXJzZU9wdGlvbnMgPSAoMCwgX29wdGlvblBhcnNlcltcImRlZmF1bHRcIl0pKGNvbW1hbmRPcHRpb25zLCBvcHREZWYpLFxuICAgICAgb3B0aW9ucyA9IF9wYXJzZU9wdGlvbnMub3B0aW9ucztcblxuICBpZiAob3B0aW9ucy5jbGVhcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZTogY2xlYXJTdGF0ZUhpc3Rvcnkoc3RhdGUpXG4gICAgfTtcbiAgfVxuXG4gIDtcbiAgcmV0dXJuIHtcbiAgICBvdXRwdXQ6IE91dHB1dEZhY3RvcnkubWFrZVRleHRPdXRwdXQoc3RyaW5naWZ5U3RhdGVIaXN0b3J5KHN0YXRlKSlcbiAgfTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbW1hbmRzL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1hbmRzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMuY29tbWFuZE5hbWVzID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGNvbW1hbmROYW1lcyA9IFsnY2F0JywgJ2NkJywgJ2NsZWFyJywgJ2NwJywgJ2VjaG8nLCAnaGVhZCcsICdoaXN0b3J5JywgJ2xzJywgJ21rZGlyJywgJ3ByaW50ZW52JywgJ3B3ZCcsICdybScsICdybWRpcicsICd0YWlsJywgJ3RvdWNoJywgJ3dob2FtaSddO1xuZXhwb3J0cy5jb21tYW5kTmFtZXMgPSBjb21tYW5kTmFtZXM7XG5cbnZhciBfZGVmYXVsdCA9IGNvbW1hbmROYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKG1hcHBpbmcsIGNvbW1hbmROYW1lKSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBtYXBwaW5nLCBfZGVmaW5lUHJvcGVydHkoe30sIGNvbW1hbmROYW1lLCB7XG4gICAgXCJmdW5jdGlvblwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tbWFuZHMgc3luYyByZWN1cnNpdmUgXlxcXFwuXFxcXC8uKiRcIikoXCIuL1wiLmNvbmNhdChjb21tYW5kTmFtZSkpW1wiZGVmYXVsdFwiXSxcbiAgICBvcHREZWY6IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21tYW5kcyBzeW5jIHJlY3Vyc2l2ZSBeXFxcXC5cXFxcLy4qJFwiKShcIi4vXCIuY29uY2F0KGNvbW1hbmROYW1lKSkub3B0RGVmXG4gIH0pKTtcbn0sIHt9KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tbWFuZHMvbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tbWFuZHMvbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBleHBvcnRzLm9wdERlZiA9IHZvaWQgMDtcblxudmFyIF9vcHRpb25QYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIHBhcnNlci9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvcGFyc2VyL29wdGlvbi1wYXJzZXIuanNcIikpO1xuXG52YXIgRGlyZWN0b3J5T3AgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMuanNcIikpO1xuXG52YXIgRW52VmFyaWFibGVVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itc3RhdGUvZW52aXJvbm1lbnQtdmFyaWFibGVzICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvZW52aXJvbm1lbnQtdmFyaWFibGVzLmpzXCIpKTtcblxudmFyIFBhdGhVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvdXRpbC9wYXRoLXV0aWwgKi8gXCIuL3NyYy9mcy91dGlsL3BhdGgtdXRpbC5qc1wiKSk7XG5cbnZhciBPdXRwdXRGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzXCIpKTtcblxudmFyIF9pbW11dGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBpbW11dGFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9pbW11dGFibGUvZGlzdC9pbW11dGFibGUuZXMuanNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIExpc3RzIHRoZSBjb250ZW50cyBvZiBhIGRpcmVjdG9yeVxuICogVXNhZ2U6IGxzIC9mb2xkZXJOYW1lXG4gKi9cbnZhciBJTVBMSUVEX0RJUkVDVE9SWV9FTlRSSUVTID0gKDAsIF9pbW11dGFibGUuU2VxKShbJy4nLCAnLi4nXSk7IC8vIC4gPSBsaXN0ZWQgZm9sZGVyLCAuLiA9IHBhcmVudCBmb2xkZXJcblxuLyoqXG4gKiBGaW5kcyB0aGUgZGlyZWN0b3J5IHBhdGggdG8gbGlzdCBlbnRyaWVzIGluLlxuICpcbiAqIElmIGxzIGhhcyBhbiBhcmd1bWVudCBwYXNzZWQgaW4gKGV4YW1wbGU6IGxzIC9ob21lL3VzZXIvZGlyZWN0b3J5LXRvLWxpc3QpLFxuICogdXNlIHRoZSBmaXJzdCBhcmd1bWVudCBhcyB0aGUgZGlyZWN0b3J5IHRvIGxpc3QuXG4gKlxuICogSWYgbHMgaXMgdXNlZCB3aXRob3V0IGFueSBwYXRoIGFyZ3VtZW50cyAoZXhhbXBsZTogbHMpLCB0aGUgY3dkIChjdXJyZW50XG4gKiB3b3JraW5nIGRpcmVjdG9yeSkgc2hvdWxkIGJlIGxpc3RlZCBieSBscy5cbiAqIEBwYXJhbSAge01hcH0gICAgZW52VmFyaWFibGVzICBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqIEBwYXJhbSAge2FycmF5fSAgYXJndiAgICAgICAgICBhcmd1bWVudCB2ZWN0b3JcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgICBkaXJlY3RvcnkgcGF0aCB0byBsaXN0XG4gKi9cblxudmFyIHJlc29sdmVEaXJlY3RvcnlUb0xpc3QgPSBmdW5jdGlvbiByZXNvbHZlRGlyZWN0b3J5VG9MaXN0KGVudlZhcmlhYmxlcywgYXJndikge1xuICB2YXIgY3dkID0gRW52VmFyaWFibGVVdGlsLmdldEVudmlyb25tZW50VmFyaWFibGUoZW52VmFyaWFibGVzLCAnY3dkJyk7XG5cbiAgaWYgKGFyZ3YubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBQYXRoVXRpbC50b0Fic29sdXRlUGF0aChhcmd2WzBdLCBjd2QpO1xuICB9XG5cbiAgcmV0dXJuIGN3ZDtcbn07XG4vKipcbiAqIEFscGhhYmV0aWNhbGx5IHNvcnRzIHRoZSBscyBsaXN0aW5nIGZvciBkaXNwbGF5IHRvIHRoZSB1c2VyXG4gKiBAcGFyYW0gIHthcnJheX0gIGxpc3RpbmcgbGlzdCBvZiBmaWxlcy9kaXJlY3RvcmllcyB0byBwcmVzZW50IHRvIHRoZSB1c2VyXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgcmV0dXJuIG9iamVjdCBvZiBsc1xuICovXG5cblxudmFyIG1ha2VTb3J0ZWRSZXR1cm4gPSBmdW5jdGlvbiBtYWtlU29ydGVkUmV0dXJuKGxpc3RpbmcpIHtcbiAgdmFyIHNvcnRlZExpc3RpbmcgPSBsaXN0aW5nLnNvcnQoKTtcbiAgcmV0dXJuIHtcbiAgICBvdXRwdXQ6IE91dHB1dEZhY3RvcnkubWFrZVRleHRPdXRwdXQoc29ydGVkTGlzdGluZy5qb2luKCcgJykpXG4gIH07XG59O1xuXG52YXIgcmVtb3ZlSGlkZGVuRmlsZXNGaWx0ZXIgPSBmdW5jdGlvbiByZW1vdmVIaWRkZW5GaWxlc0ZpbHRlcihyZWNvcmQpIHtcbiAgcmV0dXJuICFyZWNvcmQuc3RhcnRzV2l0aCgnLicpO1xufTtcblxudmFyIG9wdERlZiA9IHtcbiAgJy1hLCAtLWFsbCc6ICcnLFxuICAvLyBJbmNsdWRlIGhpZGRlbiBkaXJlY3RvcnkgZW50cmllcyBzdGFydGluZyB3aXRoIC5cbiAgJy1BLCAtLWFsbW9zdC1hbGwnOiAnJyAvLyBEbyBub3QgaW5jbHVkZSAuIGFuZCAuLiBhcyBpbXBsaWVkIGRpcmVjdG9yeSBlbnRyaWVzXG5cbn07XG5leHBvcnRzLm9wdERlZiA9IG9wdERlZjtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoc3RhdGUsIGNvbW1hbmRPcHRpb25zKSB7XG4gIHZhciBfcGFyc2VPcHRpb25zID0gKDAsIF9vcHRpb25QYXJzZXJbXCJkZWZhdWx0XCJdKShjb21tYW5kT3B0aW9ucywgb3B0RGVmKSxcbiAgICAgIG9wdGlvbnMgPSBfcGFyc2VPcHRpb25zLm9wdGlvbnMsXG4gICAgICBhcmd2ID0gX3BhcnNlT3B0aW9ucy5hcmd2O1xuXG4gIHZhciBkaXJQYXRoID0gcmVzb2x2ZURpcmVjdG9yeVRvTGlzdChzdGF0ZS5nZXRFbnZWYXJpYWJsZXMoKSwgYXJndik7XG5cbiAgdmFyIF9EaXJlY3RvcnlPcCRsaXN0RGlyZSA9IERpcmVjdG9yeU9wLmxpc3REaXJlY3Rvcnkoc3RhdGUuZ2V0RmlsZVN5c3RlbSgpLCBkaXJQYXRoKSxcbiAgICAgIGVyciA9IF9EaXJlY3RvcnlPcCRsaXN0RGlyZS5lcnIsXG4gICAgICBkaXJMaXN0ID0gX0RpcmVjdG9yeU9wJGxpc3REaXJlLmxpc3Q7XG5cbiAgaWYgKGVycikge1xuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXQ6IE91dHB1dEZhY3RvcnkubWFrZUVycm9yT3V0cHV0KGVycilcbiAgICB9O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWxsKSB7XG4gICAgcmV0dXJuIG1ha2VTb3J0ZWRSZXR1cm4oSU1QTElFRF9ESVJFQ1RPUllfRU5UUklFUy5jb25jYXQoZGlyTGlzdCkpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxtb3N0QWxsKSB7XG4gICAgcmV0dXJuIG1ha2VTb3J0ZWRSZXR1cm4oZGlyTGlzdCk7XG4gIH1cblxuICByZXR1cm4gbWFrZVNvcnRlZFJldHVybihkaXJMaXN0LmZpbHRlcihyZW1vdmVIaWRkZW5GaWxlc0ZpbHRlcikpO1xufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tbWFuZHMvbWtkaXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tbWFuZHMvbWtkaXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBleHBvcnRzLm9wdERlZiA9IHZvaWQgMDtcblxudmFyIF9vcHRpb25QYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIHBhcnNlci9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvcGFyc2VyL29wdGlvbi1wYXJzZXIuanNcIikpO1xuXG52YXIgRGlyT3AgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMuanNcIikpO1xuXG52YXIgT3V0cHV0RmFjdG9yeSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeSAqLyBcIi4vc3JjL2VtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeS5qc1wiKSk7XG5cbnZhciBGaWxlVXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL3V0aWwvZmlsZS11dGlsICovIFwiLi9zcmMvZnMvdXRpbC9maWxlLXV0aWwuanNcIikpO1xuXG52YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS91dGlsICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvdXRpbC5qc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBkaXJlY3RvcnlcbiAqIFVzYWdlOiBta2RpciAvbmV3RGlyXG4gKi9cbnZhciBFTVBUWV9ESVIgPSBGaWxlVXRpbC5tYWtlRGlyZWN0b3J5KCk7XG52YXIgb3B0RGVmID0ge307XG5leHBvcnRzLm9wdERlZiA9IG9wdERlZjtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoc3RhdGUsIGNvbW1hbmRPcHRpb25zKSB7XG4gIHZhciBfcGFyc2VPcHRpb25zID0gKDAsIF9vcHRpb25QYXJzZXJbXCJkZWZhdWx0XCJdKShjb21tYW5kT3B0aW9ucywgb3B0RGVmKSxcbiAgICAgIGFyZ3YgPSBfcGFyc2VPcHRpb25zLmFyZ3Y7XG5cbiAgaWYgKGFyZ3YubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHt9OyAvLyBkbyBub3RoaW5nIGlmIG5vIGFyZ3VtZW50cyBhcmUgZ2l2ZW5cbiAgfVxuXG4gIHZhciBuZXdGb2xkZXJQYXRoID0gKDAsIF91dGlsLnJlc29sdmVQYXRoKShzdGF0ZSwgYXJndlswXSk7XG5cbiAgdmFyIF9EaXJPcCRhZGREaXJlY3RvcnkgPSBEaXJPcC5hZGREaXJlY3Rvcnkoc3RhdGUuZ2V0RmlsZVN5c3RlbSgpLCBuZXdGb2xkZXJQYXRoLCBFTVBUWV9ESVIsIGZhbHNlKSxcbiAgICAgIGZzID0gX0Rpck9wJGFkZERpcmVjdG9yeS5mcyxcbiAgICAgIGVyciA9IF9EaXJPcCRhZGREaXJlY3RvcnkuZXJyO1xuXG4gIGlmIChlcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0OiBPdXRwdXRGYWN0b3J5Lm1ha2VFcnJvck91dHB1dChlcnIpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhdGU6IHN0YXRlLnNldEZpbGVTeXN0ZW0oZnMpXG4gIH07XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21tYW5kcy9wcmludGVudi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tYW5kcy9wcmludGVudi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMub3B0RGVmID0gdm9pZCAwO1xuXG52YXIgX29wdGlvblBhcnNlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcGFyc2VyL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy9wYXJzZXIvb3B0aW9uLXBhcnNlci5qc1wiKSk7XG5cbnZhciBPdXRwdXRGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzXCIpKTtcblxudmFyIF9lbnZpcm9ubWVudFZhcmlhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL2Vudmlyb25tZW50LXZhcmlhYmxlcyAqLyBcIi4vc3JjL2VtdWxhdG9yLXN0YXRlL2Vudmlyb25tZW50LXZhcmlhYmxlcy5qc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gQ29udmVydHMgYWxsIGtleS12YWx1ZSBwYWlycyBvZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIGEgcHJpbnRhYmxlIGZvcm1hdFxudmFyIHN0cmluZ2lmeUVudlZhcmlhYmxlcyA9IGZ1bmN0aW9uIHN0cmluZ2lmeUVudlZhcmlhYmxlcyhlbnZWYXJpYWJsZXMpIHtcbiAgdmFyIG91dHB1dHMgPSBlbnZWYXJpYWJsZXMucmVkdWNlKGZ1bmN0aW9uIChvdXRwdXRzLCB2YXJWYWwsIHZhcktleSkge1xuICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG91dHB1dHMpLCBbXCJcIi5jb25jYXQodmFyS2V5LCBcIj1cIikuY29uY2F0KHZhclZhbCldKTtcbiAgfSwgW10pO1xuICByZXR1cm4gb3V0cHV0cy5qb2luKCdcXG4nKTtcbn07XG5cbnZhciBvcHREZWYgPSB7fTtcbmV4cG9ydHMub3B0RGVmID0gb3B0RGVmO1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChzdGF0ZSwgY29tbWFuZE9wdGlvbnMpIHtcbiAgdmFyIF9wYXJzZU9wdGlvbnMgPSAoMCwgX29wdGlvblBhcnNlcltcImRlZmF1bHRcIl0pKGNvbW1hbmRPcHRpb25zLCBvcHREZWYpLFxuICAgICAgYXJndiA9IF9wYXJzZU9wdGlvbnMuYXJndjtcblxuICB2YXIgZW52VmFyaWFibGVzID0gc3RhdGUuZ2V0RW52VmFyaWFibGVzKCk7XG5cbiAgaWYgKGFyZ3YubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogT3V0cHV0RmFjdG9yeS5tYWtlVGV4dE91dHB1dChzdHJpbmdpZnlFbnZWYXJpYWJsZXMoZW52VmFyaWFibGVzKSlcbiAgICB9O1xuICB9IC8vIEFuIGFyZ3VtZW50IGhhcyBiZWVuIHBhc3NlZCB0byBwcmludGVudjsgcHJpbnRlbnYgd2lsbCBvbmx5IHByaW50IHRoZSBmaXJzdFxuICAvLyBhcmd1bWVudCBwcm92aWRlZFxuXG5cbiAgdmFyIHZhclZhbHVlID0gKDAsIF9lbnZpcm9ubWVudFZhcmlhYmxlcy5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShlbnZWYXJpYWJsZXMsIGFyZ3ZbMF0pO1xuXG4gIGlmICh2YXJWYWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXQ6IE91dHB1dEZhY3RvcnkubWFrZVRleHRPdXRwdXQodmFyVmFsdWUpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7fTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbW1hbmRzL3B3ZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tbWFuZHMvcHdkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMub3B0RGVmID0gdm9pZCAwO1xuXG52YXIgT3V0cHV0RmFjdG9yeSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeSAqLyBcIi4vc3JjL2VtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeS5qc1wiKSk7XG5cbnZhciBfZW52aXJvbm1lbnRWYXJpYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMuanNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxuICogUHJpbnRzIG91dCB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSAoY3dkKS5cbiAqIFVzYWdlOiBwd2RcbiAqL1xudmFyIG9wdERlZiA9IHt9O1xuZXhwb3J0cy5vcHREZWYgPSBvcHREZWY7XG5cbnZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KHN0YXRlLCBjb21tYW5kT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIG91dHB1dDogT3V0cHV0RmFjdG9yeS5tYWtlVGV4dE91dHB1dCgoMCwgX2Vudmlyb25tZW50VmFyaWFibGVzLmdldEVudmlyb25tZW50VmFyaWFibGUpKHN0YXRlLmdldEVudlZhcmlhYmxlcygpLCAnY3dkJykpXG4gIH07XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21tYW5kcy9ybS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tYW5kcy9ybS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMub3B0RGVmID0gdm9pZCAwO1xuXG52YXIgX29wdGlvblBhcnNlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcGFyc2VyL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy9wYXJzZXIvb3B0aW9uLXBhcnNlci5qc1wiKSk7XG5cbnZhciBGaWxlT3AgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZmlsZS1vcGVyYXRpb25zICovIFwiLi9zcmMvZnMvb3BlcmF0aW9ucy13aXRoLXBlcm1pc3Npb25zL2ZpbGUtb3BlcmF0aW9ucy5qc1wiKSk7XG5cbnZhciBEaXJPcCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMtd2l0aC1wZXJtaXNzaW9ucy9kaXJlY3Rvcnktb3BlcmF0aW9ucyAqLyBcIi4vc3JjL2ZzL29wZXJhdGlvbnMtd2l0aC1wZXJtaXNzaW9ucy9kaXJlY3Rvcnktb3BlcmF0aW9ucy5qc1wiKSk7XG5cbnZhciBPdXRwdXRGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzXCIpKTtcblxudmFyIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itc3RhdGUvdXRpbCAqLyBcIi4vc3JjL2VtdWxhdG9yLXN0YXRlL3V0aWwuanNcIik7XG5cbnZhciBfZnNFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL2ZzLWVycm9yICovIFwiLi9zcmMvZnMvZnMtZXJyb3IuanNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIFJlbW92ZXMgYSBkaXJlY3Rvcnkgb3IgYSBmaWxlXG4gKiBVc2FnZTogcm0gL2V4aXN0aW5nRGlyXG4gKi9cbnZhciBvcHREZWYgPSB7XG4gICctLW5vLXByZXNlcnZlLXJvb3QsIC0tbm9QcmVzZXJ2ZVJvb3QnOiAnJyxcbiAgJy1yLCAtLXJlY3Vyc2l2ZSc6ICcnXG59O1xuZXhwb3J0cy5vcHREZWYgPSBvcHREZWY7XG5cbnZhciBtYWtlTm9QYXRoRXJyb3JPdXRwdXQgPSBmdW5jdGlvbiBtYWtlTm9QYXRoRXJyb3JPdXRwdXQoKSB7XG4gIHZhciBub1N1Y2hGaWxlT3JEaXJFcnJvciA9ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLk5PX1NVQ0hfRklMRV9PUl9ESVJFQ1RPUlkpO1xuICByZXR1cm4ge1xuICAgIG91dHB1dDogT3V0cHV0RmFjdG9yeS5tYWtlRXJyb3JPdXRwdXQobm9TdWNoRmlsZU9yRGlyRXJyb3IpXG4gIH07XG59O1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChzdGF0ZSwgY29tbWFuZE9wdGlvbnMpIHtcbiAgdmFyIF9wYXJzZU9wdGlvbnMgPSAoMCwgX29wdGlvblBhcnNlcltcImRlZmF1bHRcIl0pKGNvbW1hbmRPcHRpb25zLCBvcHREZWYpLFxuICAgICAgYXJndiA9IF9wYXJzZU9wdGlvbnMuYXJndixcbiAgICAgIG9wdGlvbnMgPSBfcGFyc2VPcHRpb25zLm9wdGlvbnM7XG5cbiAgaWYgKGFyZ3YubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHt9OyAvLyBkbyBub3RoaW5nIGlmIG5vIGFyZ3VtZW50cyBhcmUgZ2l2ZW5cbiAgfVxuXG4gIHZhciBkZWxldGlvblBhdGggPSAoMCwgX3V0aWwucmVzb2x2ZVBhdGgpKHN0YXRlLCBhcmd2WzBdKTtcbiAgdmFyIGZzID0gc3RhdGUuZ2V0RmlsZVN5c3RlbSgpO1xuXG4gIGlmIChkZWxldGlvblBhdGggPT09ICcvJyAmJiBvcHRpb25zLm5vUHJlc2VydmVSb290ICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9OyAvLyBkbyBub3RoaW5nIGFzIGNhbm5vdCBzYWZlbHkgZGVsZXRlIHRoZSByb290XG4gIH1cblxuICBpZiAoIWZzLmhhcyhkZWxldGlvblBhdGgpKSB7XG4gICAgcmV0dXJuIG1ha2VOb1BhdGhFcnJvck91dHB1dCgpO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBvcHRpb25zLnJlY3Vyc2l2ZSA9PT0gdHJ1ZSA/IERpck9wLmRlbGV0ZURpcmVjdG9yeShmcywgZGVsZXRpb25QYXRoLCB0cnVlKSA6IEZpbGVPcC5kZWxldGVGaWxlKGZzLCBkZWxldGlvblBhdGgpLFxuICAgICAgZGVsZXRlZFBhdGhGUyA9IF9yZWYuZnMsXG4gICAgICBlcnIgPSBfcmVmLmVycjtcblxuICBpZiAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogT3V0cHV0RmFjdG9yeS5tYWtlRXJyb3JPdXRwdXQoZXJyKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXRlOiBzdGF0ZS5zZXRGaWxlU3lzdGVtKGRlbGV0ZWRQYXRoRlMpXG4gIH07XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21tYW5kcy9ybWRpci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tYW5kcy9ybWRpci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMub3B0RGVmID0gdm9pZCAwO1xuXG52YXIgX29wdGlvblBhcnNlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcGFyc2VyL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy9wYXJzZXIvb3B0aW9uLXBhcnNlci5qc1wiKSk7XG5cbnZhciBEaXJPcCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMtd2l0aC1wZXJtaXNzaW9ucy9kaXJlY3Rvcnktb3BlcmF0aW9ucyAqLyBcIi4vc3JjL2ZzL29wZXJhdGlvbnMtd2l0aC1wZXJtaXNzaW9ucy9kaXJlY3Rvcnktb3BlcmF0aW9ucy5qc1wiKSk7XG5cbnZhciBPdXRwdXRGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzXCIpKTtcblxudmFyIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itc3RhdGUvdXRpbCAqLyBcIi4vc3JjL2VtdWxhdG9yLXN0YXRlL3V0aWwuanNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIFJlbW92ZXMgYW4gZW1wdHkgZGlyZWN0b3J5XG4gKiBVc2FnZTogcm1kaXIgL2VtcHR5RGlyXG4gKi9cbnZhciBvcHREZWYgPSB7fTtcbmV4cG9ydHMub3B0RGVmID0gb3B0RGVmO1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChzdGF0ZSwgY29tbWFuZE9wdGlvbnMpIHtcbiAgdmFyIF9wYXJzZU9wdGlvbnMgPSAoMCwgX29wdGlvblBhcnNlcltcImRlZmF1bHRcIl0pKGNvbW1hbmRPcHRpb25zLCBvcHREZWYpLFxuICAgICAgYXJndiA9IF9wYXJzZU9wdGlvbnMuYXJndjtcblxuICBpZiAoYXJndi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge307IC8vIGRvIG5vdGhpbmcgaWYgbm8gYXJndW1lbnRzIGFyZSBnaXZlblxuICB9XG5cbiAgdmFyIHBhdGhUb0RlbGV0ZSA9ICgwLCBfdXRpbC5yZXNvbHZlUGF0aCkoc3RhdGUsIGFyZ3ZbMF0pO1xuXG4gIHZhciBfRGlyT3AkZGVsZXRlRGlyZWN0b3IgPSBEaXJPcC5kZWxldGVEaXJlY3Rvcnkoc3RhdGUuZ2V0RmlsZVN5c3RlbSgpLCBwYXRoVG9EZWxldGUsIGZhbHNlKSxcbiAgICAgIGZzID0gX0Rpck9wJGRlbGV0ZURpcmVjdG9yLmZzLFxuICAgICAgZXJyID0gX0Rpck9wJGRlbGV0ZURpcmVjdG9yLmVycjtcblxuICBpZiAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogT3V0cHV0RmFjdG9yeS5tYWtlRXJyb3JPdXRwdXQoZXJyKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXRlOiBzdGF0ZS5zZXRGaWxlU3lzdGVtKGZzKVxuICB9O1xufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tbWFuZHMvdGFpbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1hbmRzL3RhaWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMub3B0RGVmID0gdm9pZCAwO1xuXG52YXIgX29wdGlvblBhcnNlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcGFyc2VyL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy9wYXJzZXIvb3B0aW9uLXBhcnNlci5qc1wiKSk7XG5cbnZhciBPdXRwdXRGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzXCIpKTtcblxudmFyIF9oZWFkX3RhaWxfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvbW1hbmRzL3V0aWwvX2hlYWRfdGFpbF91dGlsLmpzICovIFwiLi9zcmMvY29tbWFuZHMvdXRpbC9faGVhZF90YWlsX3V0aWwuanNcIik7XG5cbnZhciBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL3V0aWwgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS91dGlsLmpzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBQcmludHMgdGhlIGxhc3QgbiBsaW5lcyBvZiBhIGZpbGVcbiAqIFVzYWdlOiB0YWlsIC1uIDUgZmlsZS50eHRcbiAqL1xudmFyIG9wdERlZiA9IHtcbiAgJy1uLCAtLWxpbmVzJzogJzxjb3VudD4nXG59O1xuZXhwb3J0cy5vcHREZWYgPSBvcHREZWY7XG5cbnZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KHN0YXRlLCBjb21tYW5kT3B0aW9ucykge1xuICB2YXIgX3BhcnNlT3B0aW9ucyA9ICgwLCBfb3B0aW9uUGFyc2VyW1wiZGVmYXVsdFwiXSkoY29tbWFuZE9wdGlvbnMsIG9wdERlZiksXG4gICAgICBhcmd2ID0gX3BhcnNlT3B0aW9ucy5hcmd2LFxuICAgICAgb3B0aW9ucyA9IF9wYXJzZU9wdGlvbnMub3B0aW9ucztcblxuICBpZiAoYXJndi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2YXIgZmlsZVBhdGggPSAoMCwgX3V0aWwucmVzb2x2ZVBhdGgpKHN0YXRlLCBhcmd2WzBdKTtcblxuICB2YXIgdGFpbFRyaW1taW5nRm4gPSBmdW5jdGlvbiB0YWlsVHJpbW1pbmdGbihsaW5lcywgbGluZUNvdW50KSB7XG4gICAgcmV0dXJuIGxpbmVzLnNsaWNlKC0xICogbGluZUNvdW50KTtcbiAgfTtcblxuICB2YXIgX3RyaW1GaWxlQ29udGVudCA9ICgwLCBfaGVhZF90YWlsX3V0aWwudHJpbUZpbGVDb250ZW50KShzdGF0ZS5nZXRGaWxlU3lzdGVtKCksIGZpbGVQYXRoLCBvcHRpb25zLCB0YWlsVHJpbW1pbmdGbiksXG4gICAgICBjb250ZW50ID0gX3RyaW1GaWxlQ29udGVudC5jb250ZW50LFxuICAgICAgZXJyID0gX3RyaW1GaWxlQ29udGVudC5lcnI7XG5cbiAgaWYgKGVycikge1xuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXQ6IE91dHB1dEZhY3RvcnkubWFrZUVycm9yT3V0cHV0KGVycilcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRwdXQ6IE91dHB1dEZhY3RvcnkubWFrZVRleHRPdXRwdXQoY29udGVudClcbiAgfTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbW1hbmRzL3RvdWNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1hbmRzL3RvdWNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5vcHREZWYgPSB2b2lkIDA7XG5cbnZhciBfb3B0aW9uUGFyc2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBwYXJzZXIvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3BhcnNlci9vcHRpb24tcGFyc2VyLmpzXCIpKTtcblxudmFyIEZpbGVPcCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMtd2l0aC1wZXJtaXNzaW9ucy9maWxlLW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZmlsZS1vcGVyYXRpb25zLmpzXCIpKTtcblxudmFyIE91dHB1dEZhY3RvcnkgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1vdXRwdXQvb3V0cHV0LWZhY3RvcnkgKi8gXCIuL3NyYy9lbXVsYXRvci1vdXRwdXQvb3V0cHV0LWZhY3RvcnkuanNcIikpO1xuXG52YXIgRmlsZVV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy91dGlsL2ZpbGUtdXRpbCAqLyBcIi4vc3JjL2ZzL3V0aWwvZmlsZS11dGlsLmpzXCIpKTtcblxudmFyIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itc3RhdGUvdXRpbCAqLyBcIi4vc3JjL2VtdWxhdG9yLXN0YXRlL3V0aWwuanNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgZmlsZS5cbiAqIFVzYWdlOiB0b3VjaCBuZXdfZmlsZS50eHRcbiAqL1xudmFyIEVNUFRZX0ZJTEUgPSBGaWxlVXRpbC5tYWtlRmlsZSgpO1xudmFyIG9wdERlZiA9IHt9O1xuZXhwb3J0cy5vcHREZWYgPSBvcHREZWY7XG5cbnZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KHN0YXRlLCBjb21tYW5kT3B0aW9ucykge1xuICB2YXIgX3BhcnNlT3B0aW9ucyA9ICgwLCBfb3B0aW9uUGFyc2VyW1wiZGVmYXVsdFwiXSkoY29tbWFuZE9wdGlvbnMsIG9wdERlZiksXG4gICAgICBhcmd2ID0gX3BhcnNlT3B0aW9ucy5hcmd2O1xuXG4gIGlmIChhcmd2Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7fTsgLy8gZG8gbm90aGluZyBpZiBubyBhcmd1bWVudHMgYXJlIGdpdmVuXG4gIH1cblxuICB2YXIgZmlsZVBhdGggPSAoMCwgX3V0aWwucmVzb2x2ZVBhdGgpKHN0YXRlLCBhcmd2WzBdKTtcblxuICBpZiAoc3RhdGUuZ2V0RmlsZVN5c3RlbSgpLmhhcyhmaWxlUGF0aCkpIHtcbiAgICByZXR1cm4ge307IC8vIGRvIG5vdGhpbmcgaWYgYWxyZWFkeSBoYXMgYSBmaWxlIGF0IHRoZSBwcm92aWRlZCBwYXRoXG4gIH1cblxuICB2YXIgX0ZpbGVPcCR3cml0ZUZpbGUgPSBGaWxlT3Aud3JpdGVGaWxlKHN0YXRlLmdldEZpbGVTeXN0ZW0oKSwgZmlsZVBhdGgsIEVNUFRZX0ZJTEUpLFxuICAgICAgZnMgPSBfRmlsZU9wJHdyaXRlRmlsZS5mcyxcbiAgICAgIGVyciA9IF9GaWxlT3Akd3JpdGVGaWxlLmVycjtcblxuICBpZiAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogT3V0cHV0RmFjdG9yeS5tYWtlRXJyb3JPdXRwdXQoZXJyKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXRlOiBzdGF0ZS5zZXRGaWxlU3lzdGVtKGZzKVxuICB9O1xufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tbWFuZHMvdXRpbC9faGVhZF90YWlsX3V0aWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tbWFuZHMvdXRpbC9faGVhZF90YWlsX3V0aWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy50cmltRmlsZUNvbnRlbnQgPSB2b2lkIDA7XG5cbnZhciBGaWxlT3AgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZmlsZS1vcGVyYXRpb25zICovIFwiLi9zcmMvZnMvb3BlcmF0aW9ucy13aXRoLXBlcm1pc3Npb25zL2ZpbGUtb3BlcmF0aW9ucy5qc1wiKSk7XG5cbnZhciBPdXRwdXRGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxudmFyIERFRkFVTFRfTElORV9DT1VOVCA9IDEwO1xuXG52YXIgdHJpbUZpbGVDb250ZW50ID0gZnVuY3Rpb24gdHJpbUZpbGVDb250ZW50KGZzLCBmaWxlUGF0aCwgb3B0aW9ucywgdHJpbW1pbmdGbikge1xuICB2YXIgX0ZpbGVPcCRyZWFkRmlsZSA9IEZpbGVPcC5yZWFkRmlsZShmcywgZmlsZVBhdGgpLFxuICAgICAgZmlsZSA9IF9GaWxlT3AkcmVhZEZpbGUuZmlsZSxcbiAgICAgIGVyciA9IF9GaWxlT3AkcmVhZEZpbGUuZXJyO1xuXG4gIGlmIChlcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyOiBPdXRwdXRGYWN0b3J5Lm1ha2VFcnJvck91dHB1dChlcnIpXG4gICAgfTtcbiAgfVxuXG4gIDtcbiAgdmFyIGxpbmVzQ291bnQgPSBvcHRpb25zLmxpbmVzID8gTnVtYmVyKG9wdGlvbnMubGluZXMpIDogREVGQVVMVF9MSU5FX0NPVU5UO1xuICB2YXIgdHJpbW1lZExpbmVzID0gdHJpbW1pbmdGbihmaWxlLmdldCgnY29udGVudCcpLnNwbGl0KCdcXG4nKSwgbGluZXNDb3VudCk7XG4gIHJldHVybiB7XG4gICAgY29udGVudDogdHJpbW1lZExpbmVzLmpvaW4oJ1xcbicpXG4gIH07XG59O1xuXG5leHBvcnRzLnRyaW1GaWxlQ29udGVudCA9IHRyaW1GaWxlQ29udGVudDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tbWFuZHMvd2hvYW1pLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tYW5kcy93aG9hbWkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5vcHREZWYgPSB2b2lkIDA7XG5cbnZhciBPdXRwdXRGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzXCIpKTtcblxudmFyIF9lbnZpcm9ubWVudFZhcmlhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL2Vudmlyb25tZW50LXZhcmlhYmxlcyAqLyBcIi4vc3JjL2VtdWxhdG9yLXN0YXRlL2Vudmlyb25tZW50LXZhcmlhYmxlcy5qc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXG4gKiBQcmludHMgdGhlIHVzZXJuYW1lIG9mIHRoZSBsb2dnZWQgaW4gdXNlclxuICogVXNhZ2U6IHdob2FtaVxuICovXG52YXIgRkFMTEJBQ0tfVVNFUk5BTUUgPSAncm9vdCc7XG52YXIgb3B0RGVmID0ge307XG5leHBvcnRzLm9wdERlZiA9IG9wdERlZjtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoc3RhdGUsIGNvbW1hbmRPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgb3V0cHV0OiBPdXRwdXRGYWN0b3J5Lm1ha2VUZXh0T3V0cHV0KCgwLCBfZW52aXJvbm1lbnRWYXJpYWJsZXMuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoc3RhdGUuZ2V0RW52VmFyaWFibGVzKCksICd1c2VyJykgfHwgRkFMTEJBQ0tfVVNFUk5BTUUpXG4gIH07XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9lbXVsYXRvci1vdXRwdXQvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2VtdWxhdG9yLW91dHB1dC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBPdXRwdXRGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzXCIpKTtcblxudmFyIE91dHB1dFR5cGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1vdXRwdXQvb3V0cHV0LXR5cGUgKi8gXCIuL3NyYy9lbXVsYXRvci1vdXRwdXQvb3V0cHV0LXR5cGUuanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG52YXIgX2RlZmF1bHQgPSB7XG4gIE91dHB1dEZhY3Rvcnk6IE91dHB1dEZhY3RvcnksXG4gIE91dHB1dFR5cGU6IE91dHB1dFR5cGVcbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2VtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlRXJyb3JPdXRwdXQgPSBleHBvcnRzLm1ha2VUZXh0T3V0cHV0ID0gZXhwb3J0cy5tYWtlSGVhZGVyT3V0cHV0ID0gZXhwb3J0cy5PdXRwdXRSZWNvcmQgPSB2b2lkIDA7XG5cbnZhciBfaW1tdXRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgaW1tdXRhYmxlICovIFwiLi9ub2RlX21vZHVsZXMvaW1tdXRhYmxlL2Rpc3QvaW1tdXRhYmxlLmVzLmpzXCIpO1xuXG52YXIgX291dHB1dFR5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1vdXRwdXQvb3V0cHV0LXR5cGUgKi8gXCIuL3NyYy9lbXVsYXRvci1vdXRwdXQvb3V0cHV0LXR5cGUuanNcIik7XG5cbi8qKlxuICogT3V0cHV0IGZyb20gYSBjb21tYW5kIG9yIGVtdWxhdG9yIHVzZWQgZm9yIGRpc3BsYXkgdG8gdGhlIHVzZXJcbiAqIEB0eXBlIHtPdXRwdXRSZWNvcmR9XG4gKi9cbnZhciBPdXRwdXRSZWNvcmQgPSAoMCwgX2ltbXV0YWJsZS5SZWNvcmQpKHtcbiAgdHlwZTogdW5kZWZpbmVkLFxuICBjb250ZW50OiB1bmRlZmluZWRcbn0pO1xuLyoqXG4gKiBBIHRlcm1pbmFsIGhlYWRlciBjb250YWluaW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGN3ZCAgIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IHBhdGhcbiAqIEByZXR1cm4ge091dHB1dFJlY29yZH0gb3V0cHV0IHJlY29yZFxuICovXG5cbmV4cG9ydHMuT3V0cHV0UmVjb3JkID0gT3V0cHV0UmVjb3JkO1xuXG52YXIgbWFrZUhlYWRlck91dHB1dCA9IGZ1bmN0aW9uIG1ha2VIZWFkZXJPdXRwdXQoY3dkLCBjb21tYW5kKSB7XG4gIHJldHVybiBuZXcgT3V0cHV0UmVjb3JkKHtcbiAgICB0eXBlOiBfb3V0cHV0VHlwZS5IRUFERVJfT1VUUFVUX1RZUEUsXG4gICAgY29udGVudDoge1xuICAgICAgY3dkOiBjd2QsXG4gICAgICBjb21tYW5kOiBjb21tYW5kXG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIFVuc3R5bGVkIHRleHQgb3V0cHV0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRlbnQgcGxhaW4gc3RyaW5nIG91dHB1dCBmcm9tIGEgY29tbWFuZCBvciB0aGUgZW11bGF0b3JcbiAqIEByZXR1cm4ge091dHB1dFJlY29yZH0gICBvdXRwdXQgcmVjb3JkXG4gKi9cblxuXG5leHBvcnRzLm1ha2VIZWFkZXJPdXRwdXQgPSBtYWtlSGVhZGVyT3V0cHV0O1xuXG52YXIgbWFrZVRleHRPdXRwdXQgPSBmdW5jdGlvbiBtYWtlVGV4dE91dHB1dChjb250ZW50KSB7XG4gIHJldHVybiBuZXcgT3V0cHV0UmVjb3JkKHtcbiAgICB0eXBlOiBfb3V0cHV0VHlwZS5URVhUX09VVFBVVF9UWVBFLFxuICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgfSk7XG59O1xuLyoqXG4gKiBFcnJvciB0ZXh0IG91dHB1dFxuICogQHBhcmFtICB7b2JqZWN0fSBlcnIgaW50ZXJuYWwgZXJyb3Igb2JqZWN0XG4gKiBAcmV0dXJuIHtPdXRwdXRSZWNvcmR9ICAgb3V0cHV0IHJlY29yZFxuICovXG5cblxuZXhwb3J0cy5tYWtlVGV4dE91dHB1dCA9IG1ha2VUZXh0T3V0cHV0O1xuXG52YXIgbWFrZUVycm9yT3V0cHV0ID0gZnVuY3Rpb24gbWFrZUVycm9yT3V0cHV0KGVycikge1xuICByZXR1cm4gbmV3IE91dHB1dFJlY29yZCh7XG4gICAgdHlwZTogX291dHB1dFR5cGUuVEVYVF9FUlJPUl9PVVRQVVRfVFlQRSxcbiAgICBjb250ZW50OiBcIlwiLmNvbmNhdChlcnIuc291cmNlLCBcIjogXCIpLmNvbmNhdChlcnIudHlwZSlcbiAgfSk7XG59O1xuXG5leHBvcnRzLm1ha2VFcnJvck91dHB1dCA9IG1ha2VFcnJvck91dHB1dDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC10eXBlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9lbXVsYXRvci1vdXRwdXQvb3V0cHV0LXR5cGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkhFQURFUl9PVVRQVVRfVFlQRSA9IGV4cG9ydHMuVEVYVF9FUlJPUl9PVVRQVVRfVFlQRSA9IGV4cG9ydHMuVEVYVF9PVVRQVVRfVFlQRSA9IHZvaWQgMDtcblxuLyoqXG4gKiBUeXBlcyBvZiBvdXRwdXQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBjb250ZW50IHRvIHRoZSB1c2VyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG52YXIgVEVYVF9PVVRQVVRfVFlQRSA9ICdURVhUX09VVFBVVCc7XG5leHBvcnRzLlRFWFRfT1VUUFVUX1RZUEUgPSBURVhUX09VVFBVVF9UWVBFO1xudmFyIFRFWFRfRVJST1JfT1VUUFVUX1RZUEUgPSAnVEVYVF9FUlJPUl9PVVRQVVQnO1xuZXhwb3J0cy5URVhUX0VSUk9SX09VVFBVVF9UWVBFID0gVEVYVF9FUlJPUl9PVVRQVVRfVFlQRTtcbnZhciBIRUFERVJfT1VUUFVUX1RZUEUgPSAnSEVBREVSX09VVFBVVF9UWVBFJztcbmV4cG9ydHMuSEVBREVSX09VVFBVVF9UWVBFID0gSEVBREVSX09VVFBVVF9UWVBFO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9FbXVsYXRvclN0YXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZW11bGF0b3Itc3RhdGUvRW11bGF0b3JTdGF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9pbW11dGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBpbW11dGFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9pbW11dGFibGUvZGlzdC9pbW11dGFibGUuZXMuanNcIik7XG5cbnZhciBfY29tbWFuZE1hcHBpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9jb21tYW5kLW1hcHBpbmcgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9jb21tYW5kLW1hcHBpbmcuanNcIik7XG5cbnZhciBfZW52aXJvbm1lbnRWYXJpYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMuanNcIik7XG5cbnZhciBfZmlsZVN5c3RlbSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL2ZpbGUtc3lzdGVtICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvZmlsZS1zeXN0ZW0uanNcIik7XG5cbnZhciBfaGlzdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL2hpc3RvcnkgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9oaXN0b3J5LmpzXCIpO1xuXG52YXIgX291dHB1dHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9vdXRwdXRzICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvb3V0cHV0cy5qc1wiKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgRlNfS0VZID0gJ2ZzJztcbnZhciBFTlZJUk9OTUVOVF9WQVJJQUJMRVNfS0VZID0gJ2Vudmlyb25tZW50VmFyaWFibGVzJztcbnZhciBISVNUT1JZX0tFWSA9ICdoaXN0b3J5JztcbnZhciBPVVRQVVRTX0tFWSA9ICdvdXRwdXRzJztcbnZhciBDT01NQU5EX01BUFBJTkdfS0VZID0gJ2NvbW1hbmRNYXBwaW5nJztcblxudmFyIEVtdWxhdG9yU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbXVsYXRvclN0YXRlKGltbXV0YWJsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbXVsYXRvclN0YXRlKTtcblxuICAgIGlmICghaW1tdXRhYmxlIHx8ICEoaW1tdXRhYmxlIGluc3RhbmNlb2YgX2ltbXV0YWJsZS5NYXApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvIG5vdCB1c2UgdGhlIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBVc2UgdGhlIHN0YXRpYyBjcmVhdGUgbWV0aG9kLicpO1xuICAgIH1cblxuICAgIHRoaXMuX2ltbXV0YWJsZSA9IGltbXV0YWJsZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBlbXVsYXRvciBzdGF0ZSB3aXRoIGRlZmF1bHRzXG4gICAqIEByZXR1cm4ge0VtdWxhdG9yU3RhdGV9IGRlZmF1bHQgZW11bGF0b3Igc3RhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRW11bGF0b3JTdGF0ZSwgW3tcbiAgICBrZXk6IFwiZ2V0RmlsZVN5c3RlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWxlU3lzdGVtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW1tdXRhYmxlKCkuZ2V0KEZTX0tFWSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZpbGVTeXN0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmlsZVN5c3RlbShuZXdGaWxlU3lzdGVtKSB7XG4gICAgICByZXR1cm4gbmV3IEVtdWxhdG9yU3RhdGUodGhpcy5nZXRJbW11dGFibGUoKS5zZXQoRlNfS0VZLCBuZXdGaWxlU3lzdGVtKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVudlZhcmlhYmxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbnZWYXJpYWJsZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbW11dGFibGUoKS5nZXQoRU5WSVJPTk1FTlRfVkFSSUFCTEVTX0tFWSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEVudlZhcmlhYmxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRFbnZWYXJpYWJsZXMobmV3RW52VmFyaWFibGVzKSB7XG4gICAgICByZXR1cm4gbmV3IEVtdWxhdG9yU3RhdGUodGhpcy5nZXRJbW11dGFibGUoKS5zZXQoRU5WSVJPTk1FTlRfVkFSSUFCTEVTX0tFWSwgbmV3RW52VmFyaWFibGVzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEhpc3RvcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGlzdG9yeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEltbXV0YWJsZSgpLmdldChISVNUT1JZX0tFWSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEhpc3RvcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SGlzdG9yeShuZXdIaXN0b3J5KSB7XG4gICAgICByZXR1cm4gbmV3IEVtdWxhdG9yU3RhdGUodGhpcy5nZXRJbW11dGFibGUoKS5zZXQoSElTVE9SWV9LRVksIG5ld0hpc3RvcnkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3V0cHV0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPdXRwdXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW1tdXRhYmxlKCkuZ2V0KE9VVFBVVFNfS0VZKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3V0cHV0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPdXRwdXRzKG5ld091dHB1dHMpIHtcbiAgICAgIHJldHVybiBuZXcgRW11bGF0b3JTdGF0ZSh0aGlzLmdldEltbXV0YWJsZSgpLnNldChPVVRQVVRTX0tFWSwgbmV3T3V0cHV0cykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb21tYW5kTWFwcGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb21tYW5kTWFwcGluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEltbXV0YWJsZSgpLmdldChDT01NQU5EX01BUFBJTkdfS0VZKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29tbWFuZE1hcHBpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29tbWFuZE1hcHBpbmcobmV3Q29tbWFuZE1hcHBpbmcpIHtcbiAgICAgIHJldHVybiBuZXcgRW11bGF0b3JTdGF0ZSh0aGlzLmdldEltbXV0YWJsZSgpLnNldChDT01NQU5EX01BUFBJTkdfS0VZLCBuZXdDb21tYW5kTWFwcGluZykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbW11dGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW1tdXRhYmxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ltbXV0YWJsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ltbXV0YWJsZS50b0pTKCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlRW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRW1wdHkoKSB7XG4gICAgICByZXR1cm4gRW11bGF0b3JTdGF0ZS5jcmVhdGUoe30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGVtdWxhdG9yIHN0YXRlIHVzaW5nIHRoZSB1c2VyJ3Mgc3RhdGUgY29tcG9uZW50cywgb3IgYSBkZWZhdWx0XG4gICAgICogZmFsbGJhY2sgaWYgbm9uZSBpcyBwcm92aWRlZFxuICAgICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9uYWxseSBjb250YWlucyBlYWNoIGNvbXBvbmVudCBhcyBhIGtleSBhbmQgdGhlIGNvbXBvbmVudCBhcyBhIHZhbHVlXG4gICAgICogQHJldHVybiB7RW11bGF0b3JTdGF0ZX0gICAgIGVtdWxhdG9yIHN0YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgIHZhciBfTWFwO1xuXG4gICAgICB2YXIgX3JlZiRmcyA9IF9yZWYuZnMsXG4gICAgICAgICAgZnMgPSBfcmVmJGZzID09PSB2b2lkIDAgPyAoMCwgX2ZpbGVTeXN0ZW0uY3JlYXRlKSgpIDogX3JlZiRmcyxcbiAgICAgICAgICBfcmVmJGVudmlyb25tZW50VmFyaWEgPSBfcmVmLmVudmlyb25tZW50VmFyaWFibGVzLFxuICAgICAgICAgIGVudmlyb25tZW50VmFyaWFibGVzID0gX3JlZiRlbnZpcm9ubWVudFZhcmlhID09PSB2b2lkIDAgPyAoMCwgX2Vudmlyb25tZW50VmFyaWFibGVzLmNyZWF0ZSkoKSA6IF9yZWYkZW52aXJvbm1lbnRWYXJpYSxcbiAgICAgICAgICBfcmVmJGhpc3RvcnkgPSBfcmVmLmhpc3RvcnksXG4gICAgICAgICAgaGlzdG9yeSA9IF9yZWYkaGlzdG9yeSA9PT0gdm9pZCAwID8gKDAsIF9oaXN0b3J5LmNyZWF0ZSkoKSA6IF9yZWYkaGlzdG9yeSxcbiAgICAgICAgICBfcmVmJG91dHB1dHMgPSBfcmVmLm91dHB1dHMsXG4gICAgICAgICAgb3V0cHV0cyA9IF9yZWYkb3V0cHV0cyA9PT0gdm9pZCAwID8gKDAsIF9vdXRwdXRzLmNyZWF0ZSkoKSA6IF9yZWYkb3V0cHV0cyxcbiAgICAgICAgICBfcmVmJGNvbW1hbmRNYXBwaW5nID0gX3JlZi5jb21tYW5kTWFwcGluZyxcbiAgICAgICAgICBjb21tYW5kTWFwcGluZyA9IF9yZWYkY29tbWFuZE1hcHBpbmcgPT09IHZvaWQgMCA/ICgwLCBfY29tbWFuZE1hcHBpbmcuY3JlYXRlKSgpIDogX3JlZiRjb21tYW5kTWFwcGluZztcbiAgICAgIHZhciBzdGF0ZU1hcCA9IG5ldyBfaW1tdXRhYmxlLk1hcCgoX01hcCA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX01hcCwgRlNfS0VZLCBmcyksIF9kZWZpbmVQcm9wZXJ0eShfTWFwLCBFTlZJUk9OTUVOVF9WQVJJQUJMRVNfS0VZLCBlbnZpcm9ubWVudFZhcmlhYmxlcyksIF9kZWZpbmVQcm9wZXJ0eShfTWFwLCBISVNUT1JZX0tFWSwgaGlzdG9yeSksIF9kZWZpbmVQcm9wZXJ0eShfTWFwLCBPVVRQVVRTX0tFWSwgb3V0cHV0cyksIF9kZWZpbmVQcm9wZXJ0eShfTWFwLCBDT01NQU5EX01BUFBJTkdfS0VZLCBjb21tYW5kTWFwcGluZyksIF9NYXApKTtcbiAgICAgIHJldHVybiBuZXcgRW11bGF0b3JTdGF0ZShzdGF0ZU1hcCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVtdWxhdG9yU3RhdGU7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRW11bGF0b3JTdGF0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9jb21tYW5kLW1hcHBpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2VtdWxhdG9yLXN0YXRlL2NvbW1hbmQtbWFwcGluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0Q29tbWFuZE5hbWVzID0gZXhwb3J0cy5nZXRDb21tYW5kT3B0RGVmID0gZXhwb3J0cy5nZXRDb21tYW5kRm4gPSBleHBvcnRzLnVuc2V0Q29tbWFuZCA9IGV4cG9ydHMuc2V0Q29tbWFuZCA9IGV4cG9ydHMuaXNDb21tYW5kU2V0ID0gZXhwb3J0cy5jcmVhdGUgPSB2b2lkIDA7XG5cbnZhciBfaW1tdXRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgaW1tdXRhYmxlICovIFwiLi9ub2RlX21vZHVsZXMvaW1tdXRhYmxlL2Rpc3QvaW1tdXRhYmxlLmVzLmpzXCIpO1xuXG52YXIgX2NvbW1hbmRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb21tYW5kcyAqLyBcIi4vc3JjL2NvbW1hbmRzL2luZGV4LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogTGlua3MgYSBjb21tYW5kIG5hbWUgdG8gYSBmdW5jdGlvblxuICogQHBhcmFtICB7T2JqZWN0fSBbY29tbWFuZE1hcHBpbmc9e31dIGRlZmF1bHQgY29tbWFuZCBtYXBcbiAqIEByZXR1cm4ge01hcH0gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kIG1hcHBpbmdcbiAqL1xudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIGNvbW1hbmRNYXBwaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfY29tbWFuZHNbXCJkZWZhdWx0XCJdO1xuXG4gIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMoY29tbWFuZE1hcHBpbmcpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgY29tbWFuZE5hbWUgPSBfT2JqZWN0JGtleXNbX2ldO1xuICAgIHZhciBjb21tYW5kID0gY29tbWFuZE1hcHBpbmdbY29tbWFuZE5hbWVdO1xuXG4gICAgaWYgKCFjb21tYW5kLmhhc093blByb3BlcnR5KCdmdW5jdGlvbicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNvbW1hbmQgbWFwcGluZzogbWlzc2luZyBjb21tYW5kIGZ1bmN0aW9uIGZvciBcIi5jb25jYXQoY29tbWFuZE5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbW1hbmQuaGFzT3duUHJvcGVydHkoJ29wdERlZicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNvbW1hbmQgbWFwcGluZzogbWlzc2luZyBvcHRpb24gZGVmaW5pdGlvbiAob3B0RGVmKSBmb3IgXCIuY29uY2F0KGNvbW1hbmROYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICgwLCBfaW1tdXRhYmxlLmZyb21KUykoY29tbWFuZE1hcHBpbmcpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgY29tYW5kIGhhcyBiZWVuIGRlZmluZWQgd2l0aCBhIGZ1bmN0aW9uIGluIHRoZSBjb21tYW5kIG1hcHBpbmdcbiAqIEBwYXJhbSAge01hcH0gICAgIGNvbW1hbmRNYXBwaW5nIGNvbW1hbmQgbWFwcGluZ1xuICogQHBhcmFtICB7c3RyaW5nfSAgY29tbWFuZE5hbWUgICAgY29tbWFuZCBuYW1lIHRvIGNoZWNrIGlmIGF2YWlsYWJsZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgdHJ1ZSwgaWYgdGhlIGNvbW1hbmQgaXMgYXZhaWxhYmxlXG4gKi9cblxuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcblxudmFyIGlzQ29tbWFuZFNldCA9IGZ1bmN0aW9uIGlzQ29tbWFuZFNldChjb21tYW5kTWFwcGluZywgY29tbWFuZE5hbWUpIHtcbiAgcmV0dXJuIGNvbW1hbmRNYXBwaW5nLmhhcyhjb21tYW5kTmFtZSk7XG59O1xuLyoqXG4gKiBTZXQgYSBjb21tYW5kIGZ1bmN0aW9uIHdpdGggYSBrZXkgb2YgdGhlIGNvbW1hbmQgbmFtZSBpbnRvIHRoZSBjb21tYW5kIG1hcHBpbmdcbiAqIEBwYXJhbSAge01hcH0gICAgICBjb21tYW5kTWFwcGluZyBjb21tYW5kIG1hcHBpbmdcbiAqIEBwYXJhbSAge3N0cmluZ30gICBjb21tYW5kTmFtZSAgICBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNvbW1hbmRGbiAgICAgIGNvbW1hbmQgZnVuY3Rpb25cbiAqIEBwYXJhbSAge29iamVjdH0gICBvcHREZWYgICAgICAgICBvcHRpb24gZGVmaW5pdGlvbiAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtNYXB9ICAgICAgICAgICAgICAgICAgICAgY29tbWFuZCBtYXBwaW5nXG4gKi9cblxuXG5leHBvcnRzLmlzQ29tbWFuZFNldCA9IGlzQ29tbWFuZFNldDtcblxudmFyIHNldENvbW1hbmQgPSBmdW5jdGlvbiBzZXRDb21tYW5kKGNvbW1hbmRNYXBwaW5nLCBjb21tYW5kTmFtZSwgY29tbWFuZEZuLCBvcHREZWYpIHtcbiAgaWYgKGNvbW1hbmRGbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBcIi5jb25jYXQoY29tbWFuZE5hbWUsIFwiIGNvbW1hbmQgd2l0aG91dCBmdW5jdGlvblwiKSk7XG4gIH1cblxuICBpZiAob3B0RGVmID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IFwiLmNvbmNhdChjb21tYW5kTmFtZSwgXCIgY29tbWFuZCB3aXRob3V0IG9wdERlZiAocGFzcyBpbiB7fSBpZiB0aGUgY29tbWFuZCB0YWtlcyBubyBvcHRpb25zKVwiKSk7XG4gIH1cblxuICByZXR1cm4gY29tbWFuZE1hcHBpbmcuc2V0KGNvbW1hbmROYW1lLCAoMCwgX2ltbXV0YWJsZS5mcm9tSlMpKHtcbiAgICAnZnVuY3Rpb24nOiBjb21tYW5kRm4sXG4gICAgJ29wdERlZic6IG9wdERlZlxuICB9KSk7XG59O1xuLyoqXG4gKiBSZW1vdmVzIGEgY29tbWFuZCBuYW1lIGFuZCBpdHMgZnVuY3Rpb24gZnJvbSBhIGNvbW1hbmQgbWFwcGluZ1xuICogQHBhcmFtICB7TWFwfSAgICBjb21tYW5kTWFwcGluZyBjb21tYW5kIG1hcHBpbmdcbiAqIEBwYXJhbSAge3N0cmluZ30gY29tbWFuZE5hbWUgICAgbmFtZSBvZiBjb21tYW5kIHRvIHJlbW92ZVxuICogQHJldHVybiB7TWFwfSAgICAgICAgICAgICAgICAgICBjb21tYW5kIG1hcHBpbmdcbiAqL1xuXG5cbmV4cG9ydHMuc2V0Q29tbWFuZCA9IHNldENvbW1hbmQ7XG5cbnZhciB1bnNldENvbW1hbmQgPSBmdW5jdGlvbiB1bnNldENvbW1hbmQoY29tbWFuZE1hcHBpbmcsIGNvbW1hbmROYW1lKSB7XG4gIHJldHVybiBjb21tYW5kTWFwcGluZ1tcImRlbGV0ZVwiXShjb21tYW5kTmFtZSk7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBmdW5jdGlvbiBvZiBhIGNvbW1hbmQgYmFzZWQgb24gaXRzIGNvbW1hbmQgbmFtZSAodGhlIGtleSkgZnJvbSB0aGVcbiAqIGNvbW1hbmQgbWFwcGluZ1xuICogQHBhcmFtICB7TWFwfSAgICAgIGNvbW1hbmRNYXBwaW5nIGNvbW1hbmQgbWFwcGluZ1xuICogQHBhcmFtICB7c3RyaW5nfSAgIGNvbW1hbmROYW1lICAgIG5hbWUgb2YgY29tbWFuZFxuICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICAgICAgIGNvbW1hbmQgZnVuY3Rpb25cbiAqL1xuXG5cbmV4cG9ydHMudW5zZXRDb21tYW5kID0gdW5zZXRDb21tYW5kO1xuXG52YXIgZ2V0Q29tbWFuZEZuID0gZnVuY3Rpb24gZ2V0Q29tbWFuZEZuKGNvbW1hbmRNYXBwaW5nLCBjb21tYW5kTmFtZSkge1xuICBpZiAoY29tbWFuZE1hcHBpbmcuaGFzKGNvbW1hbmROYW1lKSkge1xuICAgIHJldHVybiBjb21tYW5kTWFwcGluZy5nZXQoY29tbWFuZE5hbWUpLmdldCgnZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBvcHRpb24gZGVmaW5pdGlvbiBvZiBhIGNvbW1hbmQgYmFzZWQgb24gaXRzIGNvbW1hbmQgbmFtZVxuICogQHBhcmFtICB7TWFwfSAgICAgIGNvbW1hbmRNYXBwaW5nIGNvbW1hbmQgbWFwcGluZ1xuICogQHBhcmFtICB7c3RyaW5nfSAgIGNvbW1hbmROYW1lICAgIG5hbWUgb2YgY29tbWFuZFxuICogQHJldHVybiB7TWFwfSAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiBkZWZpbml0aW9uXG4gKi9cblxuXG5leHBvcnRzLmdldENvbW1hbmRGbiA9IGdldENvbW1hbmRGbjtcblxudmFyIGdldENvbW1hbmRPcHREZWYgPSBmdW5jdGlvbiBnZXRDb21tYW5kT3B0RGVmKGNvbW1hbmRNYXBwaW5nLCBjb21tYW5kTmFtZSkge1xuICBpZiAoY29tbWFuZE1hcHBpbmcuaGFzKGNvbW1hbmROYW1lKSkge1xuICAgIHJldHVybiBjb21tYW5kTWFwcGluZy5nZXQoY29tbWFuZE5hbWUpLmdldCgnb3B0RGVmJyk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8qKlxuICogR2V0cyBjb21tYW5kIG5hbWVzXG4gKiBAcGFyYW0gIHtNYXB9ICAgICAgY29tbWFuZE1hcHBpbmcgY29tbWFuZCBtYXBwaW5nXG4gKiBAcmV0dXJuIHtTZXF9ICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2Ugb2YgY29tbWFuZCBuYW1lc1xuICovXG5cblxuZXhwb3J0cy5nZXRDb21tYW5kT3B0RGVmID0gZ2V0Q29tbWFuZE9wdERlZjtcblxudmFyIGdldENvbW1hbmROYW1lcyA9IGZ1bmN0aW9uIGdldENvbW1hbmROYW1lcyhjb21tYW5kTWFwcGluZykge1xuICByZXR1cm4gY29tbWFuZE1hcHBpbmcua2V5U2VxKCk7XG59O1xuXG5leHBvcnRzLmdldENvbW1hbmROYW1lcyA9IGdldENvbW1hbmROYW1lcztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvZW52aXJvbm1lbnQtdmFyaWFibGVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9lbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVuc2V0RW52aXJvbm1lbnRWYXJpYWJsZSA9IGV4cG9ydHMuc2V0RW52aXJvbm1lbnRWYXJpYWJsZSA9IGV4cG9ydHMuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSA9IGV4cG9ydHMuY3JlYXRlID0gdm9pZCAwO1xuXG52YXIgX2ltbXV0YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGltbXV0YWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2ltbXV0YWJsZS9kaXN0L2ltbXV0YWJsZS5lcy5qc1wiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogRW52aXJvbm1lbnQgdmFyaWFibGUgbWFwcGluZyBjb250YWluaW5nIGFyYml0YXJ5IGRhdGEgYWNjZXNzZWQgYnkgYW55XG4gKiBjb21tYW5kIG9yIHRoZSBlbXVsYXRvciBhcyBhIGtleS12YWx1ZSBwYWlyXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtkZWZhdWx0VmFyaWFibGVzPXt9XSBkZWZhdWx0IGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogQHJldHVybiB7TWFwfSAgICAgICAgICAgICAgICAgICAgICAgICAgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKi9cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBkZWZhdWx0VmFyaWFibGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGN3ZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJy8nO1xuXG4gIGlmICghY3dkICYmICFkZWZhdWx0VmFyaWFibGVzLmhhc093blByb3BlcnR5KCdjd2QnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLiBNaXNzaW5nICdjd2QnIChjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5KS5cIik7XG4gIH1cblxuICByZXR1cm4gKDAsIF9pbW11dGFibGUuTWFwKShfb2JqZWN0U3ByZWFkKHtcbiAgICAnY3dkJzogY3dkXG4gIH0sIGRlZmF1bHRWYXJpYWJsZXMpKTtcbn07XG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGFuIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiBAcGFyYW0gIHtNYXB9IGVudmlyb25tZW50VmFyaWFibGVzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogQHBhcmFtICB7c3RyaW5nfSBrZXkgICAgICAgICAgICAgICBuYW1lIG9mIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogQHJldHVybiB7VH0gICAgICAgICAgICAgICAgICAgICAgICB0aGUgdmFsdWUgc3RvcmVkIGluIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICovXG5cblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5cbnZhciBnZXRFbnZpcm9ubWVudFZhcmlhYmxlID0gZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShlbnZpcm9ubWVudFZhcmlhYmxlcywga2V5KSB7XG4gIHJldHVybiBlbnZpcm9ubWVudFZhcmlhYmxlcy5nZXQoa2V5KTtcbn07XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGFuIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiBAcGFyYW0ge01hcH0gZW52aXJvbm1lbnRWYXJpYWJsZXMgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5ICAgICAgICAgICAgICAgbmFtZSBvZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIEBwYXJhbSB7VH0gdmFsICAgICAgICAgICAgICAgICAgICB2YWx1ZSB0byBzdG9yZSBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIEByZXR1cm4ge01hcH0gICAgICAgICAgICAgICAgICAgICBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqL1xuXG5cbmV4cG9ydHMuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSA9IGdldEVudmlyb25tZW50VmFyaWFibGU7XG5cbnZhciBzZXRFbnZpcm9ubWVudFZhcmlhYmxlID0gZnVuY3Rpb24gc2V0RW52aXJvbm1lbnRWYXJpYWJsZShlbnZpcm9ubWVudFZhcmlhYmxlcywga2V5LCB2YWwpIHtcbiAgcmV0dXJuIGVudmlyb25tZW50VmFyaWFibGVzLnNldChrZXksIHZhbCk7XG59O1xuLyoqXG4gKiBSZW1vdmVzIGFuIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiBAcGFyYW0ge01hcH0gZW52aXJvbm1lbnRWYXJpYWJsZXMgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5ICAgICAgICAgICAgICAgbmFtZSBvZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIEByZXR1cm4ge01hcH0gICAgICAgICAgICAgICAgICAgICBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqL1xuXG5cbmV4cG9ydHMuc2V0RW52aXJvbm1lbnRWYXJpYWJsZSA9IHNldEVudmlyb25tZW50VmFyaWFibGU7XG5cbnZhciB1bnNldEVudmlyb25tZW50VmFyaWFibGUgPSBmdW5jdGlvbiB1bnNldEVudmlyb25tZW50VmFyaWFibGUoZW52aXJvbm1lbnRWYXJpYWJsZXMsIGtleSkge1xuICByZXR1cm4gZW52aXJvbm1lbnRWYXJpYWJsZXNbXCJkZWxldGVcIl0oa2V5KTtcbn07XG5cbmV4cG9ydHMudW5zZXRFbnZpcm9ubWVudFZhcmlhYmxlID0gdW5zZXRFbnZpcm9ubWVudFZhcmlhYmxlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9maWxlLXN5c3RlbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9lbXVsYXRvci1zdGF0ZS9maWxlLXN5c3RlbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IHZvaWQgMDtcblxudmFyIEZpbGVVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvdXRpbC9maWxlLXV0aWwgKi8gXCIuL3NyYy9mcy91dGlsL2ZpbGUtdXRpbC5qc1wiKSk7XG5cbnZhciBEaXJPcCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zL2RpcmVjdG9yeS1vcGVyYXRpb25zLmpzXCIpKTtcblxudmFyIF9pbW11dGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBpbW11dGFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9pbW11dGFibGUvZGlzdC9pbW11dGFibGUuZXMuanNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbnZhciBERUZBVUxUX0ZJTEVfU1lTVEVNID0ge1xuICAnLyc6IEZpbGVVdGlsLm1ha2VEaXJlY3RvcnkoKVxufTtcbi8qKlxuICogQ3JlYXRlcyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIGEgZmlsZSBzeXN0ZW1cbiAqIEBwYXJhbSAge29iamVjdH0ganNGcyBhIGZpbGUgc3lzdGVtIGluIGEgc2ltcGxlIEphdmFTY3JpcHQgb2JqZWN0XG4gKiBAcmV0dXJuIHtNYXB9ICAgICAgICAgYW4gaW1tdXRhYmxlIGZpbGUgc3lzdGVtXG4gKi9cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIGpzRnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IERFRkFVTFRfRklMRV9TWVNURU07XG4gIHJldHVybiBEaXJPcC5maWxsR2FwcygoMCwgX2ltbXV0YWJsZS5mcm9tSlMpKGpzRnMpKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9oaXN0b3J5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZW11bGF0b3Itc3RhdGUvaGlzdG9yeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlY29yZENvbW1hbmQgPSBleHBvcnRzLmNyZWF0ZSA9IHZvaWQgMDtcblxudmFyIF9pbW11dGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBpbW11dGFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9pbW11dGFibGUvZGlzdC9pbW11dGFibGUuZXMuanNcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGhpc3Rvcnkgc3RhY2sgb2YgcHJldmlvdXMgY29tbWFuZHMgdGhhdCBoYXZlIGJlZW4gcnVuIGluIHRoZVxuICogZW11bGF0b3JcbiAqIEBwYXJhbSAge2FycmF5fSAgW2VudHJpZXM9W11dIGNvbW1hbmRzIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIHJ1biAoaWYgYW55KVxuICogQHJldHVybiB7U3RhY2t9ICAgICAgICAgICAgICAgaGlzdG9yeSBsaXN0XG4gKi9cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBlbnRyaWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgcmV0dXJuIF9pbW11dGFibGUuU3RhY2sub2YuYXBwbHkoX2ltbXV0YWJsZS5TdGFjaywgX3RvQ29uc3VtYWJsZUFycmF5KGVudHJpZXMpKTtcbn07XG4vKipcbiAqIFN0b3JlcyBhIGNvbW1hbmQgaW4gaGlzdG9yeSBpbiBhIHN0YWNrIChpLmUuLCB0aGUgbGF0ZXN0IGNvbW1hbmQgaXMgb24gdG9wIG9mXG4gKiB0aGUgaGlzdG9yeSBzdGFjaylcbiAqIEBwYXJhbSAge1N0YWNrfSBoaXN0b3J5ICAgICBoaXN0b3J5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbW1hbmRSdW4gdGhlIGNvbW1hbmQgdG8gc3RvcmVcbiAqIEByZXR1cm4ge1N0YWNrfSAgICAgICAgICAgICBoaXN0b3J5XG4gKi9cblxuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcblxudmFyIHJlY29yZENvbW1hbmQgPSBmdW5jdGlvbiByZWNvcmRDb21tYW5kKGhpc3RvcnksIGNvbW1hbmRSdW4pIHtcbiAgcmV0dXJuIGhpc3RvcnkucHVzaChjb21tYW5kUnVuKTtcbn07XG5cbmV4cG9ydHMucmVjb3JkQ29tbWFuZCA9IHJlY29yZENvbW1hbmQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2VtdWxhdG9yLXN0YXRlL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2VtdWxhdG9yLXN0YXRlL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgQ29tbWFuZE1hcHBpbmcgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9jb21tYW5kLW1hcHBpbmcgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9jb21tYW5kLW1hcHBpbmcuanNcIikpO1xuXG52YXIgRW52aXJvbm1lbnRWYXJpYWJsZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9lbnZpcm9ubWVudC12YXJpYWJsZXMuanNcIikpO1xuXG52YXIgRmlsZVN5c3RlbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL2ZpbGUtc3lzdGVtICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvZmlsZS1zeXN0ZW0uanNcIikpO1xuXG52YXIgSGlzdG9yeSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL2hpc3RvcnkgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9oaXN0b3J5LmpzXCIpKTtcblxudmFyIE91dHB1dHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9vdXRwdXRzICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvb3V0cHV0cy5qc1wiKSk7XG5cbnZhciBfRW11bGF0b3JTdGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itc3RhdGUvRW11bGF0b3JTdGF0ZSAqLyBcIi4vc3JjL2VtdWxhdG9yLXN0YXRlL0VtdWxhdG9yU3RhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxudmFyIF9kZWZhdWx0ID0ge1xuICBFbXVsYXRvclN0YXRlOiBfRW11bGF0b3JTdGF0ZVtcImRlZmF1bHRcIl0sXG4gIENvbW1hbmRNYXBwaW5nOiBDb21tYW5kTWFwcGluZyxcbiAgRW52aXJvbm1lbnRWYXJpYWJsZXM6IEVudmlyb25tZW50VmFyaWFibGVzLFxuICBGaWxlU3lzdGVtOiBGaWxlU3lzdGVtLFxuICBIaXN0b3J5OiBIaXN0b3J5LFxuICBPdXRwdXRzOiBPdXRwdXRzXG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9vdXRwdXRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZW11bGF0b3Itc3RhdGUvb3V0cHV0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZFJlY29yZCA9IGV4cG9ydHMuY3JlYXRlID0gdm9pZCAwO1xuXG52YXIgX2ltbXV0YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGltbXV0YWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2ltbXV0YWJsZS9kaXN0L2ltbXV0YWJsZS5lcy5qc1wiKTtcblxuLyoqXG4gKiBTdG9yZXMgb3V0cHV0cyBmcm9tIHRoZSBlbXVsYXRvciAoZS5nLiB0ZXh0IHRvIGRpc3BsYXkgYWZ0ZXIgcnVubmluZyBhIGNvbW1hbmQpXG4gKiBAcGFyYW0gIHtBcnJheX0gIFtvdXRwdXRzPVtdXSBQcmV2aW91cyBvdXRwdXRzXG4gKiBAcmV0dXJuIHtMaXN0fSAgICAgICAgICAgICAgIExpc3Qgb2Ygb3V0cHV0cyBvYmplY3RzXG4gKi9cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXRwdXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgcmV0dXJuICgwLCBfaW1tdXRhYmxlLkxpc3QpKG91dHB1dHMpO1xufTtcbi8qKlxuICogQWRkcyBhIG5ldyBvdXRwdXQgcmVjb3JkXG4gKiBAcGFyYW0ge0xpc3R9ICAgICAgICAgb3V0cHV0cyAgICAgIG91dHB1dHMgbGlzdFxuICogQHBhcmFtIHtPdXRwdXRSZWNvcmR9IG91dHB1dFJlY29yZCByZWNvcmQgY29uZm9ybWluZyB0byBvdXRwdXQgc2NoZW1hXG4gKi9cblxuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcblxudmFyIGFkZFJlY29yZCA9IGZ1bmN0aW9uIGFkZFJlY29yZChvdXRwdXRzLCBvdXRwdXRSZWNvcmQpIHtcbiAgaWYgKCFfaW1tdXRhYmxlLlJlY29yZC5pc1JlY29yZChvdXRwdXRSZWNvcmQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHJlY29yZHMgb2YgdHlwZSBPdXRwdXRSZWNvcmQgY2FuIGJlIGFkZGVkIHRvIG91dHB1dHMnKTtcbiAgfVxuXG4gIGlmICghb3V0cHV0UmVjb3JkLmhhcygndHlwZScpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPdXRwdXQgcmVjb3JkIG11c3QgaW5jbHVkZSBhIHR5cGUnKTtcbiAgfVxuXG4gIGlmICghb3V0cHV0UmVjb3JkLmhhcygnY29udGVudCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPdXRwdXQgcmVjb3JkIG11c3QgaW5jbHVkZSBjb250ZW50Jyk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0cy5wdXNoKG91dHB1dFJlY29yZCk7XG59O1xuXG5leHBvcnRzLmFkZFJlY29yZCA9IGFkZFJlY29yZDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvdXRpbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2VtdWxhdG9yLXN0YXRlL3V0aWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlc29sdmVQYXRoID0gdm9pZCAwO1xuXG52YXIgRW52VmFyaWFibGVVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itc3RhdGUvZW52aXJvbm1lbnQtdmFyaWFibGVzICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvZW52aXJvbm1lbnQtdmFyaWFibGVzLmpzXCIpKTtcblxudmFyIFBhdGhVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvdXRpbC9wYXRoLXV0aWwgKi8gXCIuL3NyYy9mcy91dGlsL3BhdGgtdXRpbC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxuICogQ29udmVydHMgYSBnaXZlbiBwYXRoIHRvIGFuIGFic29sdXRlIHBhdGggdXNpbmcgdGhlXG4gKiBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5XG4gKiBAcGFyYW0gIHtFbXVsYXRvclN0YXRlfSBzdGF0ZSBlbXVsYXRvciBzdGF0ZVxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoICAgICAgICAgcGF0aCAocmVsYXRpdmUgb3IgYWJzb2x1dGUpXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgICBhYnNvbHV0ZSBwYXRoXG4gKi9cbnZhciByZXNvbHZlUGF0aCA9IGZ1bmN0aW9uIHJlc29sdmVQYXRoKHN0YXRlLCBwYXRoKSB7XG4gIHZhciBjd2QgPSBFbnZWYXJpYWJsZVV0aWwuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShzdGF0ZS5nZXRFbnZWYXJpYWJsZXMoKSwgJ2N3ZCcpO1xuICByZXR1cm4gUGF0aFV0aWwudG9BYnNvbHV0ZVBhdGgocGF0aCwgY3dkKTtcbn07XG5cbmV4cG9ydHMucmVzb2x2ZVBhdGggPSByZXNvbHZlUGF0aDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZW11bGF0b3IvYXV0by1jb21wbGV0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2VtdWxhdG9yL2F1dG8tY29tcGxldGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN1Z2dlc3RGaWxlU3lzdGVtTmFtZXMgPSBleHBvcnRzLnN1Z2dlc3RDb21tYW5kT3B0aW9ucyA9IGV4cG9ydHMuc3VnZ2VzdENvbW1hbmRzID0gdm9pZCAwO1xuXG52YXIgUGF0aFV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy91dGlsL3BhdGgtdXRpbCAqLyBcIi4vc3JjL2ZzL3V0aWwvcGF0aC11dGlsLmpzXCIpKTtcblxudmFyIEdsb2JVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvdXRpbC9nbG9iLXV0aWwgKi8gXCIuL3NyYy9mcy91dGlsL2dsb2ItdXRpbC5qc1wiKSk7XG5cbnZhciBfY29tbWFuZE1hcHBpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9jb21tYW5kLW1hcHBpbmcgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9jb21tYW5kLW1hcHBpbmcuanNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiBTdWdnZXN0IGNvbW1hbmQgbmFtZXNcbiAqIEBwYXJhbSAge01hcH0gICAgY21kTWFwcGluZyAgICAgY29tbWFuZCBtYXBwaW5nXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhcnRpYWxTdHIgICAgIHBhcnRpYWwgdXNlciBpbnB1dCBvZiBhIGNvbW1hbmRcbiAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgICAgbGlzdCBvZiBwb3NzaWJsZSB0ZXh0IHN1Z2dlc3Rpb25zXG4gKi9cbnZhciBzdWdnZXN0Q29tbWFuZHMgPSBmdW5jdGlvbiBzdWdnZXN0Q29tbWFuZHMoY21kTWFwcGluZywgcGFydGlhbFN0cikge1xuICB2YXIgY29tbWFuZE5hbWVTZXEgPSAoMCwgX2NvbW1hbmRNYXBwaW5nLmdldENvbW1hbmROYW1lcykoY21kTWFwcGluZyk7XG4gIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkoR2xvYlV0aWwuZ2xvYlNlcShjb21tYW5kTmFtZVNlcSwgXCJcIi5jb25jYXQocGFydGlhbFN0ciwgXCIqXCIpKSk7XG59O1xuLyoqXG4gKiBTdWdnZXN0IGNvbW1hbmQgb3B0aW9uc1xuICogQHBhcmFtICB7TWFwfSAgICBjbWRNYXBwaW5nICAgICBjb21tYW5kIG1hcHBpbmdcbiAqIEBwYXJhbSAge3N0cmluZ30gY29tbWFuZE5hbWUgICAgbmFtZSBvZiB0aGUgY29tbWFuZCB1c2VyIGlzIHJ1bm5pbmdcbiAqIEBwYXJhbSAge3N0cmluZ30gcGFydGlhbFN0ciAgICAgcGFydGlhbCB1c2VyIGlucHV0IG9mIGEgY29tbWFuZCAoZXhjbHVkaW5nIHRoZSBjb21tYW5kIG5hbWUpXG4gKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICAgIGxpc3Qgb2YgcG9zc2libGUgdGV4dCBzdWdnZXN0aW9uc1xuICovXG5cblxuZXhwb3J0cy5zdWdnZXN0Q29tbWFuZHMgPSBzdWdnZXN0Q29tbWFuZHM7XG5cbnZhciBzdWdnZXN0Q29tbWFuZE9wdGlvbnMgPSBmdW5jdGlvbiBzdWdnZXN0Q29tbWFuZE9wdGlvbnMoY21kTWFwcGluZywgY29tbWFuZE5hbWUsIHBhcnRpYWxTdHIpIHtcbiAgaWYgKCEoMCwgX2NvbW1hbmRNYXBwaW5nLmlzQ29tbWFuZFNldCkoY21kTWFwcGluZywgY29tbWFuZE5hbWUpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wdERlZlNlcSA9ICgwLCBfY29tbWFuZE1hcHBpbmcuZ2V0Q29tbWFuZE9wdERlZikoY21kTWFwcGluZywgY29tbWFuZE5hbWUpLmtleVNlcSgpLmZsYXRNYXAoZnVuY3Rpb24gKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAob3B0KSB7XG4gICAgICByZXR1cm4gb3B0LnRyaW0oKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkoR2xvYlV0aWwuZ2xvYlNlcShvcHREZWZTZXEsIFwiXCIuY29uY2F0KHBhcnRpYWxTdHIsIFwiKlwiKSkpO1xufTtcbi8qKlxuICogU3VnZ2VzdCBmaWxlIGFuZCBmb2xkZXIgbmFtZXMgZnJvbSBwYXJ0aWFsbHkgY29tcGxldGVkIHVzZXIgaW5wdXRcbiAqIEBwYXJhbSAge01hcH0gICAgZmlsZVN5c3RlbSBmaWxlIHN5c3RlbVxuICogQHBhcmFtICB7c3RyaW5nfSBjd2QgICAgICAgIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnlcbiAqIEBwYXJhbSAge3N0cmluZ30gcGFydGlhbFN0ciBwYXJ0aWFsIHN0cmluZyB0byBiYXNlIHN1Z2dlc3Rpb25zIG9uIChleGNsdWRpbmcgdGhlIGNvbW1hbmQgbmFtZSlcbiAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICBsaXN0IG9mIHBvc3NpYmxlIHRleHQgc3VnZ2VzdGlvbnNcbiAqL1xuXG5cbmV4cG9ydHMuc3VnZ2VzdENvbW1hbmRPcHRpb25zID0gc3VnZ2VzdENvbW1hbmRPcHRpb25zO1xuXG52YXIgc3VnZ2VzdEZpbGVTeXN0ZW1OYW1lcyA9IGZ1bmN0aW9uIHN1Z2dlc3RGaWxlU3lzdGVtTmFtZXMoZmlsZVN5c3RlbSwgY3dkLCBwYXJ0aWFsU3RyKSB7XG4gIHZhciBwYXRoID0gUGF0aFV0aWwudG9BYnNvbHV0ZVBhdGgocGFydGlhbFN0ciwgY3dkKTsgLy8gY29tcGxldGUgbmFtZSBvZiBhIGZvbGRlciBvciBmaWxlXG5cbiAgdmFyIGNvbXBsZXRlTmFtZVBhdHRlcm4gPSBcIlwiLmNvbmNhdChwYXRoLCBcIipcIik7IC8vIGNvbXBsZXRlIGNoaWxkIGZvbGRlciBuYW1lXG5cbiAgdmFyIGNvbXBsZXRlU3ViZm9sZGVyUGF0dGVybiA9IHBhdGggPT09ICcvJyA/ICcvKicgOiBcIlwiLmNvbmNhdChwYXRoLCBcIiovKlwiKTsgLy8gb25seSBjb21wbGV0ZSBjaGlsZCBmb2xkZXJzIHdoZW4gdGhlIHBhdGggZW5kcyB3aXRoIC8gKHdoaWNoIG1hcmtzIGEgZGlyZWN0b3J5IHBhdGgpXG5cbiAgdmFyIGdsb2JQYXR0ZXJuID0gcGFydGlhbFN0ci5lbmRzV2l0aCgnLycpID8gY29tcGxldGVTdWJmb2xkZXJQYXR0ZXJuIDogY29tcGxldGVOYW1lUGF0dGVybjtcbiAgdmFyIGNoaWxkUGF0aHMgPSBHbG9iVXRpbC5nbG9iUGF0aHMoZmlsZVN5c3RlbSwgZ2xvYlBhdHRlcm4pO1xuXG4gIGlmIChQYXRoVXRpbC5pc0Fic1BhdGgocGFydGlhbFN0cikpIHtcbiAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KGNoaWxkUGF0aHMpOyAvLyBhYnNvbHV0ZSBwYXRoc1xuICB9XG5cbiAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShjaGlsZFBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBwYXRoUGFydHNXaXRob3V0VGFpbCA9IFBhdGhVdGlsLnRvUGF0aFBhcnRzKHBhcnRpYWxTdHIpLnNsaWNlKDAsIC0xKTtcbiAgICB2YXIgbmV3VGFpbCA9IFBhdGhVdGlsLmdldExhc3RQYXRoUGFydChwYXRoKTtcbiAgICByZXR1cm4gUGF0aFV0aWwudG9QYXRoKHBhdGhQYXJ0c1dpdGhvdXRUYWlsLmNvbmNhdChuZXdUYWlsKSk7XG4gIH0pKTsgLy8gcmVsYXRpdmUgcGF0aHNcbn07XG5cbmV4cG9ydHMuc3VnZ2VzdEZpbGVTeXN0ZW1OYW1lcyA9IHN1Z2dlc3RGaWxlU3lzdGVtTmFtZXM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2VtdWxhdG9yL2NvbW1hbmQtcnVubmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2VtdWxhdG9yL2NvbW1hbmQtcnVubmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucnVuID0gZXhwb3J0cy5tYWtlUnVubmVyRXJyb3JPdXRwdXQgPSB2b2lkIDA7XG5cbnZhciBfZW11bGF0b3JFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yL2VtdWxhdG9yLWVycm9yICovIFwiLi9zcmMvZW11bGF0b3IvZW11bGF0b3ItZXJyb3IuanNcIik7XG5cbnZhciBfb3V0cHV0RmFjdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeSAqLyBcIi4vc3JjL2VtdWxhdG9yLW91dHB1dC9vdXRwdXQtZmFjdG9yeS5qc1wiKTtcblxudmFyIENvbW1hbmRNYXBwaW5nVXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL2NvbW1hbmQtbWFwcGluZyAqLyBcIi4vc3JjL2VtdWxhdG9yLXN0YXRlL2NvbW1hbmQtbWFwcGluZy5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiBNYWtlcyBhbiBpbnRlcm5hbCBlbXVsYXRvciBlcnJvciBmb3IgZW11bGF0b3Igb3V0cHV0LiBFcnJvciBvdXRwdXQgbWF5IGJlXG4gKiB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuICogQHBhcmFtICB7c3RyaW5nfSBlcnJvclR5cGUgdHlwZSBvZiBlbXVsYXRvciBlcnJvclxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgZXJyb3Igb3V0cHV0IG9iamVjdFxuICovXG52YXIgbWFrZVJ1bm5lckVycm9yT3V0cHV0ID0gZnVuY3Rpb24gbWFrZVJ1bm5lckVycm9yT3V0cHV0KGVycm9yVHlwZSkge1xuICByZXR1cm4gKDAsIF9vdXRwdXRGYWN0b3J5Lm1ha2VFcnJvck91dHB1dCkoKDAsIF9lbXVsYXRvckVycm9yLm1ha2VFcnJvcikoZXJyb3JUeXBlKSk7XG59O1xuLyoqXG4gKiBSdW5zIGEgY29tbWFuZCBhbmQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBlaXRoZXI6XG4gKiAtIG91dHB1dHMgZnJvbSBydW5uaW5nIHRoZSBjb21tYW5kLCBvclxuICogLSBuZXcgZW11bGF0b3Igc3RhdGUgYWZ0ZXIgcnVubmluZyB0aGUgY29tbWFuZCwgb3JcbiAqIC0gbmV3IGVtdWxhdG9yIHN0YXRlIGFuZCBvdXRwdXQgYWZ0ZXIgcnVubmluZyB0aGUgY29tbWFuZFxuICpcbiAqIFRoZSBmb3JtIG9mIHRoZSBvYmplY3QgZnJvbSB0aGlzIGZ1bmN0aW9uIGlzIGFzIGZvbGxvd3M6XG4gKiB7XG4gKiAgIG91dHB1dHM6IFtvcHRpb25hbCBhcnJheSBvZiBvdXRwdXQgcmVjb3Jkc11cbiAqICAgb3V0cHV0OiBbb3B0aW9uYWwgc2luZ2xlIG91dHB1dCByZWNvcmRdXG4gKiAgIHN0YXRlOiBbb3B0aW9uYWwgTWFwXVxuICogfVxuICogQHBhcmFtICB7TWFwfSAgICBjb21tYW5kTWFwcGluZyBjb21tYW5kIG1hcHBpbmcgZnJvbSBlbXVsYXRvciBzdGF0ZVxuICogQHBhcmFtICB7c3RyaW5nfSBjb21tYW5kTmFtZSAgICBuYW1lIG9mIGNvbW1hbmQgdG8gcnVuXG4gKiBAcGFyYW0gIHthcnJheX0gIGNvbW1hbmRBcmdzICAgIGNvbW1hbmRzIHRvIHByb3ZpZGUgdG8gdGhlIGNvbW1hbmQgZnVuY3Rpb25cbiAqIEBwYXJhbSAge3N0cmluZ30gIGVycm9yU3RyICAgICAgYSBkZWZhdWx0IHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaWYgbm8gY29tbWFuZCBpcyBmb3VuZFxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICBvdXRwdXRzIGFuZC9vciBuZXcgc3RhdGUgb2YgdGhlIGVtdWxhdG9yXG4gKi9cblxuXG5leHBvcnRzLm1ha2VSdW5uZXJFcnJvck91dHB1dCA9IG1ha2VSdW5uZXJFcnJvck91dHB1dDtcblxudmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bihjb21tYW5kTWFwcGluZywgY29tbWFuZE5hbWUsIGNvbW1hbmRBcmdzKSB7XG4gIHZhciBlcnJvclN0ciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogX2VtdWxhdG9yRXJyb3IuZW11bGF0b3JFcnJvclR5cGUuQ09NTUFORF9OT1RfRk9VTkQ7XG5cbiAgdmFyIG5vdEZvdW5kQ2FsbGJhY2sgPSBmdW5jdGlvbiBub3RGb3VuZENhbGxiYWNrKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXQ6IG1ha2VSdW5uZXJFcnJvck91dHB1dChlcnJvclN0cilcbiAgICB9O1xuICB9O1xuXG4gIGlmICghQ29tbWFuZE1hcHBpbmdVdGlsLmlzQ29tbWFuZFNldChjb21tYW5kTWFwcGluZywgY29tbWFuZE5hbWUpKSB7XG4gICAgcmV0dXJuIG5vdEZvdW5kQ2FsbGJhY2suYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoY29tbWFuZEFyZ3MpKTtcbiAgfVxuXG4gIHZhciBjb21tYW5kID0gQ29tbWFuZE1hcHBpbmdVdGlsLmdldENvbW1hbmRGbihjb21tYW5kTWFwcGluZywgY29tbWFuZE5hbWUpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNvbW1hbmQuYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoY29tbWFuZEFyZ3MpKTsgLy8gcnVuIGV4dHJhY3RlZCBjb21tYW5kIGZyb20gdGhlIG1hcHBpbmdcbiAgfSBjYXRjaCAoZmF0YWxDb21tYW5kRXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0OiBtYWtlUnVubmVyRXJyb3JPdXRwdXQoX2VtdWxhdG9yRXJyb3IuZW11bGF0b3JFcnJvclR5cGUuVU5FWFBFQ1RFRF9DT01NQU5EX0ZBSUxVUkUpXG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0cy5ydW4gPSBydW47XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2VtdWxhdG9yL2VtdWxhdG9yLWVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2VtdWxhdG9yL2VtdWxhdG9yLWVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VFcnJvciA9IGV4cG9ydHMuZW11bGF0b3JFcnJvclR5cGUgPSB2b2lkIDA7XG5cbi8qKlxuICogRW11bGF0b3IgZXJyb3IgdHlwZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIGVtdWxhdG9yRXJyb3JUeXBlID0ge1xuICBDT01NQU5EX05PVF9GT1VORDogJ0NvbW1hbmQgbm90IGZvdW5kJyxcbiAgVU5FWFBFQ1RFRF9DT01NQU5EX0ZBSUxVUkU6ICdVbmhhbmRsZWQgY29tbWFuZCBlcnJvcidcbn07XG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3IgdG8gZGlzcGxheSB0byB0aGUgdXNlciBvcmlnaW5hdGluZyBmcm9tIHRoZSBlbXVsYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBlbXVsYXRvckVycm9yVHlwZSAgZmlsZSBzeXN0ZW0gZXJyb3IgdHlwZVxuICogQHBhcmFtICB7c3RyaW5nfSBbbWVzc2FnZT0nJ10gICAgICAgb3B0aW9uYWwgbWV0YWRhdGEgZm9yIGRldmVsb3BlcnMgYWJvdXQgdGhlIGVycm9yXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbCBlcnJvciBvYmplY3RcbiAqL1xuXG5leHBvcnRzLmVtdWxhdG9yRXJyb3JUeXBlID0gZW11bGF0b3JFcnJvclR5cGU7XG5cbnZhciBtYWtlRXJyb3IgPSBmdW5jdGlvbiBtYWtlRXJyb3IoZW11bGF0b3JFcnJvclR5cGUpIHtcbiAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICByZXR1cm4ge1xuICAgIHNvdXJjZTogJ2VtdWxhdG9yJyxcbiAgICB0eXBlOiBlbXVsYXRvckVycm9yVHlwZSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlXG4gIH07XG59O1xuXG5leHBvcnRzLm1ha2VFcnJvciA9IG1ha2VFcnJvcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZW11bGF0b3IvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZW11bGF0b3IvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBDb21tYW5kUnVubmVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3IvY29tbWFuZC1ydW5uZXIgKi8gXCIuL3NyYy9lbXVsYXRvci9jb21tYW5kLXJ1bm5lci5qc1wiKSk7XG5cbnZhciBfY29tbWFuZFBhcnNlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcGFyc2VyL2NvbW1hbmQtcGFyc2VyICovIFwiLi9zcmMvcGFyc2VyL2NvbW1hbmQtcGFyc2VyLmpzXCIpKTtcblxudmFyIF9vdXRwdXRGYWN0b3J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itb3V0cHV0L291dHB1dC1mYWN0b3J5LmpzXCIpO1xuXG52YXIgX2hpc3RvcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci1zdGF0ZS9oaXN0b3J5ICovIFwiLi9zcmMvZW11bGF0b3Itc3RhdGUvaGlzdG9yeS5qc1wiKTtcblxudmFyIF9lbnZpcm9ubWVudFZhcmlhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLXN0YXRlL2Vudmlyb25tZW50LXZhcmlhYmxlcyAqLyBcIi4vc3JjL2VtdWxhdG9yLXN0YXRlL2Vudmlyb25tZW50LXZhcmlhYmxlcy5qc1wiKTtcblxudmFyIF9hdXRvQ29tcGxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci9hdXRvLWNvbXBsZXRlICovIFwiLi9zcmMvZW11bGF0b3IvYXV0by1jb21wbGV0ZS5qc1wiKTtcblxudmFyIF9pbW11dGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBpbW11dGFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9pbW11dGFibGUvZGlzdC9pbW11dGFibGUuZXMuanNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChvID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSkgeyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBpdCwgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEVtdWxhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW11bGF0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtdWxhdG9yKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbXVsYXRvciwgW3tcbiAgICBrZXk6IFwiYXV0b2NvbXBsZXRlXCIsXG5cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZXMgdXNlciBpbnB1dCBpZiB0aGVyZSBpcyBvbmUsIGFuZCBvbmx5IG9uZSwgc3VnZ2VzdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBzdWdnZXN0aW9ucyBvciBtb3JlIHRoYW4gb25lIHN1Z2dlc3Rpb24sIHRoZSBvcmlnaW5hbFxuICAgICAqIHVzZXIgaW5wdXQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gIHtFbXVsYXRvclN0YXRlfSBzdGF0ZSAgICAgIGVtdWxhdG9yIHN0YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgcGFydGlhbFN0ciBwYXJ0aWFsIHVzZXIgaW5wdXQgdG8gdGhlIGVtdWxhdG9yXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgdXNlciBpbnB1dCB3aGVuIG9uZSBzdWdnZXN0IChvciwgb3RoZXJ3c2llLCB0aGUgb3JpZ2luYWwgaW5wdXQpXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF1dG9jb21wbGV0ZShzdGF0ZSwgcGFydGlhbFN0cikge1xuICAgICAgdmFyIHN1Z2dlc3Rpb25zID0gdGhpcy5zdWdnZXN0KHN0YXRlLCBwYXJ0aWFsU3RyKTtcblxuICAgICAgaWYgKHN1Z2dlc3Rpb25zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm4gcGFydGlhbFN0cjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0clBhcnRzID0gbmV3IF9pbW11dGFibGUuTGlzdChwYXJ0aWFsU3RyLnNwbGl0KCcgJykpO1xuICAgICAgdmFyIGF1dG9jb21wbGV0ZWRUZXh0ID0gc3VnZ2VzdGlvbnNbMF07XG4gICAgICByZXR1cm4gc3RyUGFydHMudXBkYXRlKC0xLCBmdW5jdGlvbiAobGFzdFZhbCkge1xuICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlZFRleHQ7XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1Z2dlc3RcIixcblxuICAgIC8qKlxuICAgICAqIFN1Z2dlc3Qgd2hhdCB0aGUgdXNlciB3aWxsIHR5cGUgbmV4dFxuICAgICAqIEBwYXJhbSAge0VtdWxhdG9yU3RhdGV9IHN0YXRlICAgICAgZW11bGF0b3Igc3RhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICBwYXJ0aWFsU3RyIHBhcnRpYWwgdXNlciBpbnB1dCBvZiBhIGNvbW1hbmRcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICAgICAgIGxpc3Qgb2YgcG9zc2libGUgdGV4dCBzdWdnZXN0aW9uc1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWdnZXN0KHN0YXRlLCBwYXJ0aWFsU3RyKSB7XG4gICAgICBwYXJ0aWFsU3RyID0gdGhpcy5fdHJpbUxlYWRpbmdTcGFjZShwYXJ0aWFsU3RyKTtcbiAgICAgIHZhciBsYXN0UGFydGlhbENoYXIgPSBwYXJ0aWFsU3RyLnNsaWNlKC0xKTtcbiAgICAgIHZhciBpc1R5cGluZ05ld1BhcnQgPSBsYXN0UGFydGlhbENoYXIgPT09ICcgJztcbiAgICAgIHZhciBzdHJQYXJ0cyA9IHBhcnRpYWxTdHIudHJpbSgpLnNwbGl0KCcgJyk7XG5cbiAgICAgIHZhciBfdGhpcyRfZ2V0Qm91bmRhcnlXb3IgPSB0aGlzLl9nZXRCb3VuZGFyeVdvcmRzKHN0clBhcnRzKSxcbiAgICAgICAgICBjbWROYW1lID0gX3RoaXMkX2dldEJvdW5kYXJ5V29yLnN0YXJ0LFxuICAgICAgICAgIGxhc3RUZXh0RW50ZXJlZCA9IF90aGlzJF9nZXRCb3VuZGFyeVdvci5lbmQ7XG5cbiAgICAgIGlmICghaXNUeXBpbmdOZXdQYXJ0ICYmIHN0clBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gKDAsIF9hdXRvQ29tcGxldGUuc3VnZ2VzdENvbW1hbmRzKShzdGF0ZS5nZXRDb21tYW5kTWFwcGluZygpLCBjbWROYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0clRvQ29tcGxldGUgPSBpc1R5cGluZ05ld1BhcnQgPyAnJyA6IGxhc3RUZXh0RW50ZXJlZDtcbiAgICAgIHZhciBjd2QgPSAoMCwgX2Vudmlyb25tZW50VmFyaWFibGVzLmdldEVudmlyb25tZW50VmFyaWFibGUpKHN0YXRlLmdldEVudlZhcmlhYmxlcygpLCAnY3dkJyk7XG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSgoMCwgX2F1dG9Db21wbGV0ZS5zdWdnZXN0Q29tbWFuZE9wdGlvbnMpKHN0YXRlLmdldENvbW1hbmRNYXBwaW5nKCksIGNtZE5hbWUsIHN0clRvQ29tcGxldGUpKSwgX3RvQ29uc3VtYWJsZUFycmF5KCgwLCBfYXV0b0NvbXBsZXRlLnN1Z2dlc3RGaWxlU3lzdGVtTmFtZXMpKHN0YXRlLmdldEZpbGVTeXN0ZW0oKSwgY3dkLCBzdHJUb0NvbXBsZXRlKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdHJpbUxlYWRpbmdTcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJpbUxlYWRpbmdTcGFjZShzdHIpIHtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvZywgJycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Qm91bmRhcnlXb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Qm91bmRhcnlXb3JkcyhzdHJQYXJ0cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0clBhcnRzWzBdLFxuICAgICAgICBlbmQ6IHN0clBhcnRzW3N0clBhcnRzLmxlbmd0aCAtIDFdXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleGVjdXRlXCIsXG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGVtdWxhdG9yIGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gIHtFbXVsYXRvclN0YXRlfSAgc3RhdGUgICAgICAgICAgICAgICAgICAgZW11bGF0b3Igc3RhdGUgYmVmb3JlIHJ1bm5pbmcgY29tbWFuZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICBzdHIgICAgICAgICAgICAgICAgICAgICBjb21tYW5kIHN0cmluZyB0byBleGVjdXRlXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIFtleGVjdXRpb25MaXN0ZW5lcnM9W11dIGxpc3Qgb2YgcGx1Z2lucyB0byBub3RpZnkgd2hpbGUgcnVubmluZyB0aGUgY29tbWFuZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICBlcnJvclN0ciAgICAgICAgICAgICAgICBzdHJpbmcgdG8gZGlzcGxheSBvbiB1bnJlY29nbml6ZWQgY29tbWFuZFxuICAgICAqIEByZXR1cm4ge0VtdWxhdG9yU3RhdGV9ICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkIGVtdWxhdG9yIHN0YXRlIGFmdGVyIHJ1bm5pbmcgY29tbWFuZFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjdXRlKHN0YXRlLCBzdHIpIHtcbiAgICAgIHZhciBleGVjdXRpb25MaXN0ZW5lcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICAgICAgdmFyIGVycm9yU3RyID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihleGVjdXRpb25MaXN0ZW5lcnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBleGVjdXRpb25MaXN0ZW5lciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGV4ZWN1dGlvbkxpc3RlbmVyLm9uRXhlY3V0ZVN0YXJ0ZWQoc3RhdGUsIHN0cik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUgPSB0aGlzLl9hZGRIZWFkZXJPdXRwdXQoc3RhdGUsIHN0cik7XG5cbiAgICAgIGlmIChzdHIudHJpbSgpID09PSAnJykge1xuICAgICAgICAvLyBlbXB0eSBjb21tYW5kIHN0cmluZ1xuICAgICAgICBzdGF0ZSA9IHRoaXMuX2FkZENvbW1hbmRPdXRwdXRzKHN0YXRlLCBbKDAsIF9vdXRwdXRGYWN0b3J5Lm1ha2VUZXh0T3V0cHV0KSgnJyldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy5fYWRkQ29tbWFuZFRvSGlzdG9yeShzdGF0ZSwgc3RyKTtcbiAgICAgICAgc3RhdGUgPSB0aGlzLl91cGRhdGVTdGF0ZUJ5RXhlY3V0aW9uKHN0YXRlLCBzdHIsIGVycm9yU3RyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihleGVjdXRpb25MaXN0ZW5lcnMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX2V4ZWN1dGlvbkxpc3RlbmVyID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgX2V4ZWN1dGlvbkxpc3RlbmVyLm9uRXhlY3V0ZUNvbXBsZXRlZChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTdGF0ZUJ5RXhlY3V0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVTdGF0ZUJ5RXhlY3V0aW9uKHN0YXRlLCBjb21tYW5kU3RyVG9FeGVjdXRlLCBlcnJvclN0cikge1xuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcigoMCwgX2NvbW1hbmRQYXJzZXJbXCJkZWZhdWx0XCJdKShjb21tYW5kU3RyVG9FeGVjdXRlKSksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc3RlcDMudmFsdWUsXG4gICAgICAgICAgICAgIGNvbW1hbmROYW1lID0gX3N0ZXAzJHZhbHVlLmNvbW1hbmROYW1lLFxuICAgICAgICAgICAgICBjb21tYW5kT3B0aW9ucyA9IF9zdGVwMyR2YWx1ZS5jb21tYW5kT3B0aW9ucztcbiAgICAgICAgICB2YXIgY29tbWFuZE1hcHBpbmcgPSBzdGF0ZS5nZXRDb21tYW5kTWFwcGluZygpO1xuICAgICAgICAgIHZhciBjb21tYW5kQXJncyA9IFtzdGF0ZSwgY29tbWFuZE9wdGlvbnNdO1xuXG4gICAgICAgICAgdmFyIF9Db21tYW5kUnVubmVyJHJ1biA9IENvbW1hbmRSdW5uZXIucnVuKGNvbW1hbmRNYXBwaW5nLCBjb21tYW5kTmFtZSwgY29tbWFuZEFyZ3MsIGVycm9yU3RyKSxcbiAgICAgICAgICAgICAgbmV4dFN0YXRlID0gX0NvbW1hbmRSdW5uZXIkcnVuLnN0YXRlLFxuICAgICAgICAgICAgICBvdXRwdXQgPSBfQ29tbWFuZFJ1bm5lciRydW4ub3V0cHV0LFxuICAgICAgICAgICAgICBvdXRwdXRzID0gX0NvbW1hbmRSdW5uZXIkcnVuLm91dHB1dHM7XG5cbiAgICAgICAgICBpZiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuX2FkZENvbW1hbmRPdXRwdXRzKHN0YXRlLCBbb3V0cHV0XSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvdXRwdXRzKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuX2FkZENvbW1hbmRPdXRwdXRzKHN0YXRlLCBvdXRwdXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRDb21tYW5kVG9IaXN0b3J5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRDb21tYW5kVG9IaXN0b3J5KHN0YXRlLCBjb21tYW5kKSB7XG4gICAgICB2YXIgaGlzdG9yeSA9IHN0YXRlLmdldEhpc3RvcnkoKTtcbiAgICAgIHJldHVybiBzdGF0ZS5zZXRIaXN0b3J5KCgwLCBfaGlzdG9yeS5yZWNvcmRDb21tYW5kKShoaXN0b3J5LCBjb21tYW5kKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRIZWFkZXJPdXRwdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEhlYWRlck91dHB1dChzdGF0ZSwgY29tbWFuZFN0cikge1xuICAgICAgdmFyIGVudlZhcmlhYmxlcyA9IHN0YXRlLmdldEVudlZhcmlhYmxlcygpO1xuICAgICAgdmFyIGN3ZCA9ICgwLCBfZW52aXJvbm1lbnRWYXJpYWJsZXMuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoZW52VmFyaWFibGVzLCAnY3dkJyk7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ29tbWFuZE91dHB1dHMoc3RhdGUsIFsoMCwgX291dHB1dEZhY3RvcnkubWFrZUhlYWRlck91dHB1dCkoY3dkLCBjb21tYW5kU3RyKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIG91dHB1dHMgdG8gdGhlIGludGVybmFsIHN0YXRlIG9mIG91dHB1dHNcbiAgICAgKiBAcGFyYW0ge0xpc3R9IG91dHB1dHMgbGlzdCBvZiBvdXRwdXRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQ29tbWFuZE91dHB1dHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZENvbW1hbmRPdXRwdXRzKHN0YXRlLCBvdXRwdXRzKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG91dHB1dHMpLFxuICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF9vdXRwdXRzID0gc3RhdGUuZ2V0T3V0cHV0cygpO1xuXG4gICAgICAgICAgc3RhdGUgPSBzdGF0ZS5zZXRPdXRwdXRzKF9vdXRwdXRzLnB1c2gob3V0cHV0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVtdWxhdG9yO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEVtdWxhdG9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2VtdWxhdG9yL3BsdWdpbnMvQm91bmRlZEhpc3RvcnlJdGVyYXRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZW11bGF0b3IvcGx1Z2lucy9Cb3VuZGVkSGlzdG9yeUl0ZXJhdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBNYWtlcyBhIHN0YWNrIGl0ZXJhdG9yIGZvciBhIHBvaW50IGluIGhpc3RvcnkuXG4gKlxuICogQ2FuIGdvIGJhY2t3YXJkcyBhbmQgZm9yd2FyZHMgdGhyb3VnaCB0aGUgaGlzdG9yeSBhbmQgaXMgYm91bmRlZCBieVxuICogdGhlIHNpemUgb2YgdGhlIHN0YWNrLlxuICovXG52YXIgQm91bmRlZEhpc3RvcnlJdGVyYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJvdW5kZWRIaXN0b3J5SXRlcmF0b3IoaGlzdG9yeVN0YWNrKSB7XG4gICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJvdW5kZWRIaXN0b3J5SXRlcmF0b3IpO1xuXG4gICAgdGhpcy5oaXN0b3J5U3RhY2sgPSBoaXN0b3J5U3RhY2sucHVzaCgnJyk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJvdW5kZWRIaXN0b3J5SXRlcmF0b3IsIFt7XG4gICAga2V5OiBcImhhc1VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1VwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXggKyAxIDwgdGhpcy5oaXN0b3J5U3RhY2suc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXAoKSB7XG4gICAgICBpZiAodGhpcy5oYXNVcCgpKSB7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeVN0YWNrLmdldCh0aGlzLmluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzRG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNEb3duKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXggLSAxID49IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG93bigpIHtcbiAgICAgIGlmICh0aGlzLmhhc0Rvd24oKSkge1xuICAgICAgICB0aGlzLmluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmhpc3RvcnlTdGFjay5nZXQodGhpcy5pbmRleCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJvdW5kZWRIaXN0b3J5SXRlcmF0b3I7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQm91bmRlZEhpc3RvcnlJdGVyYXRvcjtcbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9lbXVsYXRvci9wbHVnaW5zL0hpc3RvcnlLZXlib2FyZFBsdWdpbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9lbXVsYXRvci9wbHVnaW5zL0hpc3RvcnlLZXlib2FyZFBsdWdpbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfQm91bmRlZEhpc3RvcnlJdGVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3IvcGx1Z2lucy9Cb3VuZGVkSGlzdG9yeUl0ZXJhdG9yICovIFwiLi9zcmMvZW11bGF0b3IvcGx1Z2lucy9Cb3VuZGVkSGlzdG9yeUl0ZXJhdG9yLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEhpc3RvcnlLZXlib2FyZFBsdWdpbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhpc3RvcnlLZXlib2FyZFBsdWdpbihzdGF0ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaXN0b3J5S2V5Ym9hcmRQbHVnaW4pO1xuXG4gICAgdGhpcy5fbnVsbGFibGVIaXN0b3J5SXRlcmF0b3IgPSBudWxsO1xuICAgIHRoaXMuaGlzdG9yeVN0YWNrID0gc3RhdGUuZ2V0SGlzdG9yeSgpO1xuICB9IC8vIFBsdWdpbiBjb250cmFjdFxuXG5cbiAgX2NyZWF0ZUNsYXNzKEhpc3RvcnlLZXlib2FyZFBsdWdpbiwgW3tcbiAgICBrZXk6IFwib25FeGVjdXRlU3RhcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkV4ZWN1dGVTdGFydGVkKHN0YXRlLCBzdHIpIHt9IC8vIG5vLW9wXG4gICAgLy8gUGx1Z2luIGNvbnRyYWN0XG5cbiAgfSwge1xuICAgIGtleTogXCJvbkV4ZWN1dGVDb21wbGV0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FeGVjdXRlQ29tcGxldGVkKHN0YXRlKSB7XG4gICAgICB0aGlzLl9udWxsYWJsZUhpc3RvcnlJdGVyYXRvciA9IG51bGw7XG4gICAgICB0aGlzLmhpc3RvcnlTdGFjayA9IHN0YXRlLmdldEhpc3RvcnkoKTtcbiAgICB9IC8vIFBsdWdpbiBBUElcblxuICB9LCB7XG4gICAga2V5OiBcImNvbXBsZXRlVXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGxldGVVcCgpIHtcbiAgICAgIHRoaXMuY3JlYXRlSGlzdG9yeUl0ZXJhdG9ySWZOdWxsKCk7XG4gICAgICByZXR1cm4gdGhpcy5fbnVsbGFibGVIaXN0b3J5SXRlcmF0b3IudXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGxldGVEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBsZXRlRG93bigpIHtcbiAgICAgIHRoaXMuY3JlYXRlSGlzdG9yeUl0ZXJhdG9ySWZOdWxsKCk7XG4gICAgICByZXR1cm4gdGhpcy5fbnVsbGFibGVIaXN0b3J5SXRlcmF0b3IuZG93bigpO1xuICAgIH0gLy8gUHJpdmF0ZSBtZXRob2RzXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVIaXN0b3J5SXRlcmF0b3JJZk51bGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlSGlzdG9yeUl0ZXJhdG9ySWZOdWxsKCkge1xuICAgICAgaWYgKCF0aGlzLl9udWxsYWJsZUhpc3RvcnlJdGVyYXRvcikge1xuICAgICAgICB0aGlzLl9udWxsYWJsZUhpc3RvcnlJdGVyYXRvciA9IG5ldyBfQm91bmRlZEhpc3RvcnlJdGVyYXRvcltcImRlZmF1bHRcIl0odGhpcy5oaXN0b3J5U3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIaXN0b3J5S2V5Ym9hcmRQbHVnaW47XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gSGlzdG9yeUtleWJvYXJkUGx1Z2luO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2ZzL2ZzLWVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2ZzL2ZzLWVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VFcnJvciA9IGV4cG9ydHMuZnNFcnJvclR5cGUgPSB2b2lkIDA7XG5cbi8qKlxuICogRmlsZSBzeXN0ZW0gZXJyb3IgdHlwZXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBmc0Vycm9yVHlwZSA9IHtcbiAgRklMRV9FWElTVFM6ICdGaWxlIGV4aXN0cycsXG4gIERJUkVDVE9SWV9FWElTVFM6ICdEaXJlY3RvcnkgZXhpc3RzJyxcbiAgRElSRUNUT1JZX05PVF9FTVBUWTogJ0RpcmVjdG9yeSBub3QgZW1wdHknLFxuICBOT19TVUNIX0ZJTEVfT1JfRElSRUNUT1JZOiAnTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScsXG4gIE5PX1NVQ0hfRklMRTogJ05vIHN1Y2ggZmlsZScsXG4gIE5PX1NVQ0hfRElSRUNUT1JZOiAnTm8gc3VjaCBkaXJlY3RvcnknLFxuICBGSUxFX09SX0RJUkVDVE9SWV9FWElTVFM6ICdGaWxlIG9yIGRpcmVjdG9yeSBleGlzdHMnLFxuICBJU19BX0RJUkVDVE9SWTogJ0lzIGEgZGlyZWN0b3J5JyxcbiAgTk9UX0FfRElSRUNUT1JZOiAnTm90IGEgZGlyZWN0b3J5JyxcbiAgUEVSTUlTU0lPTl9ERU5JRUQ6ICdQZXJtaXNzaW9uIGRlbmllZCcsXG4gIE9USEVSOiAnT3RoZXInXG59O1xuLyoqXG4gKiBDcmVhdGUgYSBub24tZmF0YWwgZmlsZSBzeXN0ZW0gZXJyb3Igb2JqZWN0XG4gKlxuICogRm9yIGZhdGFsIGVycm9ycyBkbyBub3QgdXNlIHRoaXMuIFRocm93IGFuIGVycm9yIGluc3RlYWQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZzRXJyb3JUeXBlICBmaWxlIHN5c3RlbSBlcnJvciB0eXBlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFttZXNzYWdlPScnXSBvcHRpb25hbCBtZXRhZGF0YSBmb3IgZGV2ZWxvcGVycyBhYm91dCB0aGUgZXJyb3JcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgIGludGVybmFsIGVycm9yIG9iamVjdFxuICovXG5cbmV4cG9ydHMuZnNFcnJvclR5cGUgPSBmc0Vycm9yVHlwZTtcblxudmFyIG1ha2VFcnJvciA9IGZ1bmN0aW9uIG1ha2VFcnJvcihmc0Vycm9yVHlwZSkge1xuICB2YXIgbWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHJldHVybiB7XG4gICAgc291cmNlOiAnZnMnLFxuICAgIHR5cGU6IGZzRXJyb3JUeXBlLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgfTtcbn07XG5cbmV4cG9ydHMubWFrZUVycm9yID0gbWFrZUVycm9yO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9mcy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9mcy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIERpck9wID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMuanNcIikpO1xuXG52YXIgRmlsZU9wID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZmlsZS1vcGVyYXRpb25zICovIFwiLi9zcmMvZnMvb3BlcmF0aW9ucy13aXRoLXBlcm1pc3Npb25zL2ZpbGUtb3BlcmF0aW9ucy5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbnZhciBfZGVmYXVsdCA9IHtcbiAgRGlyT3A6IERpck9wLFxuICBGaWxlT3A6IEZpbGVPcFxufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZnMvb3BlcmF0aW9ucy13aXRoLXBlcm1pc3Npb25zL2RpcmVjdG9yeS1vcGVyYXRpb25zLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9mcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVuYW1lRGlyZWN0b3J5ID0gZXhwb3J0cy5kZWxldGVEaXJlY3RvcnkgPSBleHBvcnRzLmNvcHlEaXJlY3RvcnkgPSBleHBvcnRzLmFkZERpcmVjdG9yeSA9IGV4cG9ydHMubGlzdERpcmVjdG9yeUZvbGRlcnMgPSBleHBvcnRzLmxpc3REaXJlY3RvcnlGaWxlcyA9IGV4cG9ydHMubGlzdERpcmVjdG9yeSA9IGV4cG9ydHMuaGFzRGlyZWN0b3J5ID0gdm9pZCAwO1xuXG52YXIgRGlyZWN0b3J5T3BlcmF0aW9ucyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zL2RpcmVjdG9yeS1vcGVyYXRpb25zLmpzXCIpKTtcblxudmFyIFBlcm1pc3Npb25VdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvdXRpbC9wZXJtaXNzaW9uLXV0aWwgKi8gXCIuL3NyYy9mcy91dGlsL3Blcm1pc3Npb24tdXRpbC5qc1wiKSk7XG5cbnZhciBfZnNFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL2ZzLWVycm9yICovIFwiLi9zcmMvZnMvZnMtZXJyb3IuanNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxuICogQWRkcyBtb2RpZmljYXRpb24gcGVybWlzc2lvbnMgdG8gZGlyZWN0b3J5IG9wZXJhdGlvbnMgYnkgd3JhcHBpbmdcbiAqIGRpcmVjdG9yeSBvcGVyYXRpb25zXG4gKi9cbnZhciBtYWtlRGlyZWN0b3J5T3BlcmF0aW9uUGVybWlzc2lvbkVycm9yID0gZnVuY3Rpb24gbWFrZURpcmVjdG9yeU9wZXJhdGlvblBlcm1pc3Npb25FcnJvcigpIHtcbiAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdDYW5ub3QgbW9kaWZ5IGRpcmVjdG9yeSc7XG4gIHJldHVybiB7XG4gICAgZXJyOiAoMCwgX2ZzRXJyb3IubWFrZUVycm9yKShfZnNFcnJvci5mc0Vycm9yVHlwZS5QRVJNSVNTSU9OX0RFTklFRCwgbWVzc2FnZSlcbiAgfTtcbn07XG5cbnZhciBoYXNEaXJlY3RvcnkgPSBmdW5jdGlvbiBoYXNEaXJlY3RvcnkoKSB7XG4gIHJldHVybiBEaXJlY3RvcnlPcGVyYXRpb25zLmhhc0RpcmVjdG9yeS5hcHBseShEaXJlY3RvcnlPcGVyYXRpb25zLCBhcmd1bWVudHMpO1xufTtcblxuZXhwb3J0cy5oYXNEaXJlY3RvcnkgPSBoYXNEaXJlY3Rvcnk7XG5cbnZhciBsaXN0RGlyZWN0b3J5ID0gZnVuY3Rpb24gbGlzdERpcmVjdG9yeSgpIHtcbiAgcmV0dXJuIERpcmVjdG9yeU9wZXJhdGlvbnMubGlzdERpcmVjdG9yeS5hcHBseShEaXJlY3RvcnlPcGVyYXRpb25zLCBhcmd1bWVudHMpO1xufTtcblxuZXhwb3J0cy5saXN0RGlyZWN0b3J5ID0gbGlzdERpcmVjdG9yeTtcblxudmFyIGxpc3REaXJlY3RvcnlGaWxlcyA9IGZ1bmN0aW9uIGxpc3REaXJlY3RvcnlGaWxlcygpIHtcbiAgcmV0dXJuIERpcmVjdG9yeU9wZXJhdGlvbnMubGlzdERpcmVjdG9yeUZpbGVzLmFwcGx5KERpcmVjdG9yeU9wZXJhdGlvbnMsIGFyZ3VtZW50cyk7XG59O1xuXG5leHBvcnRzLmxpc3REaXJlY3RvcnlGaWxlcyA9IGxpc3REaXJlY3RvcnlGaWxlcztcblxudmFyIGxpc3REaXJlY3RvcnlGb2xkZXJzID0gZnVuY3Rpb24gbGlzdERpcmVjdG9yeUZvbGRlcnMoKSB7XG4gIHJldHVybiBEaXJlY3RvcnlPcGVyYXRpb25zLmxpc3REaXJlY3RvcnlGb2xkZXJzLmFwcGx5KERpcmVjdG9yeU9wZXJhdGlvbnMsIGFyZ3VtZW50cyk7XG59O1xuXG5leHBvcnRzLmxpc3REaXJlY3RvcnlGb2xkZXJzID0gbGlzdERpcmVjdG9yeUZvbGRlcnM7XG5cbnZhciBhZGREaXJlY3RvcnkgPSBmdW5jdGlvbiBhZGREaXJlY3RvcnkoZnMsIHBhdGgpIHtcbiAgaWYgKCFQZXJtaXNzaW9uVXRpbC5jYW5Nb2RpZnlQYXRoKGZzLCBwYXRoKSkge1xuICAgIHJldHVybiBtYWtlRGlyZWN0b3J5T3BlcmF0aW9uUGVybWlzc2lvbkVycm9yKCk7XG4gIH1cblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gRGlyZWN0b3J5T3BlcmF0aW9ucy5hZGREaXJlY3RvcnkuYXBwbHkoRGlyZWN0b3J5T3BlcmF0aW9ucywgW2ZzLCBwYXRoXS5jb25jYXQoYXJncykpO1xufTtcblxuZXhwb3J0cy5hZGREaXJlY3RvcnkgPSBhZGREaXJlY3Rvcnk7XG5cbnZhciBjb3B5RGlyZWN0b3J5ID0gZnVuY3Rpb24gY29weURpcmVjdG9yeShmcywgc3JjUGF0aCwgZGVzdFBhdGgpIHtcbiAgaWYgKCFQZXJtaXNzaW9uVXRpbC5jYW5Nb2RpZnlQYXRoKGZzLCBzcmNQYXRoKSkge1xuICAgIHJldHVybiBtYWtlRGlyZWN0b3J5T3BlcmF0aW9uUGVybWlzc2lvbkVycm9yKCdDYW5ub3QgbW9kaWZ5IHNvdXJjZSBkaXJlY3RvcnknKTtcbiAgfVxuXG4gIGlmICghUGVybWlzc2lvblV0aWwuY2FuTW9kaWZ5UGF0aChmcywgZGVzdFBhdGgpKSB7XG4gICAgcmV0dXJuIG1ha2VEaXJlY3RvcnlPcGVyYXRpb25QZXJtaXNzaW9uRXJyb3IoJ0Nhbm5vdCBtb2RpZnkgZGVzdCBkaXJlY3RvcnknKTtcbiAgfVxuXG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDNdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHJldHVybiBEaXJlY3RvcnlPcGVyYXRpb25zLmNvcHlEaXJlY3RvcnkuYXBwbHkoRGlyZWN0b3J5T3BlcmF0aW9ucywgW2ZzLCBzcmNQYXRoLCBkZXN0UGF0aF0uY29uY2F0KGFyZ3MpKTtcbn07XG5cbmV4cG9ydHMuY29weURpcmVjdG9yeSA9IGNvcHlEaXJlY3Rvcnk7XG5cbnZhciBkZWxldGVEaXJlY3RvcnkgPSBmdW5jdGlvbiBkZWxldGVEaXJlY3RvcnkoZnMsIHBhdGgpIHtcbiAgaWYgKCFQZXJtaXNzaW9uVXRpbC5jYW5Nb2RpZnlQYXRoKGZzLCBwYXRoKSkge1xuICAgIHJldHVybiBtYWtlRGlyZWN0b3J5T3BlcmF0aW9uUGVybWlzc2lvbkVycm9yKCk7XG4gIH1cblxuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAyID8gX2xlbjMgLSAyIDogMCksIF9rZXkzID0gMjsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAyXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gRGlyZWN0b3J5T3BlcmF0aW9ucy5kZWxldGVEaXJlY3RvcnkuYXBwbHkoRGlyZWN0b3J5T3BlcmF0aW9ucywgW2ZzLCBwYXRoXS5jb25jYXQoYXJncykpO1xufTtcblxuZXhwb3J0cy5kZWxldGVEaXJlY3RvcnkgPSBkZWxldGVEaXJlY3Rvcnk7XG5cbnZhciByZW5hbWVEaXJlY3RvcnkgPSBmdW5jdGlvbiByZW5hbWVEaXJlY3RvcnkoZnMsIGN1cnJlbnRQYXRoLCBuZXdQYXRoKSB7XG4gIGlmICghUGVybWlzc2lvblV0aWwuY2FuTW9kaWZ5UGF0aChmcywgY3VycmVudFBhdGgpKSB7XG4gICAgcmV0dXJuIG1ha2VEaXJlY3RvcnlPcGVyYXRpb25QZXJtaXNzaW9uRXJyb3IoJ0Nhbm5vdCBtb2RpZnkgY3VycmVudCBwYXRoJyk7XG4gIH1cblxuICBpZiAoIVBlcm1pc3Npb25VdGlsLmNhbk1vZGlmeVBhdGgoZnMsIG5ld1BhdGgpKSB7XG4gICAgcmV0dXJuIG1ha2VEaXJlY3RvcnlPcGVyYXRpb25QZXJtaXNzaW9uRXJyb3IoJ0Nhbm5vdCBtb2RpZnkgcmVuYW1lZCBwYXRoJyk7XG4gIH1cblxuICByZXR1cm4gRGlyZWN0b3J5T3BlcmF0aW9ucy5yZW5hbWVEaXJlY3RvcnkoZnMsIGN1cnJlbnRQYXRoLCBuZXdQYXRoKTtcbn07XG5cbmV4cG9ydHMucmVuYW1lRGlyZWN0b3J5ID0gcmVuYW1lRGlyZWN0b3J5O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zLXdpdGgtcGVybWlzc2lvbnMvZmlsZS1vcGVyYXRpb25zLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZnMvb3BlcmF0aW9ucy13aXRoLXBlcm1pc3Npb25zL2ZpbGUtb3BlcmF0aW9ucy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVsZXRlRmlsZSA9IGV4cG9ydHMuY29weUZpbGUgPSBleHBvcnRzLndyaXRlRmlsZSA9IGV4cG9ydHMucmVhZEZpbGUgPSBleHBvcnRzLmhhc0ZpbGUgPSB2b2lkIDA7XG5cbnZhciBQZXJtaXNzaW9uVXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL3V0aWwvcGVybWlzc2lvbi11dGlsICovIFwiLi9zcmMvZnMvdXRpbC9wZXJtaXNzaW9uLXV0aWwuanNcIikpO1xuXG52YXIgRmlsZU9wZXJhdGlvbnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy9vcGVyYXRpb25zL2ZpbGUtb3BlcmF0aW9ucyAqLyBcIi4vc3JjL2ZzL29wZXJhdGlvbnMvZmlsZS1vcGVyYXRpb25zLmpzXCIpKTtcblxudmFyIF9mc0Vycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvZnMtZXJyb3IgKi8gXCIuL3NyYy9mcy9mcy1lcnJvci5qc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXG4gKiBBZGRzIG1vZGlmaWNhdGlvbiBwZXJtaXNzaW9ucyB0byBmaWxlIG9wZXJhdGlvbnMgYnkgd3JhcHBpbmdcbiAqIGZpbGUgb3BlcmF0aW9uc1xuICovXG52YXIgbWFrZUZpbGVPcGVyYXRpb25QZXJtaXNzaW9uRXJyb3IgPSBmdW5jdGlvbiBtYWtlRmlsZU9wZXJhdGlvblBlcm1pc3Npb25FcnJvcigpIHtcbiAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdDYW5ub3QgbW9kaWZ5IGZpbGUnO1xuICByZXR1cm4ge1xuICAgIGVycjogKDAsIF9mc0Vycm9yLm1ha2VFcnJvcikoX2ZzRXJyb3IuZnNFcnJvclR5cGUuUEVSTUlTU0lPTl9ERU5JRUQsIG1lc3NhZ2UpXG4gIH07XG59O1xuXG52YXIgaGFzRmlsZSA9IGZ1bmN0aW9uIGhhc0ZpbGUoKSB7XG4gIHJldHVybiBGaWxlT3BlcmF0aW9ucy5oYXNGaWxlLmFwcGx5KEZpbGVPcGVyYXRpb25zLCBhcmd1bWVudHMpO1xufTtcblxuZXhwb3J0cy5oYXNGaWxlID0gaGFzRmlsZTtcblxudmFyIHJlYWRGaWxlID0gZnVuY3Rpb24gcmVhZEZpbGUoKSB7XG4gIHJldHVybiBGaWxlT3BlcmF0aW9ucy5yZWFkRmlsZS5hcHBseShGaWxlT3BlcmF0aW9ucywgYXJndW1lbnRzKTtcbn07XG5cbmV4cG9ydHMucmVhZEZpbGUgPSByZWFkRmlsZTtcblxudmFyIHdyaXRlRmlsZSA9IGZ1bmN0aW9uIHdyaXRlRmlsZShmcywgZmlsZVBhdGgpIHtcbiAgaWYgKCFQZXJtaXNzaW9uVXRpbC5jYW5Nb2RpZnlQYXRoKGZzLCBmaWxlUGF0aCkpIHtcbiAgICByZXR1cm4gbWFrZUZpbGVPcGVyYXRpb25QZXJtaXNzaW9uRXJyb3IoKTtcbiAgfVxuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBGaWxlT3BlcmF0aW9ucy53cml0ZUZpbGUuYXBwbHkoRmlsZU9wZXJhdGlvbnMsIFtmcywgZmlsZVBhdGhdLmNvbmNhdChhcmdzKSk7XG59O1xuXG5leHBvcnRzLndyaXRlRmlsZSA9IHdyaXRlRmlsZTtcblxudmFyIGNvcHlGaWxlID0gZnVuY3Rpb24gY29weUZpbGUoZnMsIHNvdXJjZVBhdGgsIGRlc3RQYXRoKSB7XG4gIGlmICghUGVybWlzc2lvblV0aWwuY2FuTW9kaWZ5UGF0aChmcywgc291cmNlUGF0aCkpIHtcbiAgICByZXR1cm4gbWFrZUZpbGVPcGVyYXRpb25QZXJtaXNzaW9uRXJyb3IoJ0Nhbm5vdCBtb2RpZnkgc291cmNlIGZpbGUnKTtcbiAgfVxuXG4gIGlmICghUGVybWlzc2lvblV0aWwuY2FuTW9kaWZ5UGF0aChmcywgZGVzdFBhdGgpKSB7XG4gICAgcmV0dXJuIG1ha2VGaWxlT3BlcmF0aW9uUGVybWlzc2lvbkVycm9yKCdDYW5ub3QgbW9kaWZ5IGRlc3RpbmF0aW9uIGZpbGUnKTtcbiAgfVxuXG4gIHJldHVybiBGaWxlT3BlcmF0aW9ucy5jb3B5RmlsZShmcywgc291cmNlUGF0aCwgZGVzdFBhdGgpO1xufTtcblxuZXhwb3J0cy5jb3B5RmlsZSA9IGNvcHlGaWxlO1xuXG52YXIgZGVsZXRlRmlsZSA9IGZ1bmN0aW9uIGRlbGV0ZUZpbGUoZnMsIGZpbGVQYXRoKSB7XG4gIGlmICghUGVybWlzc2lvblV0aWwuY2FuTW9kaWZ5UGF0aChmcywgZmlsZVBhdGgpKSB7XG4gICAgcmV0dXJuIG1ha2VGaWxlT3BlcmF0aW9uUGVybWlzc2lvbkVycm9yKCk7XG4gIH1cblxuICByZXR1cm4gRmlsZU9wZXJhdGlvbnMuZGVsZXRlRmlsZShmcywgZmlsZVBhdGgpO1xufTtcblxuZXhwb3J0cy5kZWxldGVGaWxlID0gZGVsZXRlRmlsZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZnMvb3BlcmF0aW9ucy9iYXNlLW9wZXJhdGlvbnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZnMvb3BlcmF0aW9ucy9iYXNlLW9wZXJhdGlvbnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZW1vdmUgPSBleHBvcnRzLmFkZCA9IHZvaWQgMDtcblxudmFyIEdsb2JVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvdXRpbC9nbG9iLXV0aWwgKi8gXCIuL3NyYy9mcy91dGlsL2dsb2ItdXRpbC5qc1wiKSk7XG5cbnZhciBEaXJPcCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zL2RpcmVjdG9yeS1vcGVyYXRpb25zLmpzXCIpKTtcblxudmFyIEZpbGVPcCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMvZmlsZS1vcGVyYXRpb25zICovIFwiLi9zcmMvZnMvb3BlcmF0aW9ucy9maWxlLW9wZXJhdGlvbnMuanNcIikpO1xuXG52YXIgUGF0aFV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy91dGlsL3BhdGgtdXRpbCAqLyBcIi4vc3JjL2ZzL3V0aWwvcGF0aC11dGlsLmpzXCIpKTtcblxudmFyIF9mc0Vycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvZnMtZXJyb3IgKi8gXCIuL3NyYy9mcy9mcy1lcnJvci5qc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobykgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAobyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkpIHsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgaXQsIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vKipcbiAqIEFkZHMgYSBmaWxlIG9yIGRpcmVjdG9yeSB0byBhIHBhdGhcbiAqIEBwYXJhbSB7TWFwfSAgICAgZnMgICAgICAgICAgICAgICAgICAgICBmaWxlIHN5c3RlbVxuICogQHBhcmFtIHtzdHJpbmd9ICBwYXRoVG9BZGQgICAgICAgICAgICAgIHBhdGggdG8gYWRkIHRoZSBmaWxlIG9yIGRpcmVjdG9yeSB0b1xuICogQHBhcmFtIHtzdHJpbmd9ICBmc0VsZW1lbnRUb0FkZCAgICAgICAgIGZpbGUgb3IgZGlyZWN0b3J5IG1hcFxuICogQHBhcmFtIHtCb29sZWFufSBbYWRkUGFyZW50UGF0aHM9ZmFsc2VdIHRydWUsIGlmIHBhdGggcGFyZW50IGRpcmVjdG9yaWVzIHNob3VsZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIG1hZGUgKGlmIHRoZXkgZG9uJ3QgZXhpc3QpXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSBzeXN0ZW0gb3IgZXJyb3JcbiAqL1xudmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChmcywgcGF0aFRvQWRkLCBmc0VsZW1lbnRUb0FkZCkge1xuICB2YXIgYWRkUGFyZW50UGF0aHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gIGlmIChmcy5oYXMocGF0aFRvQWRkKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnI6ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLkZJTEVfT1JfRElSRUNUT1JZX0VYSVNUUylcbiAgICB9O1xuICB9XG5cbiAgdmFyIHBhcmVudFBhdGhzID0gUGF0aFV0aWwuZ2V0UGF0aEJyZWFkQ3J1bWJzKHBhdGhUb0FkZCkuc2xpY2UoMCwgLTEpO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwYXJlbnRQYXRocyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgcGFyZW50UGF0aCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoRmlsZU9wLmhhc0ZpbGUoZnMsIHBhcmVudFBhdGgpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXJyOiAoMCwgX2ZzRXJyb3IubWFrZUVycm9yKShfZnNFcnJvci5mc0Vycm9yVHlwZS5OT1RfQV9ESVJFQ1RPUlksIFwiQ2Fubm90IGFkZCBwYXRoIHRvIGEgZmlsZTogXCIuY29uY2F0KHBhcmVudFBhdGgpKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZzLmhhcyhwYXJlbnRQYXRoKSAmJiAhYWRkUGFyZW50UGF0aHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnI6ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLk5PX1NVQ0hfRElSRUNUT1JZLCBcIlBhcmVudCBkaXJlY3RvcnkgZG9lcyBub3QgZXhpc3Q6IFwiLmNvbmNhdChwYXJlbnRQYXRoKSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHZhciBhZGRlZERpcmVjdG9yeUZzID0gZnMuc2V0KHBhdGhUb0FkZCwgZnNFbGVtZW50VG9BZGQpO1xuICByZXR1cm4ge1xuICAgIGZzOiBhZGRQYXJlbnRQYXRocyA/IERpck9wLmZpbGxHYXBzKGFkZGVkRGlyZWN0b3J5RnMpIDogYWRkZWREaXJlY3RvcnlGc1xuICB9O1xufTtcbi8qKlxuICogUmVtb3ZlcyBhIGZpbGUgb3IgZGlyZWN0b3J5IGZyb20gYSBwYXRoXG4gKiBAcGFyYW0gIHtNYXB9ICAgICBmcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHN5c3RlbVxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFRvUmVtb3ZlICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlcyB0aGUgcGF0aFxuICogQHBhcmFtICB7Qm9vbGVhbn0gW2lzTm9uRW1wdHlEaXJlY3RvcnlSZW1vdmFibGU9dHJ1ZV0gdHJ1ZSBpZiBub24tZW1wdHkgcGF0aHMgY2FuIGJlIHJlbW92ZWRcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgc3lzdGVtIG9yIGVycm9yXG4gKi9cblxuXG5leHBvcnRzLmFkZCA9IGFkZDtcblxudmFyIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShmcywgcGF0aFRvUmVtb3ZlKSB7XG4gIHZhciBpc05vbkVtcHR5RGlyZWN0b3J5UmVtb3ZhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gIGlmICghZnMuaGFzKHBhdGhUb1JlbW92ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyOiAoMCwgX2ZzRXJyb3IubWFrZUVycm9yKShfZnNFcnJvci5mc0Vycm9yVHlwZS5OT19TVUNIX0ZJTEVfT1JfRElSRUNUT1JZKVxuICAgIH07XG4gIH1cblxuICB2YXIgY2hpbGRQYXRoUGF0dGVybiA9IHBhdGhUb1JlbW92ZSA9PT0gJy8nID8gJy8qKicgOiBcIlwiLmNvbmNhdChwYXRoVG9SZW1vdmUsIFwiLyoqXCIpO1xuICB2YXIgY2hpbGRQYXRocyA9IEdsb2JVdGlsLmdsb2JQYXRocyhmcywgY2hpbGRQYXRoUGF0dGVybik7XG5cbiAgaWYgKCFpc05vbkVtcHR5RGlyZWN0b3J5UmVtb3ZhYmxlICYmICFjaGlsZFBhdGhzLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnI6ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLkRJUkVDVE9SWV9OT1RfRU1QVFkpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZnM6IGZzLnJlbW92ZUFsbChjaGlsZFBhdGhzLmNvbmNhdChwYXRoVG9SZW1vdmUpKVxuICB9O1xufTtcblxuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2ZzL29wZXJhdGlvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9mcy9vcGVyYXRpb25zL2RpcmVjdG9yeS1vcGVyYXRpb25zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZW5hbWVEaXJlY3RvcnkgPSBleHBvcnRzLmRlbGV0ZURpcmVjdG9yeSA9IGV4cG9ydHMuY29weURpcmVjdG9yeSA9IGV4cG9ydHMuYWRkRGlyZWN0b3J5ID0gZXhwb3J0cy5saXN0RGlyZWN0b3J5ID0gZXhwb3J0cy5saXN0RGlyZWN0b3J5Rm9sZGVycyA9IGV4cG9ydHMubGlzdERpcmVjdG9yeUZpbGVzID0gZXhwb3J0cy5oYXNEaXJlY3RvcnkgPSBleHBvcnRzLmZpbGxHYXBzID0gdm9pZCAwO1xuXG52YXIgRmlsZVV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy91dGlsL2ZpbGUtdXRpbCAqLyBcIi4vc3JjL2ZzL3V0aWwvZmlsZS11dGlsLmpzXCIpKTtcblxudmFyIEdsb2JVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvdXRpbC9nbG9iLXV0aWwgKi8gXCIuL3NyYy9mcy91dGlsL2dsb2ItdXRpbC5qc1wiKSk7XG5cbnZhciBQYXRoVXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL3V0aWwvcGF0aC11dGlsICovIFwiLi9zcmMvZnMvdXRpbC9wYXRoLXV0aWwuanNcIikpO1xuXG52YXIgQmFzZU9wID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvb3BlcmF0aW9ucy9iYXNlLW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zL2Jhc2Utb3BlcmF0aW9ucy5qc1wiKSk7XG5cbnZhciBfZnNFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL2ZzLWVycm9yICovIFwiLi9zcmMvZnMvZnMtZXJyb3IuanNcIik7XG5cbnZhciBfZmlsZU9wZXJhdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy9vcGVyYXRpb25zL2ZpbGUtb3BlcmF0aW9ucyAqLyBcIi4vc3JjL2ZzL29wZXJhdGlvbnMvZmlsZS1vcGVyYXRpb25zLmpzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobykgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAobyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkpIHsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgdGhyb3cgX2UyOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBpdCwgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTMpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UzOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciBvbmx5RmlsZXNGaWx0ZXIgPSBmdW5jdGlvbiBvbmx5RmlsZXNGaWx0ZXIoZnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIEZpbGVVdGlsLmlzRmlsZShmcy5nZXQocGF0aCkpO1xuICB9O1xufTtcblxudmFyIG9ubHlEaXJlY3Rvcmllc0ZpbHRlciA9IGZ1bmN0aW9uIG9ubHlEaXJlY3Rvcmllc0ZpbHRlcihmcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gRmlsZVV0aWwuaXNEaXJlY3RvcnkoZnMuZ2V0KHBhdGgpKTtcbiAgfTtcbn07XG4vKipcbiAqIEZpbGwgZmlsZSBzeXN0ZW0gZ2FwcyB3aXRoIGVtcHR5IGRpcmVjdG9yaWVzLlxuICpcbiAqIEVYUExBTkFUSU9OOlxuICogQSBmaWxlIHN5c3RlbSBjYW4gYmUgbGVmdCBpbiBhIHN0YXRlIHdoZXJlIHRoZXJlIHRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlXG4gKiBpcyBpbmNvbXBsZXRlIGFuZCB0aGVyZSBtYXkgYmUgaWxsb2dpY2FsIGdhcHMgaW4gdGhlIHN0cnVjdHVyZSBhZnRlclxuICogbWFudWFsbHkgY3JlYXRpbmcgb3IgZWRpdGluZyB0aGUgZmlsZSBzeXN0ZW0uXG4gKlxuICogRm9yIGV4YW1wbGUsIHdlIG1pZ2h0IGhhdmUgYSBmaWxlIHN5c3RlbSB0aGF0IGxvb2tzIGxpa2UgdGhpcyBhZnRlciBtYW51YWxseVxuICogYWRkaW5nIGEgZGlyZWN0b3J5IG9mICcvYS9iL2MnOlxuICpcbiAqIHtcbiAqICAnLyc6IHsuLn1cbiAqICAnL2EvYi9jJzogey4ufVxuICogfVxuICpcbiAqIEFzIGEgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb24sIHdlJ3JlIG1pc3NpbmcgZGlyZWN0b3JpZXMgb2YgJy9hJyBhbmQgJy9hL2InLlxuICogV2UgY2FuIGZpbGwgdGhlc2UgbWlzc2luZyBkaXJlY3RvcnkgZ2FwcyB0byBnZXQgYSBwcm9wZXJseSBmb3JtZWQgZGlyZWN0b3J5XG4gKiBzdHJ1Y3R1cmU6XG4gKlxuICoge1xuICogICcvJzogey4ufVxuICogICcvYSc6IHsuLn1cbiAqICAnL2EvYic6IHsuLn1cbiAqICAnL2EvYi9jJzogey4ufVxuICogfVxuICogQHBhcmFtICB7TWFwfSAgICBmcyAgIGZpbGUgc3lzdGVtIHdpdGggZ2FwcyBpbiBkaXJlY3Rvcnkgc3RydWN0dXJlXG4gKiBAcmV0dXJuIHtNYXB9ICAgICAgICAgZmlsZSBzeXN0ZW0gd2l0aG91dCBkaXJlY3RvcnkgZ2Fwc1xuICovXG5cblxudmFyIGZpbGxHYXBzID0gZnVuY3Rpb24gZmlsbEdhcHMoZnMpIHtcbiAgdmFyIGVtcHR5RGlyZWN0b3J5ID0gRmlsZVV0aWwubWFrZURpcmVjdG9yeSgpO1xuICB2YXIgZGlyZWN0b3J5R2FwUGF0aHMgPSBmcy5rZXlTZXEoKSAvLyBzZXF1ZW5jZSBvZiBwYXRoc1xuICAuZmxhdE1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiBQYXRoVXRpbC5nZXRQYXRoQnJlYWRDcnVtYnMocGF0aCk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiAhZnMuaGFzKHBhdGgpO1xuICB9KTtcbiAgcmV0dXJuIGZzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGZzKSB7XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRpcmVjdG9yeUdhcFBhdGhzKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGRpcmVjdG9yeUdhcFBhdGggPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgZnMuc2V0KGRpcmVjdG9yeUdhcFBhdGgsIGVtcHR5RGlyZWN0b3J5KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0cyBpbiB0aGUgZmlsZSBzeXN0ZW1cbiAqIEBwYXJhbSAge01hcH0gICAgIGZzICAgZmlsZSBzeXN0ZW1cbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGggcGF0aCB0byBjaGVjayBpZiBpcyBhIGRpcmVjdG9yeVxuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICB0cnVlLCBpZiB0aGUgZGlyZWN0b3J5IGV4aXN0c1xuICovXG5cblxuZXhwb3J0cy5maWxsR2FwcyA9IGZpbGxHYXBzO1xuXG52YXIgaGFzRGlyZWN0b3J5ID0gZnVuY3Rpb24gaGFzRGlyZWN0b3J5KGZzLCBwYXRoKSB7XG4gIHJldHVybiBmcy5oYXMocGF0aCkgJiYgRmlsZVV0aWwuaXNEaXJlY3RvcnkoZnMuZ2V0KHBhdGgpKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBsaXN0IG9mIGZpbGUgbmFtZXNcbiAqIEBwYXJhbSAge01hcH0gICAgZnMgICBmaWxlIHN5c3RlbVxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoIGRpcmVjdG9yeSBwYXRoIHRvIGxpc3QgZmlsZXMgaW5cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICBsaXN0IG9mIGZpbGUgbmFtZXMgb3IgYW4gZXJyb3JcbiAqL1xuXG5cbmV4cG9ydHMuaGFzRGlyZWN0b3J5ID0gaGFzRGlyZWN0b3J5O1xuXG52YXIgbGlzdERpcmVjdG9yeUZpbGVzID0gZnVuY3Rpb24gbGlzdERpcmVjdG9yeUZpbGVzKGZzLCBwYXRoKSB7XG4gIGlmICgoMCwgX2ZpbGVPcGVyYXRpb25zLmhhc0ZpbGUpKGZzLCBwYXRoKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnI6ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLkZJTEVfRVhJU1RTLCAnRmlsZSBleGlzdHMgYXQgcGF0aCcpXG4gICAgfTtcbiAgfVxuXG4gIGlmICghaGFzRGlyZWN0b3J5KGZzLCBwYXRoKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnI6ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLk5PX1NVQ0hfRElSRUNUT1JZLCAnQ2Fubm90IGxpc3QgZmlsZXMgaW4gbm9uLWV4aXN0ZW50IGRpcmVjdG9yeScpXG4gICAgfTtcbiAgfVxuXG4gIDtcbiAgdmFyIGZpbGVzUGF0dGVybiA9IHBhdGggPT09ICcvJyA/ICcvKicgOiBcIlwiLmNvbmNhdChwYXRoLCBcIi8qXCIpO1xuICByZXR1cm4ge1xuICAgIGxpc3Q6IEdsb2JVdGlsLmNhcHR1cmVHbG9iUGF0aHMoZnMsIGZpbGVzUGF0dGVybiwgb25seUZpbGVzRmlsdGVyKGZzKSlcbiAgfTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBsaXN0IG9mIGZvbGRlciBuYW1lcyBpbnNpZGUgdGhlIGN1cnJlbnQgZGlyZWN0b3J5LlxuICogQHBhcmFtICB7TWFwfSAgICBmcyAgIGZpbGUgc3lzdGVtXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGggcGF0aCB0byBsaXN0IGRpcmVjdG9yaWVzIGluXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgbGlzdCBvZiBkaXJlY3RvcmllcyBvciBhbiBlcnJvclxuICovXG5cblxuZXhwb3J0cy5saXN0RGlyZWN0b3J5RmlsZXMgPSBsaXN0RGlyZWN0b3J5RmlsZXM7XG5cbnZhciBsaXN0RGlyZWN0b3J5Rm9sZGVycyA9IGZ1bmN0aW9uIGxpc3REaXJlY3RvcnlGb2xkZXJzKGZzLCBwYXRoKSB7XG4gIHZhciBpc1RyYWlsaW5nU2xhc2hBcHBlbmRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICBpZiAoKDAsIF9maWxlT3BlcmF0aW9ucy5oYXNGaWxlKShmcywgcGF0aCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyOiAoMCwgX2ZzRXJyb3IubWFrZUVycm9yKShfZnNFcnJvci5mc0Vycm9yVHlwZS5GSUxFX0VYSVNUUywgJ0ZpbGUgZXhpc3RzIGF0IHBhdGgnKVxuICAgIH07XG4gIH1cblxuICBpZiAoIWhhc0RpcmVjdG9yeShmcywgcGF0aCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyOiAoMCwgX2ZzRXJyb3IubWFrZUVycm9yKShfZnNFcnJvci5mc0Vycm9yVHlwZS5OT19TVUNIX0RJUkVDVE9SWSwgJ0Nhbm5vdCBsaXN0IGZvbGRlcnMgaW4gbm9uLWV4aXN0ZW50IGRpcmVjdG9yeScpXG4gICAgfTtcbiAgfVxuXG4gIDtcbiAgdmFyIGZvbGRlcnNQYXR0ZXJuID0gcGF0aCA9PT0gJy8nID8gJy8qJyA6IFwiXCIuY29uY2F0KHBhdGgsIFwiLypcIik7XG4gIHZhciBmb2xkZXJOYW1lcyA9IEdsb2JVdGlsLmNhcHR1cmVHbG9iUGF0aHMoZnMsIGZvbGRlcnNQYXR0ZXJuLCBvbmx5RGlyZWN0b3JpZXNGaWx0ZXIoZnMpKTtcblxuICBpZiAoaXNUcmFpbGluZ1NsYXNoQXBwZW5kZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGlzdDogZm9sZGVyTmFtZXMubWFwKGZ1bmN0aW9uIChmb2xkZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChmb2xkZXJOYW1lLCBcIi9cIik7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpc3Q6IGZvbGRlck5hbWVzXG4gIH07XG59O1xuLyoqXG4gKiBMaXN0cyBmaWxlcyBhbmQgZm9sZGVycyBpbiBhIGRpcmVjdG9yeVxuICogQHBhcmFtICB7TWFwfSAgICAgZnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgc3lzdGVtXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5IHBhdGggdG8gbGlzdCBmaWxlcyBhbmQgZm9sZGVycyBpblxuICogQHBhcmFtICB7Ym9vbGVhbn0gW2FkZFRyYWlsaW5nU2xhc2g9dHJ1ZV0gICAgICAgICAgICAgICAgIGFkZCBhIC8gdG8gdGhlIGVuZCBvZiBmb2xkZXIgbmFtZXNcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHN5c3RlbSBvciBhbiBlcnJvclxuICovXG5cblxuZXhwb3J0cy5saXN0RGlyZWN0b3J5Rm9sZGVycyA9IGxpc3REaXJlY3RvcnlGb2xkZXJzO1xuXG52YXIgbGlzdERpcmVjdG9yeSA9IGZ1bmN0aW9uIGxpc3REaXJlY3RvcnkoZnMsIHBhdGgpIHtcbiAgdmFyIGFkZFRyYWlsaW5nU2xhc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG5cbiAgdmFyIF9saXN0RGlyZWN0b3J5RmlsZXMgPSBsaXN0RGlyZWN0b3J5RmlsZXMoZnMsIHBhdGgpLFxuICAgICAgbGlzdEZpbGVFcnIgPSBfbGlzdERpcmVjdG9yeUZpbGVzLmVycixcbiAgICAgIGZpbGVMaXN0ID0gX2xpc3REaXJlY3RvcnlGaWxlcy5saXN0O1xuXG4gIHZhciBfbGlzdERpcmVjdG9yeUZvbGRlcnMgPSBsaXN0RGlyZWN0b3J5Rm9sZGVycyhmcywgcGF0aCwgYWRkVHJhaWxpbmdTbGFzaCksXG4gICAgICBsaXN0Rm9sZGVyRXJyID0gX2xpc3REaXJlY3RvcnlGb2xkZXJzLmVycixcbiAgICAgIGZvbGRlckxpc3QgPSBfbGlzdERpcmVjdG9yeUZvbGRlcnMubGlzdDtcblxuICBpZiAobGlzdEZpbGVFcnIgfHwgbGlzdEZvbGRlckVycikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnI6IGxpc3RGaWxlRXJyID8gbGlzdEZpbGVFcnIgOiBsaXN0Rm9sZGVyRXJyXG4gICAgfTtcbiAgfVxuXG4gIDtcbiAgcmV0dXJuIHtcbiAgICBsaXN0OiBmaWxlTGlzdC5jb25jYXQoZm9sZGVyTGlzdClcbiAgfTtcbn07XG4vKipcbiAqIEFkZHMgYSBkaXJlY3RvcnkgdG8gdGhlIGZpbGUgc3lzdGVtXG4gKiBAcGFyYW0ge01hcH0gICAgIGZzICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSBzeXN0ZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSAgcGF0aCAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoIHRvIGFkZCBhIGRpcmVjdG9yeSB0b1xuICogQHBhcmFtIHtNYXB9ICAgICBkaXIgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeVxuICogQHBhcmFtIHtib29sZWFufSBbaXNSZXBsYWNlRXhpc3RpbmdEaXI9ZmFsc2VdIHdoZXRoZXIgYSBkaXJlY3RvcnkgY2FuIGJlIG92ZXJ3cml0dGVuIGlmIGl0IGFscmVhZHkgZXhpc3RzXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSBzeXN0ZW0gb3IgYW4gZXJyb3JcbiAqL1xuXG5cbmV4cG9ydHMubGlzdERpcmVjdG9yeSA9IGxpc3REaXJlY3Rvcnk7XG5cbnZhciBhZGREaXJlY3RvcnkgPSBmdW5jdGlvbiBhZGREaXJlY3RvcnkoZnMsIHBhdGgsIGRpcikge1xuICB2YXIgYWRkUGFyZW50UGF0aHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG5cbiAgaWYgKCgwLCBfZmlsZU9wZXJhdGlvbnMuaGFzRmlsZSkoZnMsIFBhdGhVdGlsLmdldFBhdGhQYXJlbnQocGF0aCkpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycjogKDAsIF9mc0Vycm9yLm1ha2VFcnJvcikoX2ZzRXJyb3IuZnNFcnJvclR5cGUuRklMRV9FWElTVFMsICdGaWxlIGV4aXN0cyBhdCBwYXRoJylcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEJhc2VPcC5hZGQoZnMsIHBhdGgsIGRpciwgYWRkUGFyZW50UGF0aHMpO1xufTtcbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgZnVuY3Rpb24gaW1wbGVtZW50aW5nIHJ1bGVzIGZvciByZXBsYWNpbmcgYSBzb3VyY2UgcGF0aCAodGhlIHBhdGhcbiAqIHdlJ3JlIGNvcHlpbmcgZnJvbSkgd2l0aCBhIGRlc3RpbmF0aW9uIHBhdGggKHRoZSBwYXRoIHdlJ3JlIGNvcHlpbmcgdG8pLiBOb3RlXG4gKiB0aGF0IGluIG91ciBmaWxlIHN5c3RlbTpcbiAqIC0gQSBmaWxlIGNhbm5vdCBvdmVyd3JpdGUgYSBkaXJlY3RvcnksXG4gKiAtIGEgZGlyZWN0b3J5IGNhbm5vdCBvdmVyd3JpdGUgYSBmaWxlLCBhbmRcbiAqIC0gYSBmaWxlL2RpcmVjdG9yeSBjYW4gb3ZlcndyaXRlIGEgZmlsZS9kaXJlY3RvcnkuXG4gKiBAcGFyYW0gIHtNYXB9ICAgICAgIGZzICAgICAgZmlsZSBzeXN0ZW1cbiAqIEBwYXJhbSAge1NlcXVlbmNlfSAgcGF0aFNlcSBzZXF1ZW5jZSBvZiBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIHBhdGhzXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgdHJ1ZSwgaWYgYSBzb3VyY2UgcGF0aCBjYW4gcmVwbGFjZSBhIGRlc3RpbmF0aW9uIHBhdGhcbiAqL1xuXG5cbmV4cG9ydHMuYWRkRGlyZWN0b3J5ID0gYWRkRGlyZWN0b3J5O1xuXG52YXIgaXNQYXRoVHlwZU1hdGNoaW5nID0gZnVuY3Rpb24gaXNQYXRoVHlwZU1hdGNoaW5nKGZzLCBwYXRoU2VxKSB7XG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGF0aFNlcSksXG4gICAgICBfc3RlcDI7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgc3JjUGF0aCA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICBkZXN0UGF0aCA9IF9zdGVwMiR2YWx1ZVsxXTtcblxuICAgICAgaWYgKGZzLmhhcyhkZXN0UGF0aCkpIHtcbiAgICAgICAgaWYgKCgwLCBfZmlsZU9wZXJhdGlvbnMuaGFzRmlsZSkoZnMsIHNyY1BhdGgpICYmIGhhc0RpcmVjdG9yeShmcywgZGVzdFBhdGgpKSB7XG4gICAgICAgICAgLy8gQ2Fubm90IG92ZXJ3cml0ZSBhIGZpbGUgd2l0aCBhIGRpcmVjdG9yeVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNEaXJlY3RvcnkoZnMsIHNyY1BhdGgpICYmICgwLCBfZmlsZU9wZXJhdGlvbnMuaGFzRmlsZSkoZnMsIGRlc3RQYXRoKSkge1xuICAgICAgICAgIC8vIENhbm5vdCBvdmVyd3JpdGUgYSBkaXJlY3Rvcnkgd2l0aCBhIGZpbGVcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIuZigpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBDb3BpZXMgYSBkaXJlY3RvcnkgKGFuZCBhbGwgZGlyZWN0b3JpZXMgaW5jbHVkZWQgaW5zaWRlIHRoYXQgZGlyZWN0b3J5KVxuICogZnJvbSBhIHNvdXJjZSBkaXJlY3RvcnkgdG8gYSBkZXN0aW5hdGlvbiBkaXJlY3RvcnlcbiAqXG4gKiBJZiB0aGUgZGVzdGluYXRpb24gZG9lc24ndCBleGlzdCwgaXQgY2FuIGJlIGNyZWF0ZWQuXG4gKlxuICogVGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gbXVzdCBiZSBhIGRpcmVjdG9yeSBhbmQgbm90IGEgZmlsZS5cbiAqIEBwYXJhbSAge01hcH0gICAgIGZzICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHN5c3RlbVxuICogQHBhcmFtICB7c3RyaW5nfSAgc3JjUGF0aCAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeSBwYXRoIHRvIGNvcHkgZnJvbVxuICogQHBhcmFtICB7c3RyaW5nfSAgZGVzdFBhdGggICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeSBwYXRoIHRvIGNvcHkgdG9cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHN5c3RlbSBvciBhbiBlcnJvclxuICovXG5cblxudmFyIGNvcHlEaXJlY3RvcnkgPSBmdW5jdGlvbiBjb3B5RGlyZWN0b3J5KGZzLCBzcmNQYXRoLCBkZXN0UGF0aCkge1xuICB2YXIgb3ZlcndyaXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuXG4gIGlmICghaGFzRGlyZWN0b3J5KGZzLCBzcmNQYXRoKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnI6ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLk5PX1NVQ0hfRElSRUNUT1JZLCAnU291cmNlIGRpcmVjdG9yeSBkb2VzIG5vdCBleGlzdCcpXG4gICAgfTtcbiAgfVxuXG4gIDtcblxuICBpZiAoIWhhc0RpcmVjdG9yeShmcywgZGVzdFBhdGgpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycjogKDAsIF9mc0Vycm9yLm1ha2VFcnJvcikoX2ZzRXJyb3IuZnNFcnJvclR5cGUuTk9fU1VDSF9ESVJFQ1RPUlksICdEZXN0aW5hdGlvbiBkaXJlY3RvcnkgZG9lcyBub3QgZXhpc3QnKVxuICAgIH07XG4gIH1cblxuICA7XG4gIHZhciBzcmNDaGlsZFBhdHRlcm4gPSBzcmNQYXRoID09PSAnLycgPyAnLyoqJyA6IFwiXCIuY29uY2F0KHNyY1BhdGgsIFwiLyoqXCIpO1xuICB2YXIgc3JjUGF0aHMgPSBHbG9iVXRpbC5nbG9iUGF0aHMoZnMsIHNyY0NoaWxkUGF0dGVybik7XG4gIHZhciBzcmNTdWJQYXRocyA9IEdsb2JVdGlsLmNhcHR1cmVHbG9iUGF0aHMoZnMsIHNyY0NoaWxkUGF0dGVybik7XG4gIHZhciBkZXN0UGF0aHMgPSBzcmNTdWJQYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aCA9PT0gJy8nID8gZGVzdFBhdGggOiBcIlwiLmNvbmNhdChkZXN0UGF0aCwgXCIvXCIpLmNvbmNhdChwYXRoKTtcbiAgfSk7XG5cbiAgaWYgKCFpc1BhdGhUeXBlTWF0Y2hpbmcoZnMsIHNyY1BhdGhzLnppcChkZXN0UGF0aHMpKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnI6ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLk9USEVSLCAnQ2Fubm90IG92ZXJ3cml0ZSBhIGRpcmVjdG9yeSB3aXRoIGZpbGUgT1IgYSBmaWxlIHdpdGggZGlyZWN0b3J5JylcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmczogZnMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobmV3RnMpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3JjUGF0aHMuemlwKGRlc3RQYXRocykpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgX3NyY1BhdGggPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIF9kZXN0UGF0aCA9IF9zdGVwMyR2YWx1ZVsxXTtcblxuICAgICAgICAgIGlmICghZnMuaGFzKF9kZXN0UGF0aCkgfHwgb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICBuZXdGcy5zZXQoX2Rlc3RQYXRoLCBmcy5nZXQoX3NyY1BhdGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuICAgIH0pXG4gIH07XG59O1xuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RvcnkgZnJvbSBhIGZpbGUgc3lzdGVtXG4gKiBAcGFyYW0gIHtNYXB9ICAgICBmcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSBzeXN0ZW1cbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhUb0RlbGV0ZSAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RvcnkgcGF0aCB0byBkZWxldGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtpc05vbkVtcHR5RGlyZWN0b3J5UmVtb3ZhYmxlPWZhbHNlXSB3aGV0aGVyIGRpcmVjdG9yaWVzIHdpdGggZmlsZXMgaW4gdGhlbSBjYW4gYmUgcmVtb3ZlZFxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgc3lzdGVtIG9yIGFuIGVycm9yXG4gKi9cblxuXG5leHBvcnRzLmNvcHlEaXJlY3RvcnkgPSBjb3B5RGlyZWN0b3J5O1xuXG52YXIgZGVsZXRlRGlyZWN0b3J5ID0gZnVuY3Rpb24gZGVsZXRlRGlyZWN0b3J5KGZzLCBwYXRoVG9EZWxldGUpIHtcbiAgdmFyIGlzTm9uRW1wdHlEaXJlY3RvcnlSZW1vdmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIGlmICgoMCwgX2ZpbGVPcGVyYXRpb25zLmhhc0ZpbGUpKGZzLCBwYXRoVG9EZWxldGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycjogKDAsIF9mc0Vycm9yLm1ha2VFcnJvcikoX2ZzRXJyb3IuZnNFcnJvclR5cGUuRklMRV9FWElTVFMsICdGaWxlIGV4aXN0cyBhdCBwYXRoJylcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFoYXNEaXJlY3RvcnkoZnMsIHBhdGhUb0RlbGV0ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyOiAoMCwgX2ZzRXJyb3IubWFrZUVycm9yKShfZnNFcnJvci5mc0Vycm9yVHlwZS5OT19TVUNIX0RJUkVDVE9SWSwgXCJObyBzdWNoIGRpcmVjdG9yeTogXCIuY29uY2F0KHBhdGhUb0RlbGV0ZSkpXG4gICAgfTtcbiAgfVxuXG4gIDtcbiAgcmV0dXJuIEJhc2VPcC5yZW1vdmUoZnMsIHBhdGhUb0RlbGV0ZSwgaXNOb25FbXB0eURpcmVjdG9yeVJlbW92YWJsZSk7XG59O1xuLyoqXG4gKiBSZW5hbWUgYSBkaXJlY3RvcnlcbiAqIEBwYXJhbSAge01hcH0gICAgZnMgICAgICAgICAgZmlsZSBzeXN0ZW1cbiAqIEBwYXJhbSAge3N0cmluZ30gY3VycmVudFBhdGggZGlyZWN0b3J5IHBhdGggdG8gcmVuYW1lIChhbmQgaGVuY2UgcmVtb3ZlKVxuICogQHBhcmFtICB7c3RyaW5nfSBuZXdQYXRoICAgICBwYXRoIHRvIHBsYWNlIHRoZSByZW5hbWVkIGRpcmVjdG9yeVxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICBmaWxlIHN5c3RlbSBvciBhbiBlcnJvclxuICovXG5cblxuZXhwb3J0cy5kZWxldGVEaXJlY3RvcnkgPSBkZWxldGVEaXJlY3Rvcnk7XG5cbnZhciByZW5hbWVEaXJlY3RvcnkgPSBmdW5jdGlvbiByZW5hbWVEaXJlY3RvcnkoZnMsIGN1cnJlbnRQYXRoLCBuZXdQYXRoKSB7XG4gIHZhciBfY29weURpcmVjdG9yeSA9IGNvcHlEaXJlY3RvcnkoZnMsIGN1cnJlbnRQYXRoLCBuZXdQYXRoLCB0cnVlKSxcbiAgICAgIGVyciA9IF9jb3B5RGlyZWN0b3J5LmVycixcbiAgICAgIGNvcGllZEZTID0gX2NvcHlEaXJlY3RvcnkuZnM7XG5cbiAgaWYgKGVycikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnI6IGVyclxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZGVsZXRlRGlyZWN0b3J5KGNvcGllZEZTLCBjdXJyZW50UGF0aCwgdHJ1ZSk7XG59O1xuXG5leHBvcnRzLnJlbmFtZURpcmVjdG9yeSA9IHJlbmFtZURpcmVjdG9yeTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZnMvb3BlcmF0aW9ucy9maWxlLW9wZXJhdGlvbnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZnMvb3BlcmF0aW9ucy9maWxlLW9wZXJhdGlvbnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWxldGVGaWxlID0gZXhwb3J0cy5jb3B5RmlsZSA9IGV4cG9ydHMud3JpdGVGaWxlID0gZXhwb3J0cy5yZWFkRmlsZSA9IGV4cG9ydHMuaGFzRmlsZSA9IHZvaWQgMDtcblxudmFyIFBhdGhVdGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnMvdXRpbC9wYXRoLXV0aWwgKi8gXCIuL3NyYy9mcy91dGlsL3BhdGgtdXRpbC5qc1wiKSk7XG5cbnZhciBCYXNlT3AgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy9vcGVyYXRpb25zL2Jhc2Utb3BlcmF0aW9ucyAqLyBcIi4vc3JjL2ZzL29wZXJhdGlvbnMvYmFzZS1vcGVyYXRpb25zLmpzXCIpKTtcblxudmFyIF9maWxlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL3V0aWwvZmlsZS11dGlsICovIFwiLi9zcmMvZnMvdXRpbC9maWxlLXV0aWwuanNcIik7XG5cbnZhciBfZGlyZWN0b3J5T3BlcmF0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzL29wZXJhdGlvbnMvZGlyZWN0b3J5LW9wZXJhdGlvbnMgKi8gXCIuL3NyYy9mcy9vcGVyYXRpb25zL2RpcmVjdG9yeS1vcGVyYXRpb25zLmpzXCIpO1xuXG52YXIgX2ZzRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy9mcy1lcnJvciAqLyBcIi4vc3JjL2ZzL2ZzLWVycm9yLmpzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZmlsZSBleGlzdHNcbiAqIEBwYXJhbSAge01hcH0gICAgIGZzICAgICAgIGZpbGUgc3lzdGVtXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBkaXJQYXRoICBkaXJlY3Rvcnkgb2YgdGhlIGZpbGUgdG8gY2hlY2sgZm9yIGV4aXN0ZW5jZVxuICogQHBhcmFtICB7c3RyaW5nfSAgZmlsZU5hbWUgZmlsZSBuYW1lIHRvIGNoZWNrIGZvciBleGlzdGVuY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIHRydWUsIGlmIHRoZSBmaWxlIGV4aXN0c1xuICovXG52YXIgaGFzRmlsZSA9IGZ1bmN0aW9uIGhhc0ZpbGUoZnMsIGZpbGVQYXRoKSB7XG4gIGlmIChmcy5oYXMoZmlsZVBhdGgpKSB7XG4gICAgdmFyIHBvc3NpYmxlRmlsZSA9IGZzLmdldChmaWxlUGF0aCk7XG4gICAgcmV0dXJuICgwLCBfZmlsZVV0aWwuaXNGaWxlKShwb3NzaWJsZUZpbGUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogR2V0IGEgZmlsZSBmcm9tIHRoZSBmaWxlIHN5c3RlbVxuICogQHBhcmFtICB7TWFwfSAgICBmcyAgICAgICBmaWxlIHN5c3RlbVxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlUGF0aCBwYXRoIHRvIGZpbGUgdG8gcmVhZFxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBmaWxlIHN5c3RlbSBvciBhbiBlcnJvclxuICovXG5cblxuZXhwb3J0cy5oYXNGaWxlID0gaGFzRmlsZTtcblxudmFyIHJlYWRGaWxlID0gZnVuY3Rpb24gcmVhZEZpbGUoZnMsIGZpbGVQYXRoKSB7XG4gIGlmICgoMCwgX2RpcmVjdG9yeU9wZXJhdGlvbnMuaGFzRGlyZWN0b3J5KShmcywgZmlsZVBhdGgpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycjogKDAsIF9mc0Vycm9yLm1ha2VFcnJvcikoX2ZzRXJyb3IuZnNFcnJvclR5cGUuSVNfQV9ESVJFQ1RPUlkpXG4gICAgfTtcbiAgfVxuXG4gIGlmICghaGFzRmlsZShmcywgZmlsZVBhdGgpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycjogKDAsIF9mc0Vycm9yLm1ha2VFcnJvcikoX2ZzRXJyb3IuZnNFcnJvclR5cGUuTk9fU1VDSF9GSUxFKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpbGU6IGZzLmdldChmaWxlUGF0aClcbiAgfTtcbn07XG4vKipcbiAqIFdyaXRlIGEgbmV3IGZpbGUgdG8gdGhlIGZpbGUgc3lzdGVtXG4gKiBAcGFyYW0gIHtNYXB9ICAgICBmcyAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHN5c3RlbVxuICogQHBhcmFtICB7c3RyaW5nfSAgZmlsZVBhdGggICAgICAgICAgICAgICAgICAgICAgcGF0aCB0byBuZXcgZmlsZVxuICogQHBhcmFtICB7TWFwfSAgICAgZmlsZSAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ldyBmaWxlXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHN5c3RlbSBvciBhbiBlcnJvclxuICovXG5cblxuZXhwb3J0cy5yZWFkRmlsZSA9IHJlYWRGaWxlO1xuXG52YXIgd3JpdGVGaWxlID0gZnVuY3Rpb24gd3JpdGVGaWxlKGZzLCBmaWxlUGF0aCwgZmlsZSkge1xuICByZXR1cm4gQmFzZU9wLmFkZChmcywgZmlsZVBhdGgsIGZpbGUpO1xufTtcbi8qKlxuICogQ29waWVzIGEgZmlsZSBmcm9tIGEgc291cmNlIGRpcmVjdG9yeSB0byBhIGRlc3RpbmF0aW9uIGRpcmVjdG9yeVxuICogQHBhcmFtICB7TWFwfSAgICBmcyAgICAgICAgICAgZmlsZSBzeXN0ZW1cbiAqIEBwYXJhbSAge3N0cmluZ30gc291cmNlUGF0aCAgIHBhdGggdG8gc291cmNlIGZpbGUgKHRvIGNvcHkgZnJvbSlcbiAqIEBwYXJhbSAge3N0cmluZ30gZGVzdFBhdGggICAgIHBhdGggdG8gZGVzdGluYXRpb24gZmlsZSAodG8gY29weSB0bylcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgIGZpbGUgc3lzdGVtIG9yIGFuIGVycm9yXG4gKi9cblxuXG5leHBvcnRzLndyaXRlRmlsZSA9IHdyaXRlRmlsZTtcblxudmFyIGNvcHlGaWxlID0gZnVuY3Rpb24gY29weUZpbGUoZnMsIHNvdXJjZVBhdGgsIGRlc3RQYXRoKSB7XG4gIGlmICghaGFzRmlsZShmcywgc291cmNlUGF0aCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyOiAoMCwgX2ZzRXJyb3IubWFrZUVycm9yKShfZnNFcnJvci5mc0Vycm9yVHlwZS5OT19TVUNIX0ZJTEUsICdTb3VyY2UgZmlsZSBkb2VzIG5vdCBleGlzdCcpXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwYXRoUGFyZW50ID0gUGF0aFV0aWwuZ2V0UGF0aFBhcmVudChkZXN0UGF0aCk7XG5cbiAgaWYgKCEoMCwgX2RpcmVjdG9yeU9wZXJhdGlvbnMuaGFzRGlyZWN0b3J5KShmcywgcGF0aFBhcmVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyOiAoMCwgX2ZzRXJyb3IubWFrZUVycm9yKShfZnNFcnJvci5mc0Vycm9yVHlwZS5OT19TVUNIX0RJUkVDVE9SWSwgJ0Rlc3RpbmF0aW9uIGRpcmVjdG9yeSBkb2VzIG5vdCBleGlzdCcpXG4gICAgfTtcbiAgfVxuXG4gIGlmICgoMCwgX2RpcmVjdG9yeU9wZXJhdGlvbnMuaGFzRGlyZWN0b3J5KShmcywgZGVzdFBhdGgpKSB7XG4gICAgLy8gQ29weWluZyBmaWxlIHRvIGRpcmVjdG9yeSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGZpbGVuYW1lIGV4cGxpY2l0bHlcbiAgICB2YXIgc291cmNlRmlsZU5hbWUgPSBQYXRoVXRpbC5nZXRMYXN0UGF0aFBhcnQoc291cmNlUGF0aCk7XG4gICAgZGVzdFBhdGggPSBkZXN0UGF0aCA9PT0gJy8nID8gXCIvXCIuY29uY2F0KHNvdXJjZUZpbGVOYW1lKSA6IFwiXCIuY29uY2F0KGRlc3RQYXRoLCBcIi9cIikuY29uY2F0KHNvdXJjZUZpbGVOYW1lKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZnM6IGZzLnNldChkZXN0UGF0aCwgZnMuZ2V0KHNvdXJjZVBhdGgpKVxuICB9O1xufTtcbi8qKlxuICogUmVtb3ZlcyBhIGZpbGUgZnJvbSB0aGUgZmlsZSBzeXN0ZW1cbiAqIEBwYXJhbSAge01hcH0gICAgZnMgICAgICAgZmlsZSBzeXN0ZW1cbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZVBhdGggcGF0aCB0byB0aGUgZmlsZSB0byBkZWxldGVcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgZmlsZSBzeXN0ZW0gb3IgYW4gZXJyb3JcbiAqL1xuXG5cbmV4cG9ydHMuY29weUZpbGUgPSBjb3B5RmlsZTtcblxudmFyIGRlbGV0ZUZpbGUgPSBmdW5jdGlvbiBkZWxldGVGaWxlKGZzLCBmaWxlUGF0aCkge1xuICBpZiAoKDAsIF9kaXJlY3RvcnlPcGVyYXRpb25zLmhhc0RpcmVjdG9yeSkoZnMsIGZpbGVQYXRoKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnI6ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLklTX0FfRElSRUNUT1JZKVxuICAgIH07XG4gIH1cblxuICBpZiAoIWhhc0ZpbGUoZnMsIGZpbGVQYXRoKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnI6ICgwLCBfZnNFcnJvci5tYWtlRXJyb3IpKF9mc0Vycm9yLmZzRXJyb3JUeXBlLk5PX1NVQ0hfRklMRSlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEJhc2VPcC5yZW1vdmUoZnMsIGZpbGVQYXRoKTtcbn07XG5cbmV4cG9ydHMuZGVsZXRlRmlsZSA9IGRlbGV0ZUZpbGU7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2ZzL3V0aWwvZmlsZS11dGlsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2ZzL3V0aWwvZmlsZS11dGlsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VEaXJlY3RvcnkgPSBleHBvcnRzLm1ha2VGaWxlID0gZXhwb3J0cy5pc0RpcmVjdG9yeSA9IGV4cG9ydHMuaXNGaWxlID0gdm9pZCAwO1xuXG52YXIgX2ltbXV0YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGltbXV0YWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2ltbXV0YWJsZS9kaXN0L2ltbXV0YWJsZS5lcy5qc1wiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgSmF2YVNjcmlwdCBvYmplY3QgaXMgYSBmaWxlIG9iamVjdFxuICogQHBhcmFtICB7b2JqZWN0fSAganNvbiBwb3RlbnRpYWwgZmlsZVxuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICB3aGV0aGVyIHRoZSBvYmplY3QgY29uZm9ybXMgdG8gdGhlIGZpbGUgc2NoZW1hXG4gKi9cbnZhciBpc0ZpbGUgPSBmdW5jdGlvbiBpc0ZpbGUobWFwKSB7XG4gIHJldHVybiBtYXAuaGFzKCdjb250ZW50Jyk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSBKYXZhU2NyaXB0IG9iamVjdCBpcyBhIGRpcmVjdG9yeSBvYmplY3RcbiAqIEBwYXJhbSAge29iamVjdH0gIGpzb24gcG90ZW50aWFsIGRpcmVjdG9yeVxuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICB3aGV0aGVyIHRoZSBvYmplY3QgY29uZm9ybXMgdG8gdGhlIGRpcmVjdG9yeSBzY2hlbWFcbiAqL1xuXG5cbmV4cG9ydHMuaXNGaWxlID0gaXNGaWxlO1xuXG52YXIgaXNEaXJlY3RvcnkgPSBmdW5jdGlvbiBpc0RpcmVjdG9yeShtYXApIHtcbiAgcmV0dXJuICFtYXAuaGFzKCdjb250ZW50Jyk7XG59O1xuLyoqXG4gKiBNYWtlcyBhbiBmaWxlIGNvbmZvcm1pbmcgdG8gdGhlIGZpbGUgc2NoZW1hXG4gKiBAcGFyYW0gIHtvYmplY3R9IGNvbnRlbnQgIGNvbnRlbnQgb2YgdGhlIGZpbGVcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgbmV3IGZpbGVcbiAqL1xuXG5cbmV4cG9ydHMuaXNEaXJlY3RvcnkgPSBpc0RpcmVjdG9yeTtcblxudmFyIG1ha2VGaWxlID0gZnVuY3Rpb24gbWFrZUZpbGUoKSB7XG4gIHZhciBjb250ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgdmFyIG1ldGFkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuICgwLCBfaW1tdXRhYmxlLmZyb21KUykoX29iamVjdFNwcmVhZCh7XG4gICAgY29udGVudDogY29udGVudFxuICB9LCBtZXRhZGF0YSkpO1xufTtcbi8qKlxuICogTWFrZXMgYW4gZGlyZWN0b3J5IGNvbmZvcm1pbmcgdG8gdGhlIGRpcmVjdG9yeSBzY2hlbWFcbiAqIEBwYXJhbSAge29iamVjdH0gY2hpbGRyZW4gY2hpbGQgZGlyZWN0b3JpZXMgb3IgZmlsZXNcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgbmV3IGRpcmVjdG9yeVxuICovXG5cblxuZXhwb3J0cy5tYWtlRmlsZSA9IG1ha2VGaWxlO1xuXG52YXIgbWFrZURpcmVjdG9yeSA9IGZ1bmN0aW9uIG1ha2VEaXJlY3RvcnkoKSB7XG4gIHZhciBtZXRhZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiAoMCwgX2ltbXV0YWJsZS5mcm9tSlMpKF9vYmplY3RTcHJlYWQoe30sIG1ldGFkYXRhKSk7XG59O1xuXG5leHBvcnRzLm1ha2VEaXJlY3RvcnkgPSBtYWtlRGlyZWN0b3J5O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9mcy91dGlsL2dsb2ItdXRpbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9mcy91dGlsL2dsb2ItdXRpbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYXB0dXJlR2xvYlBhdGhzID0gZXhwb3J0cy5nbG9iUGF0aHMgPSBleHBvcnRzLmdsb2JTZXEgPSBleHBvcnRzLmdsb2IgPSB2b2lkIDA7XG5cbnZhciBfbWluaW1hdGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBtaW5pbWF0Y2ggKi8gXCIuL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvbWluaW1hdGNoLmpzXCIpKTtcblxudmFyIF9taW5pbWF0Y2hDYXB0dXJlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBtaW5pbWF0Y2gtY2FwdHVyZSAqLyBcIi4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC1jYXB0dXJlL2luZGV4LmpzXCIpKTtcblxudmFyIF9pbW11dGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBpbW11dGFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9pbW11dGFibGUvZGlzdC9pbW11dGFibGUuZXMuanNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgR0xPQl9PUFRJT05TID0ge1xuICBkb3Q6IHRydWVcbn07XG5cbnZhciBnbG9iID0gZnVuY3Rpb24gZ2xvYihzdHIsIGdsb2JQYXR0ZXJuKSB7XG4gIHJldHVybiAoMCwgX21pbmltYXRjaFtcImRlZmF1bHRcIl0pKHN0ciwgZ2xvYlBhdHRlcm4sIEdMT0JfT1BUSU9OUyk7XG59O1xuXG5leHBvcnRzLmdsb2IgPSBnbG9iO1xuXG52YXIgZ2xvYlNlcSA9IGZ1bmN0aW9uIGdsb2JTZXEoc2VxLCBnbG9iUGF0dGVybikge1xuICByZXR1cm4gc2VxLmZpbHRlcihmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiAoMCwgX21pbmltYXRjaFtcImRlZmF1bHRcIl0pKHBhdGgsIGdsb2JQYXR0ZXJuLCBHTE9CX09QVElPTlMpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZ2xvYlNlcSA9IGdsb2JTZXE7XG5cbnZhciBnbG9iUGF0aHMgPSBmdW5jdGlvbiBnbG9iUGF0aHMoZnMsIGdsb2JQYXR0ZXJuKSB7XG4gIHJldHVybiBnbG9iU2VxKGZzLmtleVNlcSgpLCBnbG9iUGF0dGVybik7XG59O1xuXG5leHBvcnRzLmdsb2JQYXRocyA9IGdsb2JQYXRocztcblxudmFyIGNhcHR1cmVHbG9iUGF0aHMgPSBmdW5jdGlvbiBjYXB0dXJlR2xvYlBhdGhzKGZzLCBnbG9iUGF0dGVybikge1xuICB2YXIgZmlsdGVyQ29uZGl0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICByZXR1cm4gZnMua2V5U2VxKCkucmVkdWNlKGZ1bmN0aW9uIChjYXB0dXJlcywgcGF0aCkge1xuICAgIGlmIChmaWx0ZXJDb25kaXRpb24ocGF0aCkpIHtcbiAgICAgIHZhciBwYXRoQ2FwdHVyZXMgPSAoMCwgX21pbmltYXRjaENhcHR1cmVbXCJkZWZhdWx0XCJdKShwYXRoLCBnbG9iUGF0dGVybiwgR0xPQl9PUFRJT05TKTtcblxuICAgICAgaWYgKHBhdGhDYXB0dXJlcykge1xuICAgICAgICByZXR1cm4gY2FwdHVyZXMuY29uY2F0KHBhdGhDYXB0dXJlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhcHR1cmVzO1xuICB9LCAoMCwgX2ltbXV0YWJsZS5MaXN0KSgpKTtcbn07XG5cbmV4cG9ydHMuY2FwdHVyZUdsb2JQYXRocyA9IGNhcHR1cmVHbG9iUGF0aHM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2ZzL3V0aWwvcGF0aC11dGlsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2ZzL3V0aWwvcGF0aC11dGlsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnRvQWJzb2x1dGVQYXRoID0gZXhwb3J0cy5zcGxpdEZpbGVQYXRoID0gZXhwb3J0cy5nZXRMYXN0UGF0aFBhcnQgPSBleHBvcnRzLmdldFBhdGhQYXJlbnQgPSBleHBvcnRzLmdldFBhdGhCcmVhZENydW1icyA9IGV4cG9ydHMudG9QYXRoID0gZXhwb3J0cy50b1BhdGhQYXJ0cyA9IGV4cG9ydHMuaXNBYnNQYXRoID0gZXhwb3J0cy5yZW1vdmVUcmFpbGluZ1NlcGFyYXRvciA9IGV4cG9ydHMuaXNUcmFpbGluZ1BhdGggPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8pIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKG8gPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpKSB7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIGl0LCBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbi8qKlxuICogVGVzdHMgaWYgYSBwYXRoIGlzIGEgdHJhaWxpbmcgcGF0aC5cbiAqXG4gKiBBIHRyYWlsaW5nIHBhdGggZW5kcyB3aXRoIGEgdHJhaWxpbmcgc2xhc2ggKC8pIGFuZCBleGNsdWRlcyB0aGUgcm9vdFxuICogZGlyZWN0b3J5ICgvKS5cbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGggcGF0aCB3aXRoIG9yIHdpdGhvdXQgYSB0cmFpbGluZyBzbGFzaFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICB0cnVlLCBpZiB0aGUgcGF0aCBpcyBhIHRyYWlsaW5nIHBhdGhcbiAqL1xudmFyIGlzVHJhaWxpbmdQYXRoID0gZnVuY3Rpb24gaXNUcmFpbGluZ1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5lbmRzV2l0aCgnLycpICYmIHBhdGggIT09ICcvJztcbn07XG4vKipcbiAqIFJlbW92ZXMgYSB0cmFpbGluZyBzbGFzaCAoLykgZnJvbSBhIHBhdGhcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aCBwYXRoIHdpdGggb3Igd2l0aG91dCBhIHRyYWlsaW5nIC9cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICBwYXRoIHdpdGhvdXQgdHJhaWxpbmcgL1xuICovXG5cblxuZXhwb3J0cy5pc1RyYWlsaW5nUGF0aCA9IGlzVHJhaWxpbmdQYXRoO1xuXG52YXIgcmVtb3ZlVHJhaWxpbmdTZXBhcmF0b3IgPSBmdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NlcGFyYXRvcihwYXRoKSB7XG4gIGlmIChwYXRoLmVuZHNXaXRoKCcvJykgJiYgcGF0aCAhPT0gJy8nKSB7XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuLyoqXG4gKiBUZXN0cyBpZiBhIHBhdGggaXMgYWJzb2x1dGVcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5leHBvcnRzLnJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yID0gcmVtb3ZlVHJhaWxpbmdTZXBhcmF0b3I7XG5cbnZhciBpc0Fic1BhdGggPSBmdW5jdGlvbiBpc0Fic1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5zdGFydHNXaXRoKCcvJyk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIHBhdGggdG8gYW4gb3JkZXJlZCBhcnJheSBvZiBmb2xkZXJzIGFuZCBmaWxlcy5cbiAqXG4gKiBFeGFtcGxlOiBQYXJ0cyBvZiAnL2EvYi9jL2UudHh0JyBoYXMgcGFydHMgb2YgWycvJywgJ2EnLCAnYicsICdjJywgJ2UudHh0J11cbiAqXG4gKiBBIHJlbGF0aXZlIHBhdGggc3BsaXRzIHBhcnRzIGF0IC8uIEFuIGFic29sdXRlIHBhdGggc3BsaXRzIGF0IC8gYW5kIGFsc29cbiAqIGNvbnNpZGVycyB0aGUgcm9vdCBkaXJlY3RvcnkgKC8pIGFzIGEgcGFydCBvZiB0aGUgcGF0aC5cbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHthcnJheX0gICAgICAgbGlzdCBvZiBwYXRoIHBhcnRzXG4gKi9cblxuXG5leHBvcnRzLmlzQWJzUGF0aCA9IGlzQWJzUGF0aDtcblxudmFyIHRvUGF0aFBhcnRzID0gZnVuY3Rpb24gdG9QYXRoUGFydHMocGF0aCkge1xuICBpZiAocGF0aCA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIFsnLyddO1xuICB9XG5cbiAgO1xuICBwYXRoID0gcmVtb3ZlVHJhaWxpbmdTZXBhcmF0b3IocGF0aCk7XG4gIHZhciBwYXRoUGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XG5cbiAgaWYgKGlzQWJzUGF0aChwYXRoKSkge1xuICAgIHZhciBfcGF0aFBhcnRzID0gX3RvQXJyYXkocGF0aFBhcnRzKSxcbiAgICAgICAgbm9uUm9vdFBhdGhQYXJ0cyA9IF9wYXRoUGFydHMuc2xpY2UoMSk7XG5cbiAgICByZXR1cm4gWycvJ10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub25Sb290UGF0aFBhcnRzKSk7XG4gIH1cblxuICByZXR1cm4gcGF0aFBhcnRzO1xufTtcbi8qKlxuICogQ29udmVydHMgcGF0aCBwYXJ0cyBiYWNrIHRvIGEgcGF0aFxuICogQHBhcmFtICB7YXJyYXl9IHBhdGhQYXJ0cyBwYXRoIHBhcnRzXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgIHBhdGhcbiAqL1xuXG5cbmV4cG9ydHMudG9QYXRoUGFydHMgPSB0b1BhdGhQYXJ0cztcblxudmFyIHRvUGF0aCA9IGZ1bmN0aW9uIHRvUGF0aChwYXRoUGFydHMpIHtcbiAgaWYgKHBhdGhQYXJ0c1swXSA9PT0gJy8nKSB7XG4gICAgLy8gYWJzb2x1dGUgcGF0aFxuICAgIHZhciBfcGF0aFBhcnRzMiA9IF90b0FycmF5KHBhdGhQYXJ0cyksXG4gICAgICAgIG5vblJvb3RQYXRoUGFydHMgPSBfcGF0aFBhcnRzMi5zbGljZSgxKTtcblxuICAgIHJldHVybiBcIi9cIi5jb25jYXQobm9uUm9vdFBhdGhQYXJ0cy5qb2luKCcvJykpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhQYXJ0cy5qb2luKCcvJyk7XG59O1xuLyoqXG4gKiBGaW5kIGJyZWFkY3J1bWIgcGF0aHMsIGkuZS4gYWxsIHBhdGhzIHRoYXQgbmVlZCB0byBiZSB3YWxrZWQgdG8gZ2V0IHRvXG4gKiB0aGUgc3BlY2lmaWVkIHBhdGhcbiAqIEV4YW1wbGU6IC9hL2IvYyB3aWxsIGhhdmUgYnJlYWRjcnVtYiBwYXRocyBvZiAnLycsICcvYScsICcvYS9iJywgJy9hL2IvYydcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aCBwYXRoIHRvIGEgZGlyZWN0b3J5XG4gKiBAcmV0dXJuIHthcnJheX0gICAgICAgbGlzdCBvZiBwYXRocyB0aGF0IGxlYWQgdXAgdG8gYSBwYXRoXG4gKi9cblxuXG5leHBvcnRzLnRvUGF0aCA9IHRvUGF0aDtcblxudmFyIGdldFBhdGhCcmVhZENydW1icyA9IGZ1bmN0aW9uIGdldFBhdGhCcmVhZENydW1icyhwYXRoKSB7XG4gIHZhciBwYXRoUGFydHMgPSB0b1BhdGhQYXJ0cyhwYXRoKTtcblxuICBpZiAocGF0aFBhcnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIFsnLyddO1xuICB9XG5cbiAgdmFyIF9wYXRoUGFydHMzID0gX3RvQXJyYXkocGF0aFBhcnRzKSxcbiAgICAgIHNlY29uZFBhdGhQYXJ0ID0gX3BhdGhQYXJ0czNbMV0sXG4gICAgICBwYXRoUGFydHNXaXRob3V0Um9vdCA9IF9wYXRoUGFydHMzLnNsaWNlKDIpO1xuXG4gIHJldHVybiBwYXRoUGFydHNXaXRob3V0Um9vdC5yZWR1Y2UoZnVuY3Rpb24gKGJyZWFkQ3J1bWJzLCBwYXRoUGFydCkge1xuICAgIHZhciBwcmV2aW91c0JyZWFkQ3J1bWIgPSBicmVhZENydW1ic1ticmVhZENydW1icy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShicmVhZENydW1icyksIFtcIlwiLmNvbmNhdChwcmV2aW91c0JyZWFkQ3J1bWIsIFwiL1wiKS5jb25jYXQocGF0aFBhcnQpXSk7XG4gIH0sIFsnLycsIFwiL1wiLmNvbmNhdChzZWNvbmRQYXRoUGFydCldKTtcbn07XG4vKipcbiAqIFJlbW92ZXMgdGhlIGZpbGUgbmFtZSBmcm9tIHRoZSBlbmQgb2YgYSBmaWxlIHBhdGgsIHJldHVybmluZyB0aGUgcGF0aCB0byB0aGVcbiAqIGRpcmVjdG9yeSBvZiB0aGUgZmlsZVxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlUGF0aCBwYXRoIHdoaWNoIGVuZHMgd2l0aCBhIGZpbGUgbmFtZVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICBkaXJlY3RvcnkgcGF0aFxuICovXG5cblxuZXhwb3J0cy5nZXRQYXRoQnJlYWRDcnVtYnMgPSBnZXRQYXRoQnJlYWRDcnVtYnM7XG5cbnZhciBnZXRQYXRoUGFyZW50ID0gZnVuY3Rpb24gZ2V0UGF0aFBhcmVudChmaWxlUGF0aCkge1xuICBpZiAoZmlsZVBhdGggPT09ICcvJykge1xuICAgIHJldHVybiAnLyc7XG4gIH1cblxuICB2YXIgcGF0aFBhcnRzID0gdG9QYXRoUGFydHMoZmlsZVBhdGgpOyAvLyBjb252ZXJ0cyBwYXRoIHN0cmluZyB0byBhcnJheVxuXG4gIHZhciBwYXRoUGFydHNXaXRob3V0RmlsZU5hbWUgPSBwYXRoUGFydHMuc2xpY2UoMCwgLTEpOyAvLyByZW1vdmVzIGxhc3QgZWxlbWVudCBvZiBhcnJheVxuXG4gIHJldHVybiB0b1BhdGgocGF0aFBhcnRzV2l0aG91dEZpbGVOYW1lKTtcbn07XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBmaWxlIG5hbWUgZnJvbSB0aGUgZW5kIG9mIHRoZSBmaWxlIHBhdGhcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZVBhdGggcGF0aCB3aGljaCBlbmRzIHdpdGggYSBmaWxlIG5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgZmlsZSBuYW1lIGZyb20gdGhlIHBhdGhcbiAqL1xuXG5cbmV4cG9ydHMuZ2V0UGF0aFBhcmVudCA9IGdldFBhdGhQYXJlbnQ7XG5cbnZhciBnZXRMYXN0UGF0aFBhcnQgPSBmdW5jdGlvbiBnZXRMYXN0UGF0aFBhcnQoZmlsZVBhdGgpIHtcbiAgdmFyIHBhdGhQYXJ0cyA9IHRvUGF0aFBhcnRzKGZpbGVQYXRoKTsgLy8gY29udmVydHMgcGF0aCBzdHJpbmcgdG8gYXJyYXlcblxuICByZXR1cm4gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXTtcbn07XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBmaWxlIG5hbWUgYW5kIGRpcmVjdG9yeSBwYXRoIGZyb20gYSBmaWxlIHBhdGhcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZVBhdGggcGF0aCB3aGljaCBlbmRzIHdpdGggYSBmaWxlIG5hbWVcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgb2JqZWN0IHdpdGggZGlyZWN0b3J5IGFuZCBmaWxlIG5hbWVcbiAqL1xuXG5cbmV4cG9ydHMuZ2V0TGFzdFBhdGhQYXJ0ID0gZ2V0TGFzdFBhdGhQYXJ0O1xuXG52YXIgc3BsaXRGaWxlUGF0aCA9IGZ1bmN0aW9uIHNwbGl0RmlsZVBhdGgoZmlsZVBhdGgpIHtcbiAgcmV0dXJuIHtcbiAgICAnZGlyUGF0aCc6IGdldFBhdGhQYXJlbnQoZmlsZVBhdGgpLFxuICAgICdmaWxlTmFtZSc6IGdldExhc3RQYXRoUGFydChmaWxlUGF0aClcbiAgfTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgcmVsYXRpdmUgcGF0aCB0byBhbiBhYnNvbHV0ZSBwYXRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJlbGF0aXZlUGF0aFxuICogQHBhcmFtICB7c3RyaW5nfSBjd2QgICAgICAgICAgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgICAgYWJzb2x1dGUgcGF0aFxuICovXG5cblxuZXhwb3J0cy5zcGxpdEZpbGVQYXRoID0gc3BsaXRGaWxlUGF0aDtcbnZhciBHT19VUCA9ICcuLic7XG52YXIgQ1VSUkVOVF9ESVIgPSAnLic7XG5cbnZhciBpc1N0YWNrQXRSb290RGlyZWN0b3J5ID0gZnVuY3Rpb24gaXNTdGFja0F0Um9vdERpcmVjdG9yeShzdGFjaykge1xuICByZXR1cm4gc3RhY2subGVuZ3RoID09PSAxICYmIHN0YWNrWzBdID09PSAnLyc7XG59O1xuXG52YXIgdG9BYnNvbHV0ZVBhdGggPSBmdW5jdGlvbiB0b0Fic29sdXRlUGF0aChyZWxhdGl2ZVBhdGgsIGN3ZCkge1xuICByZWxhdGl2ZVBhdGggPSByZW1vdmVUcmFpbGluZ1NlcGFyYXRvcihyZWxhdGl2ZVBhdGgpO1xuICB2YXIgcGF0aFN0YWNrID0gaXNBYnNQYXRoKHJlbGF0aXZlUGF0aCkgPyBbXSA6IHRvUGF0aFBhcnRzKGN3ZCk7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRvUGF0aFBhcnRzKHJlbGF0aXZlUGF0aCkpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIHBhdGhQYXJ0ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmIChwYXRoUGFydCA9PT0gR09fVVApIHtcbiAgICAgICAgaWYgKCFpc1N0YWNrQXRSb290RGlyZWN0b3J5KHBhdGhTdGFjaykpIHtcbiAgICAgICAgICBwYXRoU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGF0aFBhcnQgIT09IENVUlJFTlRfRElSKSB7XG4gICAgICAgIHBhdGhTdGFjay5wdXNoKHBhdGhQYXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHJldHVybiB0b1BhdGgocGF0aFN0YWNrKTtcbn07XG5cbmV4cG9ydHMudG9BYnNvbHV0ZVBhdGggPSB0b0Fic29sdXRlUGF0aDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZnMvdXRpbC9wZXJtaXNzaW9uLXV0aWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZnMvdXRpbC9wZXJtaXNzaW9uLXV0aWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYW5Nb2RpZnlQYXRoID0gdm9pZCAwO1xuXG52YXIgUGF0aFV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcy91dGlsL3BhdGgtdXRpbCAqLyBcIi4vc3JjL2ZzL3V0aWwvcGF0aC11dGlsLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobykgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAobyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkpIHsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgaXQsIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgREVGQVVMVF9QRVJNSVNTSU9OID0gdHJ1ZTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgc2luZ2xlIHBhdGggY2FuIGJlIG1vZGlmaWVkIGJ5IGNoZWNraW5nIHRoZSAnY2FuTW9kaWZ5JyBrZXkgaGVsZFxuICogaW4gdGhlIHBhdGguXG4gKlxuICogVGhpcyBkb2VzIE5PVCBjaGVjayBwYXJlbnRzIG9mIHRoZSBwYXRoLlxuICogQHBhcmFtICB7TWFwfSAgICAgZnMgICBmaWxlIHN5c3RlbVxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aCBwYXRoIHRvIGNoZWNrIGZvciBtb2RpZmljYXRpb24gcGVybWlzc2lvblxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICB0cnVlLCBpZiBhIHNpbmdsZSBwYXRoIGNhbiBiZSBtb2RpZmllZFxuICovXG5cbnZhciBpc01vZGlmaWNhdGlvbkFsbG93ZWQgPSBmdW5jdGlvbiBpc01vZGlmaWNhdGlvbkFsbG93ZWQoZnMsIHBhdGgpIHtcbiAgdmFyIGRpcmVjdG9yeSA9IGZzLmdldChwYXRoLCBudWxsKTtcblxuICBpZiAoZGlyZWN0b3J5KSB7XG4gICAgdmFyIGNhbk1vZGlmeSA9IGRpcmVjdG9yeS5nZXQoJ2Nhbk1vZGlmeScsIERFRkFVTFRfUEVSTUlTU0lPTik7XG5cbiAgICBpZiAoIWNhbk1vZGlmeSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgcGF0aCBhbmQgaXRzIHBhcmVudHMgY2FuIGJlIG1vZGlmaWVkLlxuICogQHBhcmFtICB7TWFwfSAgICAgZnMgICBmaWxlIHN5c3RlbXNcbiAqIEBwYXJhbSAge1N0cmluZ30gIHBhdGggcGF0aCB0byBhIGRpcmVjdG9yeSBvciBmaWxlXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIHRydWUsIGlmIHRoZSBwYXRoIGFuZCBpdHMgcGFyZW50cyBjYW4gYmUgbW9kaWZpZWRcbiAqL1xuXG5cbnZhciBjYW5Nb2RpZnlQYXRoID0gZnVuY3Rpb24gY2FuTW9kaWZ5UGF0aChmcywgcGF0aCkge1xuICB2YXIgYnJlYWRDcnVtYlBhdGhzID0gUGF0aFV0aWwuZ2V0UGF0aEJyZWFkQ3J1bWJzKHBhdGgpO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihicmVhZENydW1iUGF0aHMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGJyZWFkQ3J1bWJQYXRoID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmICghaXNNb2RpZmljYXRpb25BbGxvd2VkKGZzLCBicmVhZENydW1iUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLmNhbk1vZGlmeVBhdGggPSBjYW5Nb2RpZnlQYXRoO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW11bGF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VtdWxhdG9yW1wiZGVmYXVsdFwiXTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIaXN0b3J5S2V5Ym9hcmRQbHVnaW5cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0hpc3RvcnlLZXlib2FyZFBsdWdpbltcImRlZmF1bHRcIl07XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW11bGF0b3JTdGF0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW11bGF0b3JTdGF0ZS5FbXVsYXRvclN0YXRlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbW1hbmRNYXBwaW5nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbXVsYXRvclN0YXRlLkNvbW1hbmRNYXBwaW5nO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVudmlyb25tZW50VmFyaWFibGVzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbXVsYXRvclN0YXRlLkVudmlyb25tZW50VmFyaWFibGVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpbGVTeXN0ZW1cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VtdWxhdG9yU3RhdGUuRmlsZVN5c3RlbTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIaXN0b3J5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbXVsYXRvclN0YXRlLkhpc3Rvcnk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3V0cHV0c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW11bGF0b3JTdGF0ZS5PdXRwdXRzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk91dHB1dEZhY3RvcnlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VtdWxhdG9yT3V0cHV0Lk91dHB1dEZhY3Rvcnk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3V0cHV0VHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW11bGF0b3JPdXRwdXQuT3V0cHV0VHlwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaXJPcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZnMuRGlyT3A7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZU9wXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9mcy5GaWxlT3A7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3B0aW9uUGFyc2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wYXJzZXIuT3B0aW9uUGFyc2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRDb21tYW5kTWFwcGluZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29tbWFuZHNbXCJkZWZhdWx0XCJdO1xuICB9XG59KTtcblxudmFyIF9lbXVsYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3IgKi8gXCIuL3NyYy9lbXVsYXRvci9pbmRleC5qc1wiKSk7XG5cbnZhciBfSGlzdG9yeUtleWJvYXJkUGx1Z2luID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbXVsYXRvci9wbHVnaW5zL0hpc3RvcnlLZXlib2FyZFBsdWdpbiAqLyBcIi4vc3JjL2VtdWxhdG9yL3BsdWdpbnMvSGlzdG9yeUtleWJvYXJkUGx1Z2luLmpzXCIpKTtcblxudmFyIF9lbXVsYXRvclN0YXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW11bGF0b3Itc3RhdGUgKi8gXCIuL3NyYy9lbXVsYXRvci1zdGF0ZS9pbmRleC5qc1wiKTtcblxudmFyIF9lbXVsYXRvck91dHB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVtdWxhdG9yLW91dHB1dCAqLyBcIi4vc3JjL2VtdWxhdG9yLW91dHB1dC9pbmRleC5qc1wiKTtcblxudmFyIF9mcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGZzICovIFwiLi9zcmMvZnMvaW5kZXguanNcIik7XG5cbnZhciBfcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcGFyc2VyICovIFwiLi9zcmMvcGFyc2VyL2luZGV4LmpzXCIpO1xuXG52YXIgX2NvbW1hbmRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb21tYW5kcyAqLyBcIi4vc3JjL2NvbW1hbmRzL2luZGV4LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3BhcnNlci9jb21tYW5kLXBhcnNlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcGFyc2VyL2NvbW1hbmQtcGFyc2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBleHBvcnRzLnBhcnNlQ29tbWFuZHMgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF90b0FycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG4vKipcbiAqIFJlbW92ZXMgZXhjZXNzIHdoaXRlc3BhY2UgKD4gMSBzcGFjZSkgZnJvbSBlZGdlcyBvZiBzdHJpbmcgYW5kIGluc2lkZSBzdHJpbmcuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0ciBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgIHN0cmluZyB3aXRob3V0ID4gMSBzcGFjZSBvZiB3aGl0ZXNwYWNlXG4gKi9cbnZhciByZW1vdmVFeGNlc3NXaGl0ZVNwYWNlID0gZnVuY3Rpb24gcmVtb3ZlRXhjZXNzV2hpdGVTcGFjZShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltKCkucmVwbGFjZSgvXFxzXFxzKy9nLCAnICcpO1xufTtcbi8qKlxuICogUGxhY2VzIHRoZSBjb21tYW5kIG5hbWUgYW5kIGVhY2ggZm9sbG93aW5nIGFyZ3VtZW50IGludG8gYSBsaXN0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbW1hbmQgc2ggY29tbWFuZFxuICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgIGNvbW1hbmQgbmFtZSBhbmQgYXJndW1lbnRzIChpZiBhbnkpXG4gKi9cblxuXG52YXIgdG9Db21tYW5kUGFydHMgPSBmdW5jdGlvbiB0b0NvbW1hbmRQYXJ0cyhjb21tYW5kKSB7XG4gIHJldHVybiByZW1vdmVFeGNlc3NXaGl0ZVNwYWNlKGNvbW1hbmQpLnNwbGl0KC9cXHMvKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBsaXN0IG9mIGNvbW1hbmRzIHNwbGl0IGludG8gdGhlIGNvbW1hbmQgbmFtZSBhbmQgYXJndW1lbnRzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbW1hbmRzIGNvbW1hbmQgaW5wdXRcbiAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgbGlzdCBvZiBwYXJzZWQgY29tbWFuZFxuICovXG5cblxudmFyIHBhcnNlQ29tbWFuZHMgPSBmdW5jdGlvbiBwYXJzZUNvbW1hbmRzKGNvbW1hbmRzKSB7XG4gIHJldHVybiBjb21tYW5kcy5zcGxpdCgvJiZ8Oy8pIC8vIHNwbGl0IGNvbW1hbmQgZGVsaW1pdGVyczogYCYmYCBhbmQgYDtgXG4gIC5tYXAoZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICByZXR1cm4gdG9Db21tYW5kUGFydHMoY29tbWFuZCk7XG4gIH0pLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBfcmVmMiA9IF90b0FycmF5KF9yZWYpLFxuICAgICAgICBjb21tYW5kTmFtZSA9IF9yZWYyWzBdLFxuICAgICAgICBjb21tYW5kT3B0aW9ucyA9IF9yZWYyLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmROYW1lOiBjb21tYW5kTmFtZSxcbiAgICAgIGNvbW1hbmRPcHRpb25zOiBjb21tYW5kT3B0aW9uc1xuICAgIH07XG4gIH0pO1xufTtcblxuZXhwb3J0cy5wYXJzZUNvbW1hbmRzID0gcGFyc2VDb21tYW5kcztcbnZhciBfZGVmYXVsdCA9IHBhcnNlQ29tbWFuZHM7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wYXJzZXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BhcnNlci9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBPcHRpb25QYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBwYXJzZXIvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3BhcnNlci9vcHRpb24tcGFyc2VyLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxudmFyIF9kZWZhdWx0ID0ge1xuICBPcHRpb25QYXJzZXI6IE9wdGlvblBhcnNlclxufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcGFyc2VyL29wdGlvbi1wYXJzZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcGFyc2VyL29wdGlvbi1wYXJzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5wYXJzZU9wdGlvbnMgPSB2b2lkIDA7XG5cbnZhciBfZ2V0T3B0aW9ucyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZ2V0LW9wdGlvbnMgKi8gXCIuL25vZGVfbW9kdWxlcy9nZXQtb3B0aW9ucy9pbmRleC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBiaW5kaW5ncyBiYXNlZCBvbiBvcHREZWZzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbW1hbmRPcHRpb25zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBjb21tYW5kIGFyZ3VtZW50c1xuICogQHBhcmFtICB7b2JqZWN0fSBvcHREZWYgICAgICAgICBzZWUgZ2V0LW9wdGlvbnMgZG9jdW1lbnRhdGlvbiBmb3Igc2NoZW1hIGRldGFpbHNcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgb3B0aW9ucyBvYmplY3RcbiAqL1xudmFyIHBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhjb21tYW5kT3B0aW9ucywgb3B0RGVmKSB7XG4gIHJldHVybiAoMCwgX2dldE9wdGlvbnNbXCJkZWZhdWx0XCJdKShjb21tYW5kT3B0aW9ucywgb3B0RGVmLCB7XG4gICAgbm9BbGlhc1Byb3BhZ2F0aW9uOiAnZmlyc3Qtb25seSdcbiAgfSk7XG59O1xuXG5leHBvcnRzLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcbnZhciBfZGVmYXVsdCA9IHBhcnNlT3B0aW9ucztcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAwOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiBtdWx0aSAuL3NyYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC9Vc2Vycy90dXJ0bGUvRG9jdW1lbnRzL0dpdGh1Yi9qYXZhc2NyaXB0LXRlcm1pbmFsL3NyYy9pbmRleC5qcyAqL1wiLi9zcmMvaW5kZXguanNcIik7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlcm1pbmFsLmpzLm1hcCJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsImJhbGFuY2VkIiwiYSIsImIiLCJzdHIiLCJSZWdFeHAiLCJtYXliZU1hdGNoIiwicmFuZ2UiLCJzdGFydCIsImVuZCIsInByZSIsInNsaWNlIiwiYm9keSIsImxlbmd0aCIsInBvc3QiLCJyZWciLCJtYXRjaCIsImJlZ3MiLCJiZWciLCJsZWZ0IiwicmlnaHQiLCJyZXN1bHQiLCJhaSIsImluZGV4T2YiLCJiaSIsInB1c2giLCJwb3AiLCJjb25jYXRNYXAiLCJleHBhbmRUb3AiLCJlc2NTbGFzaCIsIk1hdGgiLCJyYW5kb20iLCJlc2NPcGVuIiwiZXNjQ2xvc2UiLCJlc2NDb21tYSIsImVzY1BlcmlvZCIsIm51bWVyaWMiLCJwYXJzZUludCIsImNoYXJDb2RlQXQiLCJlc2NhcGVCcmFjZXMiLCJzcGxpdCIsImpvaW4iLCJ1bmVzY2FwZUJyYWNlcyIsInBhcnNlQ29tbWFQYXJ0cyIsInBhcnRzIiwicG9zdFBhcnRzIiwic2hpZnQiLCJhcHBseSIsInN1YnN0ciIsImV4cGFuZCIsIm1hcCIsImlkZW50aXR5IiwiZSIsImVtYnJhY2UiLCJpc1BhZGRlZCIsImVsIiwidGVzdCIsImx0ZSIsInkiLCJndGUiLCJpc1RvcCIsImV4cGFuc2lvbnMiLCJpc051bWVyaWNTZXF1ZW5jZSIsImlzQWxwaGFTZXF1ZW5jZSIsImlzU2VxdWVuY2UiLCJpc09wdGlvbnMiLCJOIiwieCIsIndpZHRoIiwibWF4IiwiaW5jciIsImFicyIsInJldmVyc2UiLCJwYWQiLCJzb21lIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibmVlZCIsInoiLCJBcnJheSIsImoiLCJrIiwiZXhwYW5zaW9uIiwieHMiLCJmbiIsInJlcyIsImlzQXJyYXkiLCJ0b1N0cmluZyIsIk9wdGlvbiIsImNvbnN0cnVjdG9yIiwibmFtZXMiLCJwYXJhbXMiLCJzaG9ydE5hbWVzIiwibG9uZ05hbWVzIiwidmFsdWVzIiwiZGVmaW5lTmFtZXMiLCJkZWZpbmVQYXJhbXMiLCJpbnB1dCIsInRyaW0iLCJsYXN0UGFyZW4iLCJyZXBsYWNlIiwiZmlsdGVyIiwiQm9vbGVhbiIsInBhcmFtIiwiYXJncyIsInBhdHRlcm4iLCJ2YXJpYWRpYyIsImJ1bmRsZVBhdHRlcm4iLCJfYnVuZGxlUGF0dGVybiIsImFyaXR5IiwiY29uY2F0IiwiY2FuQ29sbGVjdCIsImFycmF5aWZ5IiwiZm9ybWF0TmFtZSIsIm5vQ2FtZWxDYXNlIiwidG9Mb3dlckNhc2UiLCJfIiwidG9VcHBlckNhc2UiLCJwYXR0ZXJucyIsInVuaXF1ZVN0cmluZ3MiLCJvdXRwdXQiLCJrZXlzIiwidW5zdHJpbmdpZnkiLCJ0b2tlbnMiLCJxdW90ZUNoYXIiLCJ0b2tlbkRhdGEiLCJpc0VzY2FwZWQiLCJjaGFyIiwibmV4dCIsImF1dG9PcHRzIiwiY29uZmlnIiwib3B0cyIsImFyZ3YiLCJhcmd2RW5kIiwic3RvcEF0IiwiaWdub3JlRXF1YWxzIiwibmV4dE9wdCIsImZpbmRJbmRleCIsIkkiLCJvcHRpb25zIiwiZ2V0T3B0cyIsIm9wdGRlZiIsImZvckVhY2giLCJub0FsaWFzUHJvcGFnYXRpb24iLCJub0J1bmRsaW5nIiwibm9NaXhlZE9yZGVyIiwibm9VbmRlZmluZWQiLCJ0ZXJtaW5hdG9yIiwiZHVwbGljYXRlcyIsIm9wdGlvbiIsInVuZGVmaW5lZCIsIlJlZmVyZW5jZUVycm9yIiwiY3VycmVudE9wdGlvbiIsInJlc29sdmVEdXBsaWNhdGUiLCJwcmV2TWF0Y2hlZE5hbWUiLCJlcnJvciIsIlR5cGVFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJhZmZlY3RlZE9wdGlvbiIsImFmZmVjdGVkVmFsdWUiLCJvbGRWYWx1ZXMiLCJuZXdWYWx1ZXMiLCJzdGFja2VkIiwic3RhY2siLCJ2Iiwic2V0VmFsdWUiLCJsYXN0TWF0Y2hlZE5hbWUiLCJ3cmFwSXRVcCIsIm9wdFZhbHVlIiwiZmxpcCIsImFyZyIsIm9wdCIsImZyb20iLCJ0byIsImV4dHJhY3QiLCJzcGxpY2UiLCJuYW1lS2V5cyIsImJ1bmRsZU1hdGNoIiwiYnVuZGxlUGF0dGVybnMiLCJuaWxhZGljQXJncyIsImxlZ2FsTmFtZXMiLCJsYXN0SW5kZXgiLCJuaWxhZGljTWF0Y2giLCJzZWdtZW50cyIsImlzVGVybWluYXRvciIsImtlZXBSZXN0IiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsInZlcnNpb24iLCJDb2xsZWN0aW9uIiwiSXRlcmFibGUiLCJTZXEiLCJNYXAiLCJPcmRlcmVkTWFwIiwiTGlzdCIsIlN0YWNrIiwiU2V0IiwiT3JkZXJlZFNldCIsIlJlY29yZCIsIlJhbmdlIiwiUmVwZWF0IiwiaXMiLCJmcm9tSlMiLCJoYXNoIiwiaXNJbW11dGFibGUiLCJpc0NvbGxlY3Rpb24iLCJpc0tleWVkIiwiaXNJbmRleGVkIiwiaXNBc3NvY2lhdGl2ZSIsImlzT3JkZXJlZCIsImlzVmFsdWVPYmplY3QiLCJnZXRJbiIsImhhcyIsImhhc0luIiwibWVyZ2UkMSIsIm1lcmdlRGVlcCIsIm1lcmdlV2l0aCQxIiwibWVyZ2VEZWVwV2l0aCIsInJlbW92ZSIsInJlbW92ZUluIiwic2V0Iiwic2V0SW4iLCJ1cGRhdGUiLCJ1cGRhdGVJbiIsIkRFTEVURSIsIlNISUZUIiwiU0laRSIsIk1BU0siLCJOT1RfU0VUIiwiTWFrZVJlZiIsIlNldFJlZiIsInJlZiIsIk93bmVySUQiLCJlbnN1cmVTaXplIiwiaXRlciIsInNpemUiLCJfX2l0ZXJhdGUiLCJyZXR1cm5UcnVlIiwid3JhcEluZGV4IiwiaW5kZXgiLCJ1aW50MzJJbmRleCIsIk5hTiIsIndob2xlU2xpY2UiLCJiZWdpbiIsImlzTmVnIiwicmVzb2x2ZUJlZ2luIiwicmVzb2x2ZUluZGV4IiwicmVzb2x2ZUVuZCIsImRlZmF1bHRJbmRleCIsIkluZmluaXR5IiwibWluIiwiSVNfQ09MTEVDVElPTl9TWU1CT0wiLCJtYXliZUNvbGxlY3Rpb24iLCJJU19LRVlFRF9TWU1CT0wiLCJtYXliZUtleWVkIiwiSVNfSU5ERVhFRF9TWU1CT0wiLCJtYXliZUluZGV4ZWQiLCJtYXliZUFzc29jaWF0aXZlIiwiS2V5ZWRDb2xsZWN0aW9uIiwiS2V5ZWRTZXEiLCJfX3Byb3RvX18iLCJJbmRleGVkQ29sbGVjdGlvbiIsIkluZGV4ZWRTZXEiLCJTZXRDb2xsZWN0aW9uIiwiU2V0U2VxIiwiS2V5ZWQiLCJJbmRleGVkIiwiSVNfU0VRX1NZTUJPTCIsImlzU2VxIiwibWF5YmVTZXEiLCJJU19SRUNPUkRfU1lNQk9MIiwiaXNSZWNvcmQiLCJtYXliZVJlY29yZCIsIm1heWJlSW1tdXRhYmxlIiwiSVNfT1JERVJFRF9TWU1CT0wiLCJtYXliZU9yZGVyZWQiLCJJVEVSQVRFX0tFWVMiLCJJVEVSQVRFX1ZBTFVFUyIsIklURVJBVEVfRU5UUklFUyIsIlJFQUxfSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsIklURVJBVE9SX1NZTUJPTCIsIkl0ZXJhdG9yIiwiS0VZUyIsIlZBTFVFUyIsIkVOVFJJRVMiLCJpbnNwZWN0IiwidG9Tb3VyY2UiLCJpdGVyYXRvclZhbHVlIiwidHlwZSIsIml0ZXJhdG9yUmVzdWx0IiwiZG9uZSIsIml0ZXJhdG9yRG9uZSIsImhhc0l0ZXJhdG9yIiwibWF5YmVJdGVyYWJsZSIsImdldEl0ZXJhdG9yRm4iLCJpc0l0ZXJhdG9yIiwibWF5YmVJdGVyYXRvciIsImdldEl0ZXJhdG9yIiwiaXRlcmFibGUiLCJpdGVyYXRvckZuIiwiaXNBcnJheUxpa2UiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJDb2xsZWN0aW9uJCQxIiwiZW1wdHlTZXF1ZW5jZSIsInRvU2VxIiwic2VxRnJvbVZhbHVlIiwiX190b1N0cmluZyIsImNhY2hlUmVzdWx0IiwiX2NhY2hlIiwiX19pdGVyYXRlVW5jYWNoZWQiLCJlbnRyeVNlcSIsInRvQXJyYXkiLCJjYWNoZSIsImVudHJ5IiwiX19pdGVyYXRvciIsIl9faXRlcmF0b3JVbmNhY2hlZCIsInRvS2V5ZWRTZXEiLCJmcm9tRW50cnlTZXEiLCJrZXllZFNlcUZyb21WYWx1ZSIsInRvSW5kZXhlZFNlcSIsImluZGV4ZWRTZXFGcm9tVmFsdWUiLCJvZiIsImFyZ3VtZW50cyIsInRvU2V0U2VxIiwiQXJyYXlTZXEiLCJhcnJheSIsIl9hcnJheSIsIm5vdFNldFZhbHVlIiwiaWkiLCJPYmplY3RTZXEiLCJfb2JqZWN0IiwiX2tleXMiLCJDb2xsZWN0aW9uU2VxIiwiY29sbGVjdGlvbiIsIl9jb2xsZWN0aW9uIiwiaXRlcmF0aW9ucyIsInN0ZXAiLCJFTVBUWV9TRVEiLCJzZXEiLCJtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUiLCJJU19NQVBfU1lNQk9MIiwiaXNNYXAiLCJtYXliZU1hcCIsImlzT3JkZXJlZE1hcCIsIm1heWJlT3JkZXJlZE1hcCIsIm1heWJlVmFsdWUiLCJlcXVhbHMiLCJoYXNoQ29kZSIsInZhbHVlQSIsInZhbHVlQiIsInZhbHVlT2YiLCJpbXVsIiwic21pIiwiaTMyIiwiZGVmYXVsdFZhbHVlT2YiLCJoYXNoTnVtYmVyIiwiU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTiIsImNhY2hlZEhhc2hTdHJpbmciLCJoYXNoU3RyaW5nIiwiaGFzaEpTT2JqIiwiRXJyb3IiLCJzdHJpbmciLCJoYXNoZWQiLCJzdHJpbmdIYXNoQ2FjaGUiLCJTVFJJTkdfSEFTSF9DQUNIRV9TSVpFIiwiU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUiLCJvYmoiLCJ1c2luZ1dlYWtNYXAiLCJ3ZWFrTWFwIiwiVUlEX0hBU0hfS0VZIiwiY2FuRGVmaW5lUHJvcGVydHkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImdldElFTm9kZUhhc2giLCJvYmpIYXNoVUlEIiwiaXNFeHRlbnNpYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJub2RlVHlwZSIsIm5vZGUiLCJ1bmlxdWVJRCIsImRvY3VtZW50RWxlbWVudCIsIldlYWtNYXAiLCJUb0tleWVkU2VxdWVuY2UiLCJLZXllZFNlcSQkMSIsImluZGV4ZWQiLCJ1c2VLZXlzIiwiX2l0ZXIiLCJfdXNlS2V5cyIsInZhbHVlU2VxIiwidGhpcyQxIiwicmV2ZXJzZWRTZXF1ZW5jZSIsInJldmVyc2VGYWN0b3J5IiwibWFwcGVyIiwiY29udGV4dCIsIm1hcHBlZFNlcXVlbmNlIiwibWFwRmFjdG9yeSIsIlRvSW5kZXhlZFNlcXVlbmNlIiwiSW5kZXhlZFNlcSQkMSIsImluY2x1ZGVzIiwiVG9TZXRTZXF1ZW5jZSIsIlNldFNlcSQkMSIsIkZyb21FbnRyaWVzU2VxdWVuY2UiLCJlbnRyaWVzIiwidmFsaWRhdGVFbnRyeSIsImluZGV4ZWRDb2xsZWN0aW9uIiwiY2FjaGVSZXN1bHRUaHJvdWdoIiwiZmxpcEZhY3RvcnkiLCJmbGlwU2VxdWVuY2UiLCJtYWtlU2VxdWVuY2UiLCJmaWx0ZXJGYWN0b3J5IiwicHJlZGljYXRlIiwiZmlsdGVyU2VxdWVuY2UiLCJjb3VudEJ5RmFjdG9yeSIsImdyb3VwZXIiLCJncm91cHMiLCJhc011dGFibGUiLCJhc0ltbXV0YWJsZSIsImdyb3VwQnlGYWN0b3J5IiwiaXNLZXllZEl0ZXIiLCJjb2VyY2UiLCJjb2xsZWN0aW9uQ2xhc3MiLCJhcnIiLCJyZWlmeSIsInNsaWNlRmFjdG9yeSIsIm9yaWdpbmFsU2l6ZSIsInJlc29sdmVkQmVnaW4iLCJyZXNvbHZlZEVuZCIsInJlc29sdmVkU2l6ZSIsInNsaWNlU2l6ZSIsInNsaWNlU2VxIiwic2tpcHBlZCIsImlzU2tpcHBpbmciLCJ0YWtlV2hpbGVGYWN0b3J5IiwidGFrZVNlcXVlbmNlIiwiaXRlcmF0aW5nIiwic2tpcFdoaWxlRmFjdG9yeSIsInNraXBTZXF1ZW5jZSIsInNraXBwaW5nIiwiY29uY2F0RmFjdG9yeSIsImlzS2V5ZWRDb2xsZWN0aW9uIiwiaXRlcnMiLCJzaW5nbGV0b24iLCJjb25jYXRTZXEiLCJmbGF0dGVuIiwicmVkdWNlIiwic3VtIiwiZmxhdHRlbkZhY3RvcnkiLCJkZXB0aCIsImZsYXRTZXF1ZW5jZSIsInN0b3BwZWQiLCJmbGF0RGVlcCIsImN1cnJlbnREZXB0aCIsImZsYXRNYXBGYWN0b3J5IiwiaW50ZXJwb3NlRmFjdG9yeSIsInNlcGFyYXRvciIsImludGVycG9zZWRTZXF1ZW5jZSIsInNvcnRGYWN0b3J5IiwiY29tcGFyYXRvciIsImRlZmF1bHRDb21wYXJhdG9yIiwic29ydCIsIm1heEZhY3RvcnkiLCJtYXhDb21wYXJlIiwiY29tcCIsInppcFdpdGhGYWN0b3J5Iiwia2V5SXRlciIsInppcHBlciIsInppcEFsbCIsInppcFNlcXVlbmNlIiwic2l6ZXMiLCJpdGVyYXRvcnMiLCJpc0RvbmUiLCJzdGVwcyIsImV2ZXJ5IiwiYXJyQ29weSIsIm9mZnNldCIsImxlbiIsIm5ld0FyciIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImFzc2VydE5vdEluZmluaXRlIiwiY29lcmNlS2V5UGF0aCIsImtleVBhdGgiLCJpc1BsYWluT2JqIiwiaXNEYXRhU3RydWN0dXJlIiwicXVvdGVTdHJpbmciLCJfaWdub3JlRXJyb3IiLCJzaGFsbG93Q29weSIsImNvbGxlY3Rpb25Db3B5IiwidXBkYXRlciIsInVwZGF0ZWRWYWx1ZSIsInVwZGF0ZUluRGVlcGx5IiwiaW5JbW11dGFibGUiLCJleGlzdGluZyIsIndhc05vdFNldCIsImV4aXN0aW5nVmFsdWUiLCJuZXdWYWx1ZSIsIm5leHRFeGlzdGluZyIsIm5leHRVcGRhdGVkIiwiZW1wdHlNYXAiLCJzZXRJbiQxIiwiZGVsZXRlSW4iLCJ1cGRhdGUkMSIsInVwZGF0ZUluJDEiLCJtZXJnZSIsIm1lcmdlSW50b0tleWVkV2l0aCIsIm1lcmdlV2l0aCIsIm1lcmdlciIsImNvbGxlY3Rpb25zIiwiY29sbGVjdGlvbiQxIiwiX19vd25lcklEIiwid2l0aE11dGF0aW9ucyIsIm1lcmdlSW50b0NvbGxlY3Rpb24iLCJvbGRWYWwiLCJzb3VyY2VzIiwibWVyZ2VXaXRoU291cmNlcyIsIm1lcmdlRGVlcFdpdGhTb3VyY2VzIiwiZGVlcE1lcmdlcldpdGgiLCJtZXJnZWQiLCJtZXJnZUl0ZW0iLCJoYXNWYWwiLCJuZXh0VmFsIiwiZGVlcE1lcmdlciIsIm9sZFZhbHVlIiwibWVyZ2VEZWVwJDEiLCJtZXJnZURlZXBXaXRoJDEiLCJtZXJnZUluIiwibWVyZ2VEZWVwSW4iLCJtdXRhYmxlIiwid2FzQWx0ZXJlZCIsIl9fZW5zdXJlT3duZXIiLCJfX2FsdGVyZWQiLCJLZXllZENvbGxlY3Rpb24kJDEiLCJrZXlWYWx1ZXMiLCJfcm9vdCIsInVwZGF0ZU1hcCIsImRlbGV0ZUFsbCIsImNsZWFyIiwiX19oYXNoIiwic29ydEJ5IiwiTWFwSXRlcmF0b3IiLCJpdGVyYXRlIiwib3duZXJJRCIsIm1ha2VNYXAiLCJNYXBQcm90b3R5cGUiLCJyZW1vdmVBbGwiLCJBcnJheU1hcE5vZGUiLCJrZXlIYXNoIiwiZGlkQ2hhbmdlU2l6ZSIsImRpZEFsdGVyIiwicmVtb3ZlZCIsImlkeCIsImV4aXN0cyIsIk1BWF9BUlJBWV9NQVBfU0laRSIsImNyZWF0ZU5vZGVzIiwiaXNFZGl0YWJsZSIsIm5ld0VudHJpZXMiLCJCaXRtYXBJbmRleGVkTm9kZSIsImJpdG1hcCIsIm5vZGVzIiwiYml0IiwicG9wQ291bnQiLCJrZXlIYXNoRnJhZyIsIm5ld05vZGUiLCJ1cGRhdGVOb2RlIiwiTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUiLCJleHBhbmROb2RlcyIsImlzTGVhZk5vZGUiLCJuZXdCaXRtYXAiLCJuZXdOb2RlcyIsInNldEF0Iiwic3BsaWNlT3V0Iiwic3BsaWNlSW4iLCJIYXNoQXJyYXlNYXBOb2RlIiwiY291bnQiLCJuZXdDb3VudCIsIk1JTl9IQVNIX0FSUkFZX01BUF9TSVpFIiwicGFja05vZGVzIiwiSGFzaENvbGxpc2lvbk5vZGUiLCJtZXJnZUludG9Ob2RlIiwiVmFsdWVOb2RlIiwia2V5TWF0Y2giLCJtYXhJbmRleCIsIkl0ZXJhdG9yJCQxIiwiX3R5cGUiLCJfcmV2ZXJzZSIsIl9zdGFjayIsIm1hcEl0ZXJhdG9yRnJhbWUiLCJtYXBJdGVyYXRvclZhbHVlIiwic3ViTm9kZSIsIl9fcHJldiIsInByZXYiLCJoYXNoJCQxIiwiRU1QVFlfTUFQIiwibmV3Um9vdCIsIm5ld1NpemUiLCJpZHgxIiwiaWR4MiIsImV4Y2x1ZGluZyIsInBhY2tlZElJIiwicGFja2VkTm9kZXMiLCJpbmNsdWRpbmciLCJleHBhbmRlZE5vZGVzIiwidmFsIiwiY2FuRWRpdCIsIm5ld0FycmF5IiwibmV3TGVuIiwiYWZ0ZXIiLCJJU19MSVNUX1NZTUJPTCIsImlzTGlzdCIsIm1heWJlTGlzdCIsIkluZGV4ZWRDb2xsZWN0aW9uJCQxIiwiZW1wdHkiLCJlbXB0eUxpc3QiLCJtYWtlTGlzdCIsIlZOb2RlIiwibGlzdCIsInNldFNpemUiLCJfb3JpZ2luIiwibGlzdE5vZGVGb3IiLCJ1cGRhdGVMaXN0IiwiaW5zZXJ0IiwiX2NhcGFjaXR5IiwiX2xldmVsIiwiX3RhaWwiLCJvbGRTaXplIiwic2V0TGlzdEJvdW5kcyIsInVuc2hpZnQiLCJhcmd1bWVudHMkMSIsInNlcXMiLCJhcmd1bWVudCIsIml0ZXJhdGVMaXN0IiwiRE9ORSIsIkxpc3RQcm90b3R5cGUiLCJyZW1vdmVCZWZvcmUiLCJsZXZlbCIsIm9yaWdpbkluZGV4IiwicmVtb3ZpbmdGaXJzdCIsIm5ld0NoaWxkIiwib2xkQ2hpbGQiLCJlZGl0YWJsZSIsImVkaXRhYmxlVk5vZGUiLCJyZW1vdmVBZnRlciIsInNpemVJbmRleCIsInRhaWxQb3MiLCJnZXRUYWlsT2Zmc2V0IiwidGFpbCIsIml0ZXJhdGVOb2RlT3JMZWFmIiwiaXRlcmF0ZUxlYWYiLCJpdGVyYXRlTm9kZSIsIm9yaWdpbiIsImNhcGFjaXR5IiwiRU1QVFlfTElTVCIsIm5ld1RhaWwiLCJ1cGRhdGVWTm9kZSIsIm5vZGVIYXMiLCJsb3dlck5vZGUiLCJuZXdMb3dlck5vZGUiLCJyYXdJbmRleCIsIm93bmVyIiwib2xkT3JpZ2luIiwib2xkQ2FwYWNpdHkiLCJuZXdPcmlnaW4iLCJuZXdDYXBhY2l0eSIsIm5ld0xldmVsIiwib2Zmc2V0U2hpZnQiLCJvbGRUYWlsT2Zmc2V0IiwibmV3VGFpbE9mZnNldCIsIm9sZFRhaWwiLCJiZWdpbkluZGV4IiwiTWFwJCQxIiwiZW1wdHlPcmRlcmVkTWFwIiwiX21hcCIsIl9saXN0IiwidXBkYXRlT3JkZXJlZE1hcCIsIm5ld01hcCIsIm5ld0xpc3QiLCJtYWtlT3JkZXJlZE1hcCIsIm9tYXAiLCJFTVBUWV9PUkRFUkVEX01BUCIsInRvTWFwIiwiSVNfU1RBQ0tfU1lNQk9MIiwiaXNTdGFjayIsIm1heWJlU3RhY2siLCJlbXB0eVN0YWNrIiwicHVzaEFsbCIsImhlYWQiLCJfaGVhZCIsInBlZWsiLCJtYWtlU3RhY2siLCJTdGFja1Byb3RvdHlwZSIsInVuc2hpZnRBbGwiLCJFTVBUWV9TVEFDSyIsIklTX1NFVF9TWU1CT0wiLCJpc1NldCIsIm1heWJlU2V0IiwiaXNPcmRlcmVkU2V0IiwibWF5YmVPcmRlcmVkU2V0IiwiZGVlcEVxdWFsIiwibm90QXNzb2NpYXRpdmUiLCJmbGlwcGVkIiwiYWxsRXF1YWwiLCJiU2l6ZSIsIm1peGluIiwiY3RvciIsIm1ldGhvZHMiLCJrZXlDb3BpZXIiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJ0b0pTIiwicmVzdWx0JDEiLCJTZXRDb2xsZWN0aW9uJCQxIiwiZW1wdHlTZXQiLCJhZGQiLCJmcm9tS2V5cyIsImtleVNlcSIsImludGVyc2VjdCIsInNldHMiLCJTZXRQcm90b3R5cGUiLCJ1bmlvbiIsInVwZGF0ZVNldCIsInJlbW92ZXMiLCJhZGRzIiwibWFwcGVkIiwidG9SZW1vdmUiLCJzdWJ0cmFjdCIsIl9fZW1wdHkiLCJfX21ha2UiLCJtYWtlU2V0IiwiRU1QVFlfU0VUIiwiX3N0YXJ0IiwiX2VuZCIsIl9zdGVwIiwiY2VpbCIsIkVNUFRZX1JBTkdFIiwic2VhcmNoVmFsdWUiLCJwb3NzaWJsZUluZGV4IiwiZmxvb3IiLCJvZmZzZXRWYWx1ZSIsImxhc3RJbmRleE9mIiwib3RoZXIiLCJzZWFyY2hLZXlQYXRoIiwiZ2V0SW4kMSIsImhhc0luJDEiLCJ0b09iamVjdCIsImlzSXRlcmFibGUiLCJ1c2VUdXBsZXMiLCJ0b0pTJDEiLCJ0b09yZGVyZWRNYXAiLCJ0b09yZGVyZWRTZXQiLCJ0b1NldCIsInRvU3RhY2siLCJ0b0xpc3QiLCJfX3RvU3RyaW5nTWFwcGVyIiwicmV0dXJuVmFsdWUiLCJmaW5kIiwiZmluZEVudHJ5Iiwic2lkZUVmZmVjdCIsImpvaW5lZCIsImlzRmlyc3QiLCJyZWR1Y2UkMSIsInJlZHVjZXIiLCJpbml0aWFsUmVkdWN0aW9uIiwicmVkdWNlUmlnaHQiLCJub3QiLCJidXRMYXN0IiwiaXNFbXB0eSIsImNvdW50QnkiLCJlbnRyaWVzU2VxdWVuY2UiLCJlbnRyeU1hcHBlciIsImZpbHRlck5vdCIsImZvdW5kIiwiZmluZEtleSIsImZpbmRMYXN0IiwiZmluZExhc3RFbnRyeSIsImZpbmRMYXN0S2V5IiwiZmlyc3QiLCJmbGF0TWFwIiwic2VhcmNoS2V5IiwiZ3JvdXBCeSIsImlzU3Vic2V0IiwiaXNTdXBlcnNldCIsImtleU9mIiwia2V5TWFwcGVyIiwibGFzdCIsImxhc3RLZXlPZiIsIm1heEJ5IiwibmVnIiwiZGVmYXVsdE5lZ0NvbXBhcmF0b3IiLCJtaW5CeSIsInJlc3QiLCJza2lwIiwiYW1vdW50Iiwic2tpcExhc3QiLCJza2lwV2hpbGUiLCJza2lwVW50aWwiLCJ0YWtlIiwidGFrZUxhc3QiLCJ0YWtlV2hpbGUiLCJ0YWtlVW50aWwiLCJoYXNoQ29sbGVjdGlvbiIsIkNvbGxlY3Rpb25Qcm90b3R5cGUiLCJ0b0pTT04iLCJjaGFpbiIsImNvbnRhaW5zIiwibWFwRW50cmllcyIsIm1hcEtleXMiLCJLZXllZENvbGxlY3Rpb25Qcm90b3R5cGUiLCJyZW1vdmVOdW0iLCJudW1BcmdzIiwic3BsaWNlZCIsImZpbmRMYXN0SW5kZXgiLCJpbnRlcnBvc2UiLCJpbnRlcmxlYXZlIiwiemlwcGVkIiwiaW50ZXJsZWF2ZWQiLCJ6aXAiLCJkZWZhdWx0WmlwcGVyIiwiemlwV2l0aCIsIkluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlIiwicmVkdWN0aW9uIiwidXNlRmlyc3QiLCJvcmRlcmVkIiwia2V5ZWQiLCJoIiwiaGFzaE1lcmdlIiwibXVybXVySGFzaE9mU2l6ZSIsIlNldCQkMSIsImVtcHR5T3JkZXJlZFNldCIsIk9yZGVyZWRTZXRQcm90b3R5cGUiLCJtYWtlT3JkZXJlZFNldCIsIkVNUFRZX09SREVSRURfU0VUIiwiZGVmYXVsdFZhbHVlcyIsImhhc0luaXRpYWxpemVkIiwiUmVjb3JkVHlwZSIsImluZGljZXMiLCJSZWNvcmRUeXBlUHJvdG90eXBlIiwiX2luZGljZXMiLCJfbmFtZSIsIl9kZWZhdWx0VmFsdWVzIiwicHJvcE5hbWUiLCJjb25zb2xlIiwid2FybiIsInJlY29yZE5hbWUiLCJzZXRQcm9wIiwiX3ZhbHVlcyIsIlJlY29yZFByb3RvdHlwZSIsImRpc3BsYXlOYW1lIiwicmVjb3JkU2VxIiwibWFrZVJlY29yZCIsImdldERlc2NyaXB0aXZlTmFtZSIsImxpa2VSZWNvcmQiLCJyZWNvcmQiLCJnZXRQcm90b3R5cGVPZiIsInRpbWVzIiwiX3ZhbHVlIiwiRU1QVFlfUkVQRUFUIiwiY29udmVydGVyIiwiZnJvbUpTV2l0aCIsImRlZmF1bHRDb252ZXJ0ZXIiLCJwYXJlbnRWYWx1ZSIsImNvbnZlcnRlZCIsIkltbXV0YWJsZSIsIm1pbmltYXRjaCIsInNwbGl0UmUiLCJlbmRXaXRoTmVnUmUiLCJDYXB0dXJlIiwibWFrZVJlIiwicmVnZXhwIiwiY2FwdHVyZSIsInBhdGgiLCJpc0RlZiIsIm5vdHJpbSIsIm5vbmVnYXRlIiwiX21ha2VSZSIsImZsYWdzIiwibm9jYXNlIiwic3VicGF0dGVybnMiLCJicmFjZUV4cGFuZCIsImV4cHJlc3Npb25zIiwic3VicGF0dGVybiIsIm1pZGRsZSIsImFzc2lnbiIsInJlIiwic291cmNlIiwic3RhcnRzV2l0aCIsInJlZ0V4cEVzY2FwZSIsImNhcCIsIk1pbmltYXRjaCIsInNlcCIsImVyIiwiR0xPQlNUQVIiLCJwbFR5cGVzIiwib3BlbiIsImNsb3NlIiwicW1hcmsiLCJzdGFyIiwidHdvU3RhckRvdCIsInR3b1N0YXJOb0RvdCIsInJlU3BlY2lhbHMiLCJjaGFyU2V0Iiwic2xhc2hTcGxpdCIsImV4dCIsImRlZmF1bHRzIiwiZGVmIiwib3JpZyIsIm5vY29tbWVudCIsImNoYXJBdCIsIm5lZ2F0ZSIsImNvbW1lbnQiLCJtYWtlIiwiZGVidWciLCJfbWFkZSIsInBhcnNlTmVnYXRlIiwiZ2xvYlNldCIsImdsb2JQYXJ0cyIsInNpIiwicGFyc2UiLCJuZWdhdGVPZmZzZXQiLCJub2JyYWNlIiwiU1VCUEFSU0UiLCJpc1N1YiIsIm5vZ2xvYnN0YXIiLCJoYXNNYWdpYyIsImVzY2FwaW5nIiwicGF0dGVybkxpc3RTdGFjayIsIm5lZ2F0aXZlTGlzdHMiLCJzdGF0ZUNoYXIiLCJpbkNsYXNzIiwicmVDbGFzc1N0YXJ0IiwiY2xhc3NTdGFydCIsInBhdHRlcm5TdGFydCIsImRvdCIsInNlbGYiLCJjbGVhclN0YXRlQ2hhciIsIm5vZXh0IiwicmVTdGFydCIsInBsIiwicmVFbmQiLCJjcyIsInN1YnN0cmluZyIsInNwIiwiJDEiLCIkMiIsImFkZFBhdHRlcm5TdGFydCIsIm5sIiwibmxCZWZvcmUiLCJubEZpcnN0IiwibmxMYXN0IiwibmxBZnRlciIsIm9wZW5QYXJlbnNCZWZvcmUiLCJjbGVhbkFmdGVyIiwiZG9sbGFyIiwibmV3UmUiLCJnbG9iVW5lc2NhcGUiLCJyZWdFeHAiLCJfZ2xvYiIsIl9zcmMiLCJ0d29TdGFyIiwiZXgiLCJtbSIsImYiLCJub251bGwiLCJwYXJ0aWFsIiwiZmlsZW5hbWUiLCJmaWxlIiwibWF0Y2hCYXNlIiwiaGl0IiwibWF0Y2hPbmUiLCJmbGlwTmVnYXRlIiwiZmkiLCJwaSIsImZsIiwiZnIiLCJwciIsInN3YWxsb3dlZSIsImVtcHR5RmlsZUVuZCIsInByb2Nlc3MiLCJub3JtYWxpemVBcnJheSIsImFsbG93QWJvdmVSb290IiwidXAiLCJyZXNvbHZlIiwicmVzb2x2ZWRQYXRoIiwicmVzb2x2ZWRBYnNvbHV0ZSIsImN3ZCIsIm5vcm1hbGl6ZSIsImlzQWJzb2x1dGUiLCJ0cmFpbGluZ1NsYXNoIiwicGF0aHMiLCJyZWxhdGl2ZSIsImZyb21QYXJ0cyIsInRvUGFydHMiLCJzYW1lUGFydHNMZW5ndGgiLCJvdXRwdXRQYXJ0cyIsImRlbGltaXRlciIsImRpcm5hbWUiLCJjb2RlIiwiaGFzUm9vdCIsIm1hdGNoZWRTbGFzaCIsImJhc2VuYW1lIiwiZXh0bmFtZSIsInN0YXJ0RG90Iiwic3RhcnRQYXJ0IiwicHJlRG90U3RhdGUiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJydW4iLCJuZXh0VGljayIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJiaW5kaW5nIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsIndlYnBhY2tDb250ZXh0IiwicmVxIiwiaWQiLCJ3ZWJwYWNrQ29udGV4dFJlc29sdmUiLCJ3ZWJwYWNrQ29udGV4dEtleXMiLCJfdHlwZW9mIiwib3B0RGVmIiwiX29wdGlvblBhcnNlciIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJGaWxlT3AiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIk91dHB1dEZhY3RvcnkiLCJfdXRpbCIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlc2MiLCJmaWxlVG9UZXh0T3V0cHV0IiwiZnMiLCJmaWxlUGF0aCIsIl9GaWxlT3AkcmVhZEZpbGUiLCJyZWFkRmlsZSIsImVyciIsIm1ha2VFcnJvck91dHB1dCIsIm1ha2VUZXh0T3V0cHV0IiwiX2RlZmF1bHQiLCJzdGF0ZSIsImNvbW1hbmRPcHRpb25zIiwiX3BhcnNlT3B0aW9ucyIsImZpbGVQYXRocyIsInBhdGhBcmciLCJyZXNvbHZlUGF0aCIsIm91dHB1dHMiLCJnZXRGaWxlU3lzdGVtIiwiRGlyZWN0b3J5T3AiLCJFbnZWYXJpYWJsZVV0aWwiLCJfZnNFcnJvciIsInVwZGF0ZVN0YXRlQ3dkIiwibmV3Q3dkUGF0aCIsInNldEVudmlyb25tZW50VmFyaWFibGUiLCJnZXRFbnZWYXJpYWJsZXMiLCJoYXNEaXJlY3RvcnkiLCJuZXdDd2RQYXRoRG9lc05vdEV4aXN0RXJyIiwibWFrZUVycm9yIiwiZnNFcnJvclR5cGUiLCJOT19TVUNIX0RJUkVDVE9SWSIsInNldEVudlZhcmlhYmxlcyIsIl9vdXRwdXRzIiwic2V0T3V0cHV0cyIsIlBhdGhVdGlsIiwiRmlsZVV0aWwiLCJjb3B5U291cmNlRmlsZSIsInNyY1BhdGgiLCJkZXN0UGF0aCIsImlzVHJhaWxpbmdQYXRoRGVzdCIsImRpckF0VHJhaWxpbmdQYXRoTm9uRXhpc3RlbnRFcnIiLCJfRmlsZU9wJGNvcHlGaWxlIiwiY29weUZpbGUiLCJjb3BpZWRGUyIsInNldEZpbGVTeXN0ZW0iLCJjb3B5U291cmNlRGlyZWN0b3J5IiwibGFzdFBhdGhDb21wb25lbnQiLCJnZXRMYXN0UGF0aFBhcnQiLCJlbXB0eURpciIsIm1ha2VEaXJlY3RvcnkiLCJfRGlyZWN0b3J5T3AkYWRkRGlyZWMiLCJhZGREaXJlY3RvcnkiLCJfZnMiLCJfZXJyIiwiX0RpcmVjdG9yeU9wJGNvcHlEaXJlIiwiY29weURpcmVjdG9yeSIsImlzVHJhaWxpbmdEZXN0UGF0aCIsImlzVHJhaWxpbmdQYXRoIiwicmVjdXJzaXZlIiwiX2Vudmlyb25tZW50VmFyaWFibGVzIiwiVkFSSUFCTEVfR1JPVVBfUkVHRVgiLCJET1VCTEVfU1BBQ0VfUkVHRVgiLCJzdWJzdGl0dXRlRW52VmFyaWFibGVzIiwiZW52aXJvbm1lbnRWYXJpYWJsZXMiLCJpbnB1dFN0ciIsInZhck5hbWUiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwib3V0cHV0U3RyIiwiY2xlYW5TdHIiLCJfaGVhZF90YWlsX3V0aWwiLCJoZWFkVHJpbW1pbmdGbiIsImxpbmVzIiwibGluZUNvdW50IiwiX3RyaW1GaWxlQ29udGVudCIsInRyaW1GaWxlQ29udGVudCIsImNvbnRlbnQiLCJfaGlzdG9yeSIsImNsZWFyU3RhdGVIaXN0b3J5Iiwic2V0SGlzdG9yeSIsInN0cmluZ2lmeVN0YXRlSGlzdG9yeSIsImdldEhpc3RvcnkiLCJjb21tYW5kTmFtZXMiLCJvd25LZXlzIiwiZW51bWVyYWJsZU9ubHkiLCJzeW1ib2xzIiwic3ltIiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwibWFwcGluZyIsImNvbW1hbmROYW1lIiwiX2ltbXV0YWJsZSIsIklNUExJRURfRElSRUNUT1JZX0VOVFJJRVMiLCJyZXNvbHZlRGlyZWN0b3J5VG9MaXN0IiwiZW52VmFyaWFibGVzIiwidG9BYnNvbHV0ZVBhdGgiLCJtYWtlU29ydGVkUmV0dXJuIiwibGlzdGluZyIsInNvcnRlZExpc3RpbmciLCJyZW1vdmVIaWRkZW5GaWxlc0ZpbHRlciIsImRpclBhdGgiLCJfRGlyZWN0b3J5T3AkbGlzdERpcmUiLCJsaXN0RGlyZWN0b3J5IiwiZGlyTGlzdCIsImFsbCIsImFsbW9zdEFsbCIsIkRpck9wIiwiRU1QVFlfRElSIiwibmV3Rm9sZGVyUGF0aCIsIl9EaXJPcCRhZGREaXJlY3RvcnkiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJhcnIyIiwic3RyaW5naWZ5RW52VmFyaWFibGVzIiwidmFyVmFsIiwidmFyS2V5IiwidmFyVmFsdWUiLCJtYWtlTm9QYXRoRXJyb3JPdXRwdXQiLCJub1N1Y2hGaWxlT3JEaXJFcnJvciIsIk5PX1NVQ0hfRklMRV9PUl9ESVJFQ1RPUlkiLCJkZWxldGlvblBhdGgiLCJub1ByZXNlcnZlUm9vdCIsIl9yZWYiLCJkZWxldGVEaXJlY3RvcnkiLCJkZWxldGVGaWxlIiwiZGVsZXRlZFBhdGhGUyIsInBhdGhUb0RlbGV0ZSIsIl9EaXJPcCRkZWxldGVEaXJlY3RvciIsInRhaWxUcmltbWluZ0ZuIiwiRU1QVFlfRklMRSIsIm1ha2VGaWxlIiwiX0ZpbGVPcCR3cml0ZUZpbGUiLCJ3cml0ZUZpbGUiLCJERUZBVUxUX0xJTkVfQ09VTlQiLCJ0cmltbWluZ0ZuIiwibGluZXNDb3VudCIsInRyaW1tZWRMaW5lcyIsIkZBTExCQUNLX1VTRVJOQU1FIiwiT3V0cHV0VHlwZSIsImRlZmF1bHQiLCJtYWtlSGVhZGVyT3V0cHV0IiwiT3V0cHV0UmVjb3JkIiwiX291dHB1dFR5cGUiLCJjb21tYW5kIiwiSEVBREVSX09VVFBVVF9UWVBFIiwiVEVYVF9PVVRQVVRfVFlQRSIsIlRFWFRfRVJST1JfT1VUUFVUX1RZUEUiLCJfY29tbWFuZE1hcHBpbmciLCJfZmlsZVN5c3RlbSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIkZTX0tFWSIsIkVOVklST05NRU5UX1ZBUklBQkxFU19LRVkiLCJISVNUT1JZX0tFWSIsIk9VVFBVVFNfS0VZIiwiQ09NTUFORF9NQVBQSU5HX0tFWSIsIkVtdWxhdG9yU3RhdGUiLCJpbW11dGFibGUiLCJnZXRJbW11dGFibGUiLCJuZXdGaWxlU3lzdGVtIiwibmV3RW52VmFyaWFibGVzIiwibmV3SGlzdG9yeSIsImdldE91dHB1dHMiLCJuZXdPdXRwdXRzIiwiZ2V0Q29tbWFuZE1hcHBpbmciLCJzZXRDb21tYW5kTWFwcGluZyIsIm5ld0NvbW1hbmRNYXBwaW5nIiwiY3JlYXRlRW1wdHkiLCJfTWFwIiwiX3JlZiRmcyIsIl9yZWYkZW52aXJvbm1lbnRWYXJpYSIsIl9yZWYkaGlzdG9yeSIsImhpc3RvcnkiLCJfcmVmJG91dHB1dHMiLCJfcmVmJGNvbW1hbmRNYXBwaW5nIiwiY29tbWFuZE1hcHBpbmciLCJzdGF0ZU1hcCIsImdldENvbW1hbmROYW1lcyIsImdldENvbW1hbmRPcHREZWYiLCJnZXRDb21tYW5kRm4iLCJ1bnNldENvbW1hbmQiLCJzZXRDb21tYW5kIiwiaXNDb21tYW5kU2V0IiwiX2NvbW1hbmRzIiwiX2kiLCJfT2JqZWN0JGtleXMiLCJjb21tYW5kRm4iLCJ1bnNldEVudmlyb25tZW50VmFyaWFibGUiLCJkZWZhdWx0VmFyaWFibGVzIiwiREVGQVVMVF9GSUxFX1NZU1RFTSIsImpzRnMiLCJmaWxsR2FwcyIsInJlY29yZENvbW1hbmQiLCJjb21tYW5kUnVuIiwiQ29tbWFuZE1hcHBpbmciLCJFbnZpcm9ubWVudFZhcmlhYmxlcyIsIkZpbGVTeXN0ZW0iLCJIaXN0b3J5IiwiT3V0cHV0cyIsIl9FbXVsYXRvclN0YXRlIiwiYWRkUmVjb3JkIiwib3V0cHV0UmVjb3JkIiwic3VnZ2VzdEZpbGVTeXN0ZW1OYW1lcyIsInN1Z2dlc3RDb21tYW5kT3B0aW9ucyIsInN1Z2dlc3RDb21tYW5kcyIsIkdsb2JVdGlsIiwiY21kTWFwcGluZyIsInBhcnRpYWxTdHIiLCJjb21tYW5kTmFtZVNlcSIsImdsb2JTZXEiLCJvcHREZWZTZXEiLCJmaWxlU3lzdGVtIiwiY29tcGxldGVOYW1lUGF0dGVybiIsImNvbXBsZXRlU3ViZm9sZGVyUGF0dGVybiIsImdsb2JQYXR0ZXJuIiwiZW5kc1dpdGgiLCJjaGlsZFBhdGhzIiwiZ2xvYlBhdGhzIiwiaXNBYnNQYXRoIiwicGF0aFBhcnRzV2l0aG91dFRhaWwiLCJ0b1BhdGhQYXJ0cyIsInRvUGF0aCIsIm1ha2VSdW5uZXJFcnJvck91dHB1dCIsIl9lbXVsYXRvckVycm9yIiwiX291dHB1dEZhY3RvcnkiLCJDb21tYW5kTWFwcGluZ1V0aWwiLCJlcnJvclR5cGUiLCJjb21tYW5kQXJncyIsImVycm9yU3RyIiwiZW11bGF0b3JFcnJvclR5cGUiLCJDT01NQU5EX05PVF9GT1VORCIsIm5vdEZvdW5kQ2FsbGJhY2siLCJmYXRhbENvbW1hbmRFcnJvciIsIlVORVhQRUNURURfQ09NTUFORF9GQUlMVVJFIiwibWVzc2FnZSIsIkNvbW1hbmRSdW5uZXIiLCJfY29tbWFuZFBhcnNlciIsIl9hdXRvQ29tcGxldGUiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsIkYiLCJfZSIsIml0Iiwibm9ybWFsQ29tcGxldGlvbiIsImRpZEVyciIsIl9lMiIsIkVtdWxhdG9yIiwiYXV0b2NvbXBsZXRlIiwic3VnZ2VzdGlvbnMiLCJzdWdnZXN0Iiwic3RyUGFydHMiLCJhdXRvY29tcGxldGVkVGV4dCIsImxhc3RWYWwiLCJfdHJpbUxlYWRpbmdTcGFjZSIsImxhc3RQYXJ0aWFsQ2hhciIsImlzVHlwaW5nTmV3UGFydCIsIl90aGlzJF9nZXRCb3VuZGFyeVdvciIsIl9nZXRCb3VuZGFyeVdvcmRzIiwiY21kTmFtZSIsImxhc3RUZXh0RW50ZXJlZCIsInN0clRvQ29tcGxldGUiLCJleGVjdXRlIiwiZXhlY3V0aW9uTGlzdGVuZXJzIiwiX2l0ZXJhdG9yIiwiZXhlY3V0aW9uTGlzdGVuZXIiLCJvbkV4ZWN1dGVTdGFydGVkIiwiX2FkZEhlYWRlck91dHB1dCIsIl9hZGRDb21tYW5kT3V0cHV0cyIsIl9hZGRDb21tYW5kVG9IaXN0b3J5IiwiX3VwZGF0ZVN0YXRlQnlFeGVjdXRpb24iLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiX2V4ZWN1dGlvbkxpc3RlbmVyIiwib25FeGVjdXRlQ29tcGxldGVkIiwiY29tbWFuZFN0clRvRXhlY3V0ZSIsIl9pdGVyYXRvcjMiLCJfc3RlcDMiLCJfc3RlcDMkdmFsdWUiLCJfQ29tbWFuZFJ1bm5lciRydW4iLCJuZXh0U3RhdGUiLCJjb21tYW5kU3RyIiwiX2l0ZXJhdG9yNCIsIl9zdGVwNCIsIkJvdW5kZWRIaXN0b3J5SXRlcmF0b3IiLCJoaXN0b3J5U3RhY2siLCJoYXNVcCIsImhhc0Rvd24iLCJkb3duIiwiX0JvdW5kZWRIaXN0b3J5SXRlcmF0b3IiLCJIaXN0b3J5S2V5Ym9hcmRQbHVnaW4iLCJfbnVsbGFibGVIaXN0b3J5SXRlcmF0b3IiLCJjb21wbGV0ZVVwIiwiY3JlYXRlSGlzdG9yeUl0ZXJhdG9ySWZOdWxsIiwiY29tcGxldGVEb3duIiwiRklMRV9FWElTVFMiLCJESVJFQ1RPUllfRVhJU1RTIiwiRElSRUNUT1JZX05PVF9FTVBUWSIsIk5PX1NVQ0hfRklMRSIsIkZJTEVfT1JfRElSRUNUT1JZX0VYSVNUUyIsIklTX0FfRElSRUNUT1JZIiwiTk9UX0FfRElSRUNUT1JZIiwiUEVSTUlTU0lPTl9ERU5JRUQiLCJPVEhFUiIsInJlbmFtZURpcmVjdG9yeSIsImxpc3REaXJlY3RvcnlGb2xkZXJzIiwibGlzdERpcmVjdG9yeUZpbGVzIiwiRGlyZWN0b3J5T3BlcmF0aW9ucyIsIlBlcm1pc3Npb25VdGlsIiwibWFrZURpcmVjdG9yeU9wZXJhdGlvblBlcm1pc3Npb25FcnJvciIsImNhbk1vZGlmeVBhdGgiLCJfbGVuIiwiX2tleSIsIl9sZW4yIiwiX2tleTIiLCJfbGVuMyIsIl9rZXkzIiwiY3VycmVudFBhdGgiLCJuZXdQYXRoIiwiaGFzRmlsZSIsIkZpbGVPcGVyYXRpb25zIiwibWFrZUZpbGVPcGVyYXRpb25QZXJtaXNzaW9uRXJyb3IiLCJzb3VyY2VQYXRoIiwicGF0aFRvQWRkIiwiZnNFbGVtZW50VG9BZGQiLCJhZGRQYXJlbnRQYXRocyIsInBhcmVudFBhdGhzIiwiZ2V0UGF0aEJyZWFkQ3J1bWJzIiwicGFyZW50UGF0aCIsImFkZGVkRGlyZWN0b3J5RnMiLCJwYXRoVG9SZW1vdmUiLCJpc05vbkVtcHR5RGlyZWN0b3J5UmVtb3ZhYmxlIiwiY2hpbGRQYXRoUGF0dGVybiIsIkJhc2VPcCIsIl9maWxlT3BlcmF0aW9ucyIsIl9zbGljZWRUb0FycmF5IiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX25vbkl0ZXJhYmxlUmVzdCIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZTMiLCJvbmx5RmlsZXNGaWx0ZXIiLCJpc0ZpbGUiLCJvbmx5RGlyZWN0b3JpZXNGaWx0ZXIiLCJpc0RpcmVjdG9yeSIsImVtcHR5RGlyZWN0b3J5IiwiZGlyZWN0b3J5R2FwUGF0aHMiLCJkaXJlY3RvcnlHYXBQYXRoIiwiZmlsZXNQYXR0ZXJuIiwiY2FwdHVyZUdsb2JQYXRocyIsImlzVHJhaWxpbmdTbGFzaEFwcGVuZGVkIiwiZm9sZGVyc1BhdHRlcm4iLCJmb2xkZXJOYW1lcyIsImZvbGRlck5hbWUiLCJhZGRUcmFpbGluZ1NsYXNoIiwiX2xpc3REaXJlY3RvcnlGaWxlcyIsImxpc3RGaWxlRXJyIiwiZmlsZUxpc3QiLCJfbGlzdERpcmVjdG9yeUZvbGRlcnMiLCJsaXN0Rm9sZGVyRXJyIiwiZm9sZGVyTGlzdCIsImdldFBhdGhQYXJlbnQiLCJpc1BhdGhUeXBlTWF0Y2hpbmciLCJwYXRoU2VxIiwiX3N0ZXAyJHZhbHVlIiwib3ZlcndyaXRlIiwic3JjQ2hpbGRQYXR0ZXJuIiwic3JjUGF0aHMiLCJzcmNTdWJQYXRocyIsImRlc3RQYXRocyIsIm5ld0ZzIiwiX3NyY1BhdGgiLCJfZGVzdFBhdGgiLCJfY29weURpcmVjdG9yeSIsIl9maWxlVXRpbCIsIl9kaXJlY3RvcnlPcGVyYXRpb25zIiwicG9zc2libGVGaWxlIiwicGF0aFBhcmVudCIsInNvdXJjZUZpbGVOYW1lIiwibWV0YWRhdGEiLCJnbG9iIiwiX21pbmltYXRjaCIsIl9taW5pbWF0Y2hDYXB0dXJlIiwiR0xPQl9PUFRJT05TIiwiZmlsdGVyQ29uZGl0aW9uIiwiY2FwdHVyZXMiLCJwYXRoQ2FwdHVyZXMiLCJzcGxpdEZpbGVQYXRoIiwicmVtb3ZlVHJhaWxpbmdTZXBhcmF0b3IiLCJfdG9BcnJheSIsInBhdGhQYXJ0cyIsIl9wYXRoUGFydHMiLCJub25Sb290UGF0aFBhcnRzIiwiX3BhdGhQYXJ0czIiLCJfcGF0aFBhcnRzMyIsInNlY29uZFBhdGhQYXJ0IiwicGF0aFBhcnRzV2l0aG91dFJvb3QiLCJicmVhZENydW1icyIsInBhdGhQYXJ0IiwicHJldmlvdXNCcmVhZENydW1iIiwicGF0aFBhcnRzV2l0aG91dEZpbGVOYW1lIiwiR09fVVAiLCJDVVJSRU5UX0RJUiIsImlzU3RhY2tBdFJvb3REaXJlY3RvcnkiLCJyZWxhdGl2ZVBhdGgiLCJwYXRoU3RhY2siLCJERUZBVUxUX1BFUk1JU1NJT04iLCJpc01vZGlmaWNhdGlvbkFsbG93ZWQiLCJkaXJlY3RvcnkiLCJjYW5Nb2RpZnkiLCJicmVhZENydW1iUGF0aHMiLCJicmVhZENydW1iUGF0aCIsIl9lbXVsYXRvciIsIl9IaXN0b3J5S2V5Ym9hcmRQbHVnaW4iLCJfZW11bGF0b3JTdGF0ZSIsIl9lbXVsYXRvck91dHB1dCIsIl9wYXJzZXIiLCJPcHRpb25QYXJzZXIiLCJwYXJzZUNvbW1hbmRzIiwicmVtb3ZlRXhjZXNzV2hpdGVTcGFjZSIsInRvQ29tbWFuZFBhcnRzIiwiY29tbWFuZHMiLCJfcmVmMiIsInBhcnNlT3B0aW9ucyIsIl9nZXRPcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/javascript-terminal-turtle/lib/terminal.js\n");

/***/ })

};
;